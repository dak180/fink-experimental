diff -uNr libcxx-3.7.0.src.orig/.gitignore libcxx-3.7.0.src/.gitignore
--- libcxx-3.7.0.src.orig/.gitignore	2015-02-20 10:36:58.000000000 -0500
+++ libcxx-3.7.0.src/.gitignore	2015-07-04 22:33:31.000000000 -0400
@@ -52,3 +52,19 @@
 
 # PyBuilder
 target/
+
+# old ignores
+*.ii
+*.ii-*
+*.s
+*.s-*
+*.o
+*.o-*
+*.dylib
+*.a
+temp.*
+a.out
+*.pass
+*.fail
+*.log
+*.bz2
diff -uNr libcxx-3.7.0.src.orig/cmake/Modules/HandleLibCXXABI.cmake libcxx-3.7.0.src/cmake/Modules/HandleLibCXXABI.cmake
--- libcxx-3.7.0.src.orig/cmake/Modules/HandleLibCXXABI.cmake	2015-05-20 07:02:22.000000000 -0400
+++ libcxx-3.7.0.src/cmake/Modules/HandleLibCXXABI.cmake	2015-07-04 22:33:31.000000000 -0400
@@ -60,9 +60,12 @@
 
 if ("${LIBCXX_CXX_ABI_LIBNAME}" STREQUAL "libstdc++" OR
     "${LIBCXX_CXX_ABI_LIBNAME}" STREQUAL "libsupc++")
+# some headers were absent on older darwin libstdc++
   set(_LIBSUPCXX_INCLUDE_FILES
-    cxxabi.h bits/c++config.h bits/os_defines.h bits/cpu_defines.h
-    bits/cxxabi_tweaks.h bits/cxxabi_forced.h
+    cxxabi.h bits/c++config.h bits/os_defines.h
+# bits/cpu_defines.h
+    bits/cxxabi_tweaks.h
+# bits/cxxabi_forced.h
     )
   if ("${LIBCXX_CXX_ABI_LIBNAME}" STREQUAL "libstdc++")
     set(_LIBSUPCXX_DEFINES "-DLIBSTDCXX")
diff -uNr libcxx-3.7.0.src.orig/include/__atomic_locked libcxx-3.7.0.src/include/__atomic_locked
--- libcxx-3.7.0.src.orig/include/__atomic_locked	1969-12-31 19:00:00.000000000 -0500
+++ libcxx-3.7.0.src/include/__atomic_locked	2015-07-04 22:33:31.000000000 -0400
@@ -0,0 +1,240 @@
+// -*- C++ -*-
+//===--------------------------- __atomic_locked --------------------------===//
+//
+//                     The LLVM Compiler Infrastructure
+//
+// This file is distributed under the University of Illinois Open Source
+// License. See LICENSE.TXT for details.
+//
+//===----------------------------------------------------------------------===//
+
+#ifndef _LIBCPP_ATOMIC_LOCKED
+#define _LIBCPP_ATOMIC_LOCKED
+
+#include <__mutex_base>	// for mutex and lock_guard
+
+/**
+	This provides slow-but-usable lock-based atomic access to
+	structures for which atomic lock-free functions are missing.
+	This is motivated by the desire for 64b atomic operations
+	on 32b PowerPC architectures.  
+**/
+
+#if !defined(_LIBCPP_HAS_NO_PRAGMA_SYSTEM_HEADER)
+#pragma GCC system_header
+#endif
+
+_LIBCPP_BEGIN_NAMESPACE_STD
+
+template <class _Tp, bool = is_integral<_Tp>::value && !is_same<_Tp, bool>::value>
+struct __atomic_mutex_locked  // false
+{
+    mutable _Atomic(_Tp) __a_;
+    mutable mutex __lock_;
+    typedef lock_guard<mutex>	lock_type;
+
+    _Tp& na(void) const { return reinterpret_cast<_Tp&>(__a_); }
+    volatile _Tp& na(void) const volatile { return reinterpret_cast<volatile _Tp&>(__a_); }
+
+    _LIBCPP_INLINE_VISIBILITY
+    bool is_lock_free() const volatile _NOEXCEPT
+        {return false;}
+    _LIBCPP_INLINE_VISIBILITY
+    bool is_lock_free() const _NOEXCEPT
+        {return false;}
+    _LIBCPP_INLINE_VISIBILITY
+    void store(_Tp __d, memory_order = memory_order_seq_cst) volatile _NOEXCEPT
+        { const lock_type g(const_cast<mutex&>(__lock_)); na() = __d; }
+    _LIBCPP_INLINE_VISIBILITY
+    void store(_Tp __d, memory_order = memory_order_seq_cst) _NOEXCEPT
+        { const lock_type g(__lock_); na() = __d; }
+    _LIBCPP_INLINE_VISIBILITY
+    _Tp load(memory_order = memory_order_seq_cst) const volatile _NOEXCEPT
+        { const lock_type g(const_cast<mutex&>(__lock_)); return na(); }
+    _LIBCPP_INLINE_VISIBILITY
+    _Tp load(memory_order = memory_order_seq_cst) const _NOEXCEPT
+        { const lock_type g(__lock_); return na(); }
+    _LIBCPP_INLINE_VISIBILITY
+    operator _Tp() const volatile _NOEXCEPT {return load();}
+    _LIBCPP_INLINE_VISIBILITY
+    operator _Tp() const _NOEXCEPT          {return load();}
+    _LIBCPP_INLINE_VISIBILITY
+    _Tp exchange(_Tp __d, memory_order = memory_order_seq_cst) volatile _NOEXCEPT
+        { const lock_type g(const_cast<mutex&>(__lock_));
+	// or use std::swap
+          const _Tp ret = na(); na() = __d; return ret; }
+    _LIBCPP_INLINE_VISIBILITY
+    _Tp exchange(_Tp __d, memory_order = memory_order_seq_cst) _NOEXCEPT
+        { const lock_type g(__lock_);
+	// or use std::swap
+          const _Tp ret = na(); na() = __d; return ret; }
+    _LIBCPP_INLINE_VISIBILITY
+    bool compare_exchange_weak(_Tp& __e, _Tp __d,
+                               memory_order __s, memory_order __f) volatile _NOEXCEPT
+        { const lock_type g(const_cast<mutex&>(__lock_));
+	  if (na() == __e) { na() = __d; return true; }
+	  else { __e = na(); return false; }
+	}
+    _LIBCPP_INLINE_VISIBILITY
+    bool compare_exchange_weak(_Tp& __e, _Tp __d,
+                               memory_order __s, memory_order __f) _NOEXCEPT
+        { const lock_type g(__lock_);
+	  if (na() == __e) { na() = __d; return true; }
+	  else { __e = na(); return false; }
+	}
+
+    // for now, _weak inditinguishable from _strong
+    _LIBCPP_INLINE_VISIBILITY
+    bool compare_exchange_strong(_Tp& __e, _Tp __d,
+                                 memory_order __s, memory_order __f) volatile _NOEXCEPT
+        {return compare_exchange_weak(__e, __d, __s, __f);}
+    _LIBCPP_INLINE_VISIBILITY
+    bool compare_exchange_strong(_Tp& __e, _Tp __d,
+                                 memory_order __s, memory_order __f) _NOEXCEPT
+        {return compare_exchange_weak(__e, __d, __s, __f);}
+    _LIBCPP_INLINE_VISIBILITY
+    bool compare_exchange_weak(_Tp& __e, _Tp __d,
+                              memory_order __m = memory_order_seq_cst) volatile _NOEXCEPT
+        {return compare_exchange_weak(__e, __d, __m, __m);}
+    _LIBCPP_INLINE_VISIBILITY
+    bool compare_exchange_weak(_Tp& __e, _Tp __d,
+                               memory_order __m = memory_order_seq_cst) _NOEXCEPT
+        {return compare_exchange_weak(__e, __d, __m, __m);}
+    _LIBCPP_INLINE_VISIBILITY
+    bool compare_exchange_strong(_Tp& __e, _Tp __d,
+                              memory_order __m = memory_order_seq_cst) volatile _NOEXCEPT
+        {return compare_exchange_strong(__e, __d, __m, __m);}
+    _LIBCPP_INLINE_VISIBILITY
+    bool compare_exchange_strong(_Tp& __e, _Tp __d,
+                                 memory_order __m = memory_order_seq_cst) _NOEXCEPT
+        {return compare_exchange_strong(__e, __d, __m, __m);}
+
+    _LIBCPP_INLINE_VISIBILITY
+#ifndef _LIBCPP_HAS_NO_DEFAULTED_FUNCTIONS
+    __atomic_mutex_locked() _NOEXCEPT = default;
+#else
+    __atomic_mutex_locked() _NOEXCEPT : __a_() {}
+#endif // _LIBCPP_HAS_NO_DEFAULTED_FUNCTIONS
+
+    _LIBCPP_INLINE_VISIBILITY
+    _LIBCPP_CONSTEXPR __atomic_mutex_locked(_Tp __d) _NOEXCEPT : __a_(__d) {}
+#ifndef _LIBCPP_HAS_NO_DELETED_FUNCTIONS
+    __atomic_mutex_locked(const __atomic_mutex_locked&) = delete;
+    __atomic_mutex_locked& operator=(const __atomic_mutex_locked&) = delete;
+    __atomic_mutex_locked& operator=(const __atomic_mutex_locked&) volatile = delete;
+#else  // _LIBCPP_HAS_NO_DELETED_FUNCTIONS
+private:
+    __atomic_mutex_locked(const __atomic_mutex_locked&);
+    __atomic_mutex_locked& operator=(const __atomic_mutex_locked&);
+    __atomic_mutex_locked& operator=(const __atomic_mutex_locked&) volatile;
+#endif  // _LIBCPP_HAS_NO_DELETED_FUNCTIONS
+};	// end struct __atomic_mutex_locked
+
+// atomic<Integral>
+
+template <class _Tp>
+struct __atomic_mutex_locked<_Tp, true>
+    : public __atomic_mutex_locked<_Tp, false>
+{
+    typedef __atomic_mutex_locked<_Tp, false> __base;
+    typedef	typename __base::lock_type	lock_type;
+    using __base::__lock_;
+    using __base::na;
+
+    _LIBCPP_INLINE_VISIBILITY
+    __atomic_mutex_locked() _NOEXCEPT _LIBCPP_DEFAULT
+    _LIBCPP_INLINE_VISIBILITY
+    _LIBCPP_CONSTEXPR __atomic_mutex_locked(_Tp __d) _NOEXCEPT : __base(__d) {}
+
+    _LIBCPP_INLINE_VISIBILITY
+    _Tp fetch_add(_Tp __op, memory_order __m = memory_order_seq_cst) volatile _NOEXCEPT
+        { const lock_type g(const_cast<mutex&>(__lock_));
+	  const _Tp ret = na(); na() += __op; return ret;
+	}
+    _LIBCPP_INLINE_VISIBILITY
+    _Tp fetch_add(_Tp __op, memory_order __m = memory_order_seq_cst) _NOEXCEPT
+        { const lock_type g(__lock_);
+	  const _Tp ret = na(); na() += __op; return ret;
+	}
+    _LIBCPP_INLINE_VISIBILITY
+    _Tp fetch_sub(_Tp __op, memory_order __m = memory_order_seq_cst) volatile _NOEXCEPT
+        { const lock_type g(const_cast<mutex&>(__lock_));
+	  const _Tp ret = na(); na() -= __op; return ret;
+	}
+    _LIBCPP_INLINE_VISIBILITY
+    _Tp fetch_sub(_Tp __op, memory_order __m = memory_order_seq_cst) _NOEXCEPT
+        { const lock_type g(__lock_);
+	  const _Tp ret = na(); na() -= __op; return ret;
+	}
+    _LIBCPP_INLINE_VISIBILITY
+    _Tp fetch_and(_Tp __op, memory_order __m = memory_order_seq_cst) volatile _NOEXCEPT
+        { const lock_type g(const_cast<mutex&>(__lock_));
+	  const _Tp ret = na(); na() &= __op; return ret;
+	}
+    _LIBCPP_INLINE_VISIBILITY
+    _Tp fetch_and(_Tp __op, memory_order __m = memory_order_seq_cst) _NOEXCEPT
+        { const lock_type g(__lock_);
+	  const _Tp ret = na(); na() &= __op; return ret;
+	}
+    _LIBCPP_INLINE_VISIBILITY
+    _Tp fetch_or(_Tp __op, memory_order __m = memory_order_seq_cst) volatile _NOEXCEPT
+        { const lock_type g(const_cast<mutex&>(__lock_));
+	  const _Tp ret = na(); na() |= __op; return ret;
+	}
+    _LIBCPP_INLINE_VISIBILITY
+    _Tp fetch_or(_Tp __op, memory_order __m = memory_order_seq_cst) _NOEXCEPT
+        { const lock_type g(__lock_);
+	  const _Tp ret = na(); na() |= __op; return ret;
+	}
+    _LIBCPP_INLINE_VISIBILITY
+    _Tp fetch_xor(_Tp __op, memory_order __m = memory_order_seq_cst) volatile _NOEXCEPT
+        { const lock_type g(const_cast<mutex&>(__lock_));
+	  const _Tp ret = na(); na() ^= __op; return ret;
+	}
+    _LIBCPP_INLINE_VISIBILITY
+    _Tp fetch_xor(_Tp __op, memory_order __m = memory_order_seq_cst) _NOEXCEPT
+        { const lock_type g(__lock_);
+	  const _Tp ret = na(); na() ^= __op; return ret;
+	}
+
+    _LIBCPP_INLINE_VISIBILITY
+    _Tp operator++(int) volatile _NOEXCEPT      {return fetch_add(_Tp(1));}
+    _LIBCPP_INLINE_VISIBILITY
+    _Tp operator++(int) _NOEXCEPT               {return fetch_add(_Tp(1));}
+    _LIBCPP_INLINE_VISIBILITY
+    _Tp operator--(int) volatile _NOEXCEPT      {return fetch_sub(_Tp(1));}
+    _LIBCPP_INLINE_VISIBILITY
+    _Tp operator--(int) _NOEXCEPT               {return fetch_sub(_Tp(1));}
+    _LIBCPP_INLINE_VISIBILITY
+    _Tp operator++() volatile _NOEXCEPT         {return fetch_add(_Tp(1)) + _Tp(1);}
+    _LIBCPP_INLINE_VISIBILITY
+    _Tp operator++() _NOEXCEPT                  {return fetch_add(_Tp(1)) + _Tp(1);}
+    _LIBCPP_INLINE_VISIBILITY
+    _Tp operator--() volatile _NOEXCEPT         {return fetch_sub(_Tp(1)) - _Tp(1);}
+    _LIBCPP_INLINE_VISIBILITY
+    _Tp operator--() _NOEXCEPT                  {return fetch_sub(_Tp(1)) - _Tp(1);}
+    _LIBCPP_INLINE_VISIBILITY
+    _Tp operator+=(_Tp __op) volatile _NOEXCEPT {return fetch_add(__op) + __op;}
+    _LIBCPP_INLINE_VISIBILITY
+    _Tp operator+=(_Tp __op) _NOEXCEPT          {return fetch_add(__op) + __op;}
+    _LIBCPP_INLINE_VISIBILITY
+    _Tp operator-=(_Tp __op) volatile _NOEXCEPT {return fetch_sub(__op) - __op;}
+    _LIBCPP_INLINE_VISIBILITY
+    _Tp operator-=(_Tp __op) _NOEXCEPT          {return fetch_sub(__op) - __op;}
+    _LIBCPP_INLINE_VISIBILITY
+    _Tp operator&=(_Tp __op) volatile _NOEXCEPT {return fetch_and(__op) & __op;}
+    _LIBCPP_INLINE_VISIBILITY
+    _Tp operator&=(_Tp __op) _NOEXCEPT          {return fetch_and(__op) & __op;}
+    _LIBCPP_INLINE_VISIBILITY
+    _Tp operator|=(_Tp __op) volatile _NOEXCEPT {return fetch_or(__op) | __op;}
+    _LIBCPP_INLINE_VISIBILITY
+    _Tp operator|=(_Tp __op) _NOEXCEPT          {return fetch_or(__op) | __op;}
+    _LIBCPP_INLINE_VISIBILITY
+    _Tp operator^=(_Tp __op) volatile _NOEXCEPT {return fetch_xor(__op) ^ __op;}
+    _LIBCPP_INLINE_VISIBILITY
+    _Tp operator^=(_Tp __op) _NOEXCEPT          {return fetch_xor(__op) ^ __op;}
+};
+
+_LIBCPP_END_NAMESPACE_STD
+
+#endif  // _LIBCPP_ATOMIC_LOCKED
diff -uNr libcxx-3.7.0.src.orig/include/atomic libcxx-3.7.0.src/include/atomic
--- libcxx-3.7.0.src.orig/include/atomic	2015-06-15 18:10:22.000000000 -0400
+++ libcxx-3.7.0.src/include/atomic	2015-07-04 22:33:31.000000000 -0400
@@ -1795,6 +1795,51 @@
 
 _LIBCPP_END_NAMESPACE_STD
 
+#if	defined(__ppc__) && !defined(__ppc64__)
+// specialize fallback implementation where 64b atomics are missing
+#include <__atomic_locked>
+
+_LIBCPP_BEGIN_NAMESPACE_STD
+
+template <>
+struct atomic<long long> : public __atomic_mutex_locked<long long>
+{
+    typedef long long		_Tp;
+    typedef __atomic_mutex_locked<_Tp> __base;
+    _LIBCPP_INLINE_VISIBILITY
+    atomic() _NOEXCEPT _LIBCPP_DEFAULT
+    _LIBCPP_INLINE_VISIBILITY
+    _LIBCPP_CONSTEXPR atomic(_Tp __d) _NOEXCEPT : __base(__d) {}
+
+    _LIBCPP_INLINE_VISIBILITY
+    _Tp operator=(_Tp __d) volatile _NOEXCEPT
+        {__base::store(__d); return __d;}
+    _LIBCPP_INLINE_VISIBILITY
+    _Tp operator=(_Tp __d) _NOEXCEPT
+        {__base::store(__d); return __d;}
+};
+
+template <>
+struct atomic<unsigned long long> :
+	public __atomic_mutex_locked<unsigned long long>
+{
+    typedef unsigned long long		_Tp;
+    typedef __atomic_mutex_locked<_Tp> __base;
+    _LIBCPP_INLINE_VISIBILITY
+    atomic() _NOEXCEPT _LIBCPP_DEFAULT
+    _LIBCPP_INLINE_VISIBILITY
+    _LIBCPP_CONSTEXPR atomic(_Tp __d) _NOEXCEPT : __base(__d) {}
+
+    _LIBCPP_INLINE_VISIBILITY
+    _Tp operator=(_Tp __d) volatile _NOEXCEPT
+        {__base::store(__d); return __d;}
+    _LIBCPP_INLINE_VISIBILITY
+    _Tp operator=(_Tp __d) _NOEXCEPT
+        {__base::store(__d); return __d;}
+};
+
+_LIBCPP_END_NAMESPACE_STD
+#endif	// defined(__ppc__) && !defined(__ppc64__)
 #endif  // !_LIBCPP_HAS_NO_THREADS
 
 #endif  // _LIBCPP_ATOMIC
diff -uNr libcxx-3.7.0.src.orig/include/atomic.orig libcxx-3.7.0.src/include/atomic.orig
--- libcxx-3.7.0.src.orig/include/atomic.orig	1969-12-31 19:00:00.000000000 -0500
+++ libcxx-3.7.0.src/include/atomic.orig	2015-06-15 18:10:22.000000000 -0400
@@ -0,0 +1,1800 @@
+// -*- C++ -*-
+//===--------------------------- atomic -----------------------------------===//
+//
+//                     The LLVM Compiler Infrastructure
+//
+// This file is distributed under the University of Illinois Open Source
+// License. See LICENSE.TXT for details.
+//
+//===----------------------------------------------------------------------===//
+
+#ifndef _LIBCPP_ATOMIC
+#define _LIBCPP_ATOMIC
+
+/*
+    atomic synopsis
+
+namespace std
+{
+
+// order and consistency
+
+typedef enum memory_order
+{
+    memory_order_relaxed,
+    memory_order_consume,  // load-consume
+    memory_order_acquire,  // load-acquire
+    memory_order_release,  // store-release
+    memory_order_acq_rel,  // store-release load-acquire
+    memory_order_seq_cst   // store-release load-acquire
+} memory_order;
+
+template <class T> T kill_dependency(T y) noexcept;
+
+// lock-free property
+
+#define ATOMIC_BOOL_LOCK_FREE unspecified
+#define ATOMIC_CHAR_LOCK_FREE unspecified
+#define ATOMIC_CHAR16_T_LOCK_FREE unspecified
+#define ATOMIC_CHAR32_T_LOCK_FREE unspecified
+#define ATOMIC_WCHAR_T_LOCK_FREE unspecified
+#define ATOMIC_SHORT_LOCK_FREE unspecified
+#define ATOMIC_INT_LOCK_FREE unspecified
+#define ATOMIC_LONG_LOCK_FREE unspecified
+#define ATOMIC_LLONG_LOCK_FREE unspecified
+#define ATOMIC_POINTER_LOCK_FREE unspecified
+
+// flag type and operations
+
+typedef struct atomic_flag
+{
+    bool test_and_set(memory_order m = memory_order_seq_cst) volatile noexcept;
+    bool test_and_set(memory_order m = memory_order_seq_cst) noexcept;
+    void clear(memory_order m = memory_order_seq_cst) volatile noexcept;
+    void clear(memory_order m = memory_order_seq_cst) noexcept;
+    atomic_flag()  noexcept = default;
+    atomic_flag(const atomic_flag&) = delete;
+    atomic_flag& operator=(const atomic_flag&) = delete;
+    atomic_flag& operator=(const atomic_flag&) volatile = delete;
+} atomic_flag;
+
+bool
+    atomic_flag_test_and_set(volatile atomic_flag* obj) noexcept;
+
+bool
+    atomic_flag_test_and_set(atomic_flag* obj) noexcept;
+
+bool
+    atomic_flag_test_and_set_explicit(volatile atomic_flag* obj,
+                                      memory_order m) noexcept;
+
+bool
+    atomic_flag_test_and_set_explicit(atomic_flag* obj, memory_order m) noexcept;
+
+void
+    atomic_flag_clear(volatile atomic_flag* obj) noexcept;
+
+void
+    atomic_flag_clear(atomic_flag* obj) noexcept;
+
+void
+    atomic_flag_clear_explicit(volatile atomic_flag* obj, memory_order m) noexcept;
+
+void
+    atomic_flag_clear_explicit(atomic_flag* obj, memory_order m) noexcept;
+
+#define ATOMIC_FLAG_INIT see below
+#define ATOMIC_VAR_INIT(value) see below
+
+template <class T>
+struct atomic
+{
+    bool is_lock_free() const volatile noexcept;
+    bool is_lock_free() const noexcept;
+    void store(T desr, memory_order m = memory_order_seq_cst) volatile noexcept;
+    void store(T desr, memory_order m = memory_order_seq_cst) noexcept;
+    T load(memory_order m = memory_order_seq_cst) const volatile noexcept;
+    T load(memory_order m = memory_order_seq_cst) const noexcept;
+    operator T() const volatile noexcept;
+    operator T() const noexcept;
+    T exchange(T desr, memory_order m = memory_order_seq_cst) volatile noexcept;
+    T exchange(T desr, memory_order m = memory_order_seq_cst) noexcept;
+    bool compare_exchange_weak(T& expc, T desr,
+                               memory_order s, memory_order f) volatile noexcept;
+    bool compare_exchange_weak(T& expc, T desr, memory_order s, memory_order f) noexcept;
+    bool compare_exchange_strong(T& expc, T desr,
+                                 memory_order s, memory_order f) volatile noexcept;
+    bool compare_exchange_strong(T& expc, T desr,
+                                 memory_order s, memory_order f) noexcept;
+    bool compare_exchange_weak(T& expc, T desr,
+                               memory_order m = memory_order_seq_cst) volatile noexcept;
+    bool compare_exchange_weak(T& expc, T desr,
+                               memory_order m = memory_order_seq_cst) noexcept;
+    bool compare_exchange_strong(T& expc, T desr,
+                                memory_order m = memory_order_seq_cst) volatile noexcept;
+    bool compare_exchange_strong(T& expc, T desr,
+                                 memory_order m = memory_order_seq_cst) noexcept;
+
+    atomic() noexcept = default;
+    constexpr atomic(T desr) noexcept;
+    atomic(const atomic&) = delete;
+    atomic& operator=(const atomic&) = delete;
+    atomic& operator=(const atomic&) volatile = delete;
+    T operator=(T) volatile noexcept;
+    T operator=(T) noexcept;
+};
+
+template <>
+struct atomic<integral>
+{
+    bool is_lock_free() const volatile noexcept;
+    bool is_lock_free() const noexcept;
+    void store(integral desr, memory_order m = memory_order_seq_cst) volatile noexcept;
+    void store(integral desr, memory_order m = memory_order_seq_cst) noexcept;
+    integral load(memory_order m = memory_order_seq_cst) const volatile noexcept;
+    integral load(memory_order m = memory_order_seq_cst) const noexcept;
+    operator integral() const volatile noexcept;
+    operator integral() const noexcept;
+    integral exchange(integral desr,
+                      memory_order m = memory_order_seq_cst) volatile noexcept;
+    integral exchange(integral desr, memory_order m = memory_order_seq_cst) noexcept;
+    bool compare_exchange_weak(integral& expc, integral desr,
+                               memory_order s, memory_order f) volatile noexcept;
+    bool compare_exchange_weak(integral& expc, integral desr,
+                               memory_order s, memory_order f) noexcept;
+    bool compare_exchange_strong(integral& expc, integral desr,
+                                 memory_order s, memory_order f) volatile noexcept;
+    bool compare_exchange_strong(integral& expc, integral desr,
+                                 memory_order s, memory_order f) noexcept;
+    bool compare_exchange_weak(integral& expc, integral desr,
+                               memory_order m = memory_order_seq_cst) volatile noexcept;
+    bool compare_exchange_weak(integral& expc, integral desr,
+                               memory_order m = memory_order_seq_cst) noexcept;
+    bool compare_exchange_strong(integral& expc, integral desr,
+                                memory_order m = memory_order_seq_cst) volatile noexcept;
+    bool compare_exchange_strong(integral& expc, integral desr,
+                                 memory_order m = memory_order_seq_cst) noexcept;
+
+    integral
+        fetch_add(integral op, memory_order m = memory_order_seq_cst) volatile noexcept;
+    integral fetch_add(integral op, memory_order m = memory_order_seq_cst) noexcept;
+    integral
+        fetch_sub(integral op, memory_order m = memory_order_seq_cst) volatile noexcept;
+    integral fetch_sub(integral op, memory_order m = memory_order_seq_cst) noexcept;
+    integral
+        fetch_and(integral op, memory_order m = memory_order_seq_cst) volatile noexcept;
+    integral fetch_and(integral op, memory_order m = memory_order_seq_cst) noexcept;
+    integral
+        fetch_or(integral op, memory_order m = memory_order_seq_cst) volatile noexcept;
+    integral fetch_or(integral op, memory_order m = memory_order_seq_cst) noexcept;
+    integral
+        fetch_xor(integral op, memory_order m = memory_order_seq_cst) volatile noexcept;
+    integral fetch_xor(integral op, memory_order m = memory_order_seq_cst) noexcept;
+
+    atomic() noexcept = default;
+    constexpr atomic(integral desr) noexcept;
+    atomic(const atomic&) = delete;
+    atomic& operator=(const atomic&) = delete;
+    atomic& operator=(const atomic&) volatile = delete;
+    integral operator=(integral desr) volatile noexcept;
+    integral operator=(integral desr) noexcept;
+
+    integral operator++(int) volatile noexcept;
+    integral operator++(int) noexcept;
+    integral operator--(int) volatile noexcept;
+    integral operator--(int) noexcept;
+    integral operator++() volatile noexcept;
+    integral operator++() noexcept;
+    integral operator--() volatile noexcept;
+    integral operator--() noexcept;
+    integral operator+=(integral op) volatile noexcept;
+    integral operator+=(integral op) noexcept;
+    integral operator-=(integral op) volatile noexcept;
+    integral operator-=(integral op) noexcept;
+    integral operator&=(integral op) volatile noexcept;
+    integral operator&=(integral op) noexcept;
+    integral operator|=(integral op) volatile noexcept;
+    integral operator|=(integral op) noexcept;
+    integral operator^=(integral op) volatile noexcept;
+    integral operator^=(integral op) noexcept;
+};
+
+template <class T>
+struct atomic<T*>
+{
+    bool is_lock_free() const volatile noexcept;
+    bool is_lock_free() const noexcept;
+    void store(T* desr, memory_order m = memory_order_seq_cst) volatile noexcept;
+    void store(T* desr, memory_order m = memory_order_seq_cst) noexcept;
+    T* load(memory_order m = memory_order_seq_cst) const volatile noexcept;
+    T* load(memory_order m = memory_order_seq_cst) const noexcept;
+    operator T*() const volatile noexcept;
+    operator T*() const noexcept;
+    T* exchange(T* desr, memory_order m = memory_order_seq_cst) volatile noexcept;
+    T* exchange(T* desr, memory_order m = memory_order_seq_cst) noexcept;
+    bool compare_exchange_weak(T*& expc, T* desr,
+                               memory_order s, memory_order f) volatile noexcept;
+    bool compare_exchange_weak(T*& expc, T* desr,
+                               memory_order s, memory_order f) noexcept;
+    bool compare_exchange_strong(T*& expc, T* desr,
+                                 memory_order s, memory_order f) volatile noexcept;
+    bool compare_exchange_strong(T*& expc, T* desr,
+                                 memory_order s, memory_order f) noexcept;
+    bool compare_exchange_weak(T*& expc, T* desr,
+                               memory_order m = memory_order_seq_cst) volatile noexcept;
+    bool compare_exchange_weak(T*& expc, T* desr,
+                               memory_order m = memory_order_seq_cst) noexcept;
+    bool compare_exchange_strong(T*& expc, T* desr,
+                                memory_order m = memory_order_seq_cst) volatile noexcept;
+    bool compare_exchange_strong(T*& expc, T* desr,
+                                 memory_order m = memory_order_seq_cst) noexcept;
+    T* fetch_add(ptrdiff_t op, memory_order m = memory_order_seq_cst) volatile noexcept;
+    T* fetch_add(ptrdiff_t op, memory_order m = memory_order_seq_cst) noexcept;
+    T* fetch_sub(ptrdiff_t op, memory_order m = memory_order_seq_cst) volatile noexcept;
+    T* fetch_sub(ptrdiff_t op, memory_order m = memory_order_seq_cst) noexcept;
+
+    atomic() noexcept = default;
+    constexpr atomic(T* desr) noexcept;
+    atomic(const atomic&) = delete;
+    atomic& operator=(const atomic&) = delete;
+    atomic& operator=(const atomic&) volatile = delete;
+
+    T* operator=(T*) volatile noexcept;
+    T* operator=(T*) noexcept;
+    T* operator++(int) volatile noexcept;
+    T* operator++(int) noexcept;
+    T* operator--(int) volatile noexcept;
+    T* operator--(int) noexcept;
+    T* operator++() volatile noexcept;
+    T* operator++() noexcept;
+    T* operator--() volatile noexcept;
+    T* operator--() noexcept;
+    T* operator+=(ptrdiff_t op) volatile noexcept;
+    T* operator+=(ptrdiff_t op) noexcept;
+    T* operator-=(ptrdiff_t op) volatile noexcept;
+    T* operator-=(ptrdiff_t op) noexcept;
+};
+
+
+template <class T>
+    bool
+    atomic_is_lock_free(const volatile atomic<T>* obj) noexcept;
+
+template <class T>
+    bool
+    atomic_is_lock_free(const atomic<T>* obj) noexcept;
+
+template <class T>
+    void
+    atomic_init(volatile atomic<T>* obj, T desr) noexcept;
+
+template <class T>
+    void
+    atomic_init(atomic<T>* obj, T desr) noexcept;
+
+template <class T>
+    void
+    atomic_store(volatile atomic<T>* obj, T desr) noexcept;
+
+template <class T>
+    void
+    atomic_store(atomic<T>* obj, T desr) noexcept;
+
+template <class T>
+    void
+    atomic_store_explicit(volatile atomic<T>* obj, T desr, memory_order m) noexcept;
+
+template <class T>
+    void
+    atomic_store_explicit(atomic<T>* obj, T desr, memory_order m) noexcept;
+
+template <class T>
+    T
+    atomic_load(const volatile atomic<T>* obj) noexcept;
+
+template <class T>
+    T
+    atomic_load(const atomic<T>* obj) noexcept;
+
+template <class T>
+    T
+    atomic_load_explicit(const volatile atomic<T>* obj, memory_order m) noexcept;
+
+template <class T>
+    T
+    atomic_load_explicit(const atomic<T>* obj, memory_order m) noexcept;
+
+template <class T>
+    T
+    atomic_exchange(volatile atomic<T>* obj, T desr) noexcept;
+
+template <class T>
+    T
+    atomic_exchange(atomic<T>* obj, T desr) noexcept;
+
+template <class T>
+    T
+    atomic_exchange_explicit(volatile atomic<T>* obj, T desr, memory_order m) noexcept;
+
+template <class T>
+    T
+    atomic_exchange_explicit(atomic<T>* obj, T desr, memory_order m) noexcept;
+
+template <class T>
+    bool
+    atomic_compare_exchange_weak(volatile atomic<T>* obj, T* expc, T desr) noexcept;
+
+template <class T>
+    bool
+    atomic_compare_exchange_weak(atomic<T>* obj, T* expc, T desr) noexcept;
+
+template <class T>
+    bool
+    atomic_compare_exchange_strong(volatile atomic<T>* obj, T* expc, T desr) noexcept;
+
+template <class T>
+    bool
+    atomic_compare_exchange_strong(atomic<T>* obj, T* expc, T desr) noexcept;
+
+template <class T>
+    bool
+    atomic_compare_exchange_weak_explicit(volatile atomic<T>* obj, T* expc,
+                                          T desr,
+                                          memory_order s, memory_order f) noexcept;
+
+template <class T>
+    bool
+    atomic_compare_exchange_weak_explicit(atomic<T>* obj, T* expc, T desr,
+                                          memory_order s, memory_order f) noexcept;
+
+template <class T>
+    bool
+    atomic_compare_exchange_strong_explicit(volatile atomic<T>* obj,
+                                            T* expc, T desr,
+                                            memory_order s, memory_order f) noexcept;
+
+template <class T>
+    bool
+    atomic_compare_exchange_strong_explicit(atomic<T>* obj, T* expc,
+                                            T desr,
+                                            memory_order s, memory_order f) noexcept;
+
+template <class Integral>
+    Integral
+    atomic_fetch_add(volatile atomic<Integral>* obj, Integral op) noexcept;
+
+template <class Integral>
+    Integral
+    atomic_fetch_add(atomic<Integral>* obj, Integral op) noexcept;
+
+template <class Integral>
+    Integral
+    atomic_fetch_add_explicit(volatile atomic<Integral>* obj, Integral op,
+                              memory_order m) noexcept;
+template <class Integral>
+    Integral
+    atomic_fetch_add_explicit(atomic<Integral>* obj, Integral op,
+                              memory_order m) noexcept;
+template <class Integral>
+    Integral
+    atomic_fetch_sub(volatile atomic<Integral>* obj, Integral op) noexcept;
+
+template <class Integral>
+    Integral
+    atomic_fetch_sub(atomic<Integral>* obj, Integral op) noexcept;
+
+template <class Integral>
+    Integral
+    atomic_fetch_sub_explicit(volatile atomic<Integral>* obj, Integral op,
+                              memory_order m) noexcept;
+template <class Integral>
+    Integral
+    atomic_fetch_sub_explicit(atomic<Integral>* obj, Integral op,
+                              memory_order m) noexcept;
+template <class Integral>
+    Integral
+    atomic_fetch_and(volatile atomic<Integral>* obj, Integral op) noexcept;
+
+template <class Integral>
+    Integral
+    atomic_fetch_and(atomic<Integral>* obj, Integral op) noexcept;
+
+template <class Integral>
+    Integral
+    atomic_fetch_and_explicit(volatile atomic<Integral>* obj, Integral op,
+                              memory_order m) noexcept;
+template <class Integral>
+    Integral
+    atomic_fetch_and_explicit(atomic<Integral>* obj, Integral op,
+                              memory_order m) noexcept;
+template <class Integral>
+    Integral
+    atomic_fetch_or(volatile atomic<Integral>* obj, Integral op) noexcept;
+
+template <class Integral>
+    Integral
+    atomic_fetch_or(atomic<Integral>* obj, Integral op) noexcept;
+
+template <class Integral>
+    Integral
+    atomic_fetch_or_explicit(volatile atomic<Integral>* obj, Integral op,
+                             memory_order m) noexcept;
+template <class Integral>
+    Integral
+    atomic_fetch_or_explicit(atomic<Integral>* obj, Integral op,
+                             memory_order m) noexcept;
+template <class Integral>
+    Integral
+    atomic_fetch_xor(volatile atomic<Integral>* obj, Integral op) noexcept;
+
+template <class Integral>
+    Integral
+    atomic_fetch_xor(atomic<Integral>* obj, Integral op) noexcept;
+
+template <class Integral>
+    Integral
+    atomic_fetch_xor_explicit(volatile atomic<Integral>* obj, Integral op,
+                              memory_order m) noexcept;
+template <class Integral>
+    Integral
+    atomic_fetch_xor_explicit(atomic<Integral>* obj, Integral op,
+                              memory_order m) noexcept;
+
+template <class T>
+    T*
+    atomic_fetch_add(volatile atomic<T*>* obj, ptrdiff_t op) noexcept;
+
+template <class T>
+    T*
+    atomic_fetch_add(atomic<T*>* obj, ptrdiff_t op) noexcept;
+
+template <class T>
+    T*
+    atomic_fetch_add_explicit(volatile atomic<T*>* obj, ptrdiff_t op,
+                              memory_order m) noexcept;
+template <class T>
+    T*
+    atomic_fetch_add_explicit(atomic<T*>* obj, ptrdiff_t op, memory_order m) noexcept;
+
+template <class T>
+    T*
+    atomic_fetch_sub(volatile atomic<T*>* obj, ptrdiff_t op) noexcept;
+
+template <class T>
+    T*
+    atomic_fetch_sub(atomic<T*>* obj, ptrdiff_t op) noexcept;
+
+template <class T>
+    T*
+    atomic_fetch_sub_explicit(volatile atomic<T*>* obj, ptrdiff_t op,
+                              memory_order m) noexcept;
+template <class T>
+    T*
+    atomic_fetch_sub_explicit(atomic<T*>* obj, ptrdiff_t op, memory_order m) noexcept;
+
+// Atomics for standard typedef types
+
+typedef atomic<bool>               atomic_bool;
+typedef atomic<char>               atomic_char;
+typedef atomic<signed char>        atomic_schar;
+typedef atomic<unsigned char>      atomic_uchar;
+typedef atomic<short>              atomic_short;
+typedef atomic<unsigned short>     atomic_ushort;
+typedef atomic<int>                atomic_int;
+typedef atomic<unsigned int>       atomic_uint;
+typedef atomic<long>               atomic_long;
+typedef atomic<unsigned long>      atomic_ulong;
+typedef atomic<long long>          atomic_llong;
+typedef atomic<unsigned long long> atomic_ullong;
+typedef atomic<char16_t>           atomic_char16_t;
+typedef atomic<char32_t>           atomic_char32_t;
+typedef atomic<wchar_t>            atomic_wchar_t;
+
+typedef atomic<int_least8_t>   atomic_int_least8_t;
+typedef atomic<uint_least8_t>  atomic_uint_least8_t;
+typedef atomic<int_least16_t>  atomic_int_least16_t;
+typedef atomic<uint_least16_t> atomic_uint_least16_t;
+typedef atomic<int_least32_t>  atomic_int_least32_t;
+typedef atomic<uint_least32_t> atomic_uint_least32_t;
+typedef atomic<int_least64_t>  atomic_int_least64_t;
+typedef atomic<uint_least64_t> atomic_uint_least64_t;
+
+typedef atomic<int_fast8_t>   atomic_int_fast8_t;
+typedef atomic<uint_fast8_t>  atomic_uint_fast8_t;
+typedef atomic<int_fast16_t>  atomic_int_fast16_t;
+typedef atomic<uint_fast16_t> atomic_uint_fast16_t;
+typedef atomic<int_fast32_t>  atomic_int_fast32_t;
+typedef atomic<uint_fast32_t> atomic_uint_fast32_t;
+typedef atomic<int_fast64_t>  atomic_int_fast64_t;
+typedef atomic<uint_fast64_t> atomic_uint_fast64_t;
+
+typedef atomic<intptr_t>  atomic_intptr_t;
+typedef atomic<uintptr_t> atomic_uintptr_t;
+typedef atomic<size_t>    atomic_size_t;
+typedef atomic<ptrdiff_t> atomic_ptrdiff_t;
+typedef atomic<intmax_t>  atomic_intmax_t;
+typedef atomic<uintmax_t> atomic_uintmax_t;
+
+// fences
+
+void atomic_thread_fence(memory_order m) noexcept;
+void atomic_signal_fence(memory_order m) noexcept;
+
+}  // std
+
+*/
+
+#include <__config>
+#include <cstddef>
+#include <cstdint>
+#include <type_traits>
+
+#if !defined(_LIBCPP_HAS_NO_PRAGMA_SYSTEM_HEADER)
+#pragma GCC system_header
+#endif
+
+#ifdef _LIBCPP_HAS_NO_THREADS
+#error <atomic> is not supported on this single threaded system
+#else // !_LIBCPP_HAS_NO_THREADS
+
+_LIBCPP_BEGIN_NAMESPACE_STD
+
+#if !__has_feature(cxx_atomic) && _GNUC_VER < 407
+#error <atomic> is not implemented
+#else
+
+typedef enum memory_order
+{
+    memory_order_relaxed, memory_order_consume, memory_order_acquire,
+    memory_order_release, memory_order_acq_rel, memory_order_seq_cst
+} memory_order;
+
+#if _GNUC_VER >= 407
+namespace __gcc_atomic {
+template <typename _Tp>
+struct __gcc_atomic_t {
+  __gcc_atomic_t() _NOEXCEPT {}
+  explicit __gcc_atomic_t(_Tp value) _NOEXCEPT : __a_value(value) {}
+  _Tp __a_value;
+};
+#define _Atomic(x) __gcc_atomic::__gcc_atomic_t<x>
+
+template <typename _Tp> _Tp __create();
+
+template <typename _Tp, typename _Td>
+typename enable_if<sizeof(_Tp()->__a_value = __create<_Td>()), char>::type
+    __test_atomic_assignable(int);
+template <typename _Tp, typename _Up>
+__two __test_atomic_assignable(...);
+
+template <typename _Tp, typename _Td>
+struct __can_assign {
+  static const bool value =
+      sizeof(__test_atomic_assignable<_Tp, _Td>(1)) == sizeof(char);
+};
+
+static inline constexpr int __to_gcc_order(memory_order __order) {
+  // Avoid switch statement to make this a constexpr.
+  return __order == memory_order_relaxed ? __ATOMIC_RELAXED:
+         (__order == memory_order_acquire ? __ATOMIC_ACQUIRE:
+          (__order == memory_order_release ? __ATOMIC_RELEASE:
+           (__order == memory_order_seq_cst ? __ATOMIC_SEQ_CST:
+            (__order == memory_order_acq_rel ? __ATOMIC_ACQ_REL:
+              __ATOMIC_CONSUME))));
+}
+
+static inline constexpr int __to_gcc_failure_order(memory_order __order) {
+  // Avoid switch statement to make this a constexpr.
+  return __order == memory_order_relaxed ? __ATOMIC_RELAXED:
+         (__order == memory_order_acquire ? __ATOMIC_ACQUIRE:
+          (__order == memory_order_release ? __ATOMIC_RELAXED:
+           (__order == memory_order_seq_cst ? __ATOMIC_SEQ_CST:
+            (__order == memory_order_acq_rel ? __ATOMIC_ACQUIRE:
+              __ATOMIC_CONSUME))));
+}
+
+} // namespace __gcc_atomic
+
+template <typename _Tp>
+static inline
+typename enable_if<
+    __gcc_atomic::__can_assign<volatile _Atomic(_Tp)*, _Tp>::value>::type
+__c11_atomic_init(volatile _Atomic(_Tp)* __a,  _Tp __val) {
+  __a->__a_value = __val;
+}
+
+template <typename _Tp>
+static inline
+typename enable_if<
+    !__gcc_atomic::__can_assign<volatile _Atomic(_Tp)*, _Tp>::value &&
+     __gcc_atomic::__can_assign<         _Atomic(_Tp)*, _Tp>::value>::type
+__c11_atomic_init(volatile _Atomic(_Tp)* __a,  _Tp __val) {
+  // [atomics.types.generic]p1 guarantees _Tp is trivially copyable. Because
+  // the default operator= in an object is not volatile, a byte-by-byte copy
+  // is required.
+  volatile char* to = reinterpret_cast<volatile char*>(&__a->__a_value);
+  volatile char* end = to + sizeof(_Tp);
+  char* from = reinterpret_cast<char*>(&__val);
+  while (to != end) {
+    *to++ = *from++;
+  }
+}
+
+template <typename _Tp>
+static inline void __c11_atomic_init(_Atomic(_Tp)* __a,  _Tp __val) {
+  __a->__a_value = __val;
+}
+
+static inline void __c11_atomic_thread_fence(memory_order __order) {
+  __atomic_thread_fence(__gcc_atomic::__to_gcc_order(__order));
+}
+
+static inline void __c11_atomic_signal_fence(memory_order __order) {
+  __atomic_signal_fence(__gcc_atomic::__to_gcc_order(__order));
+}
+
+template <typename _Tp>
+static inline void __c11_atomic_store(volatile _Atomic(_Tp)* __a,  _Tp __val,
+                                      memory_order __order) {
+  return __atomic_store(&__a->__a_value, &__val,
+                        __gcc_atomic::__to_gcc_order(__order));
+}
+
+template <typename _Tp>
+static inline void __c11_atomic_store(_Atomic(_Tp)* __a,  _Tp __val,
+                                      memory_order __order) {
+  __atomic_store(&__a->__a_value, &__val,
+                 __gcc_atomic::__to_gcc_order(__order));
+}
+
+template <typename _Tp>
+static inline _Tp __c11_atomic_load(volatile _Atomic(_Tp)* __a,
+                                    memory_order __order) {
+  _Tp __ret;
+  __atomic_load(&__a->__a_value, &__ret,
+                __gcc_atomic::__to_gcc_order(__order));
+  return __ret;
+}
+
+template <typename _Tp>
+static inline _Tp __c11_atomic_load(_Atomic(_Tp)* __a, memory_order __order) {
+  _Tp __ret;
+  __atomic_load(&__a->__a_value, &__ret,
+                __gcc_atomic::__to_gcc_order(__order));
+  return __ret;
+}
+
+template <typename _Tp>
+static inline _Tp __c11_atomic_exchange(volatile _Atomic(_Tp)* __a,
+                                        _Tp __value, memory_order __order) {
+  _Tp __ret;
+  __atomic_exchange(&__a->__a_value, &__value, &__ret,
+                    __gcc_atomic::__to_gcc_order(__order));
+  return __ret;
+}
+
+template <typename _Tp>
+static inline _Tp __c11_atomic_exchange(_Atomic(_Tp)* __a, _Tp __value,
+                                        memory_order __order) {
+  _Tp __ret;
+  __atomic_exchange(&__a->__a_value, &__value, &__ret,
+                    __gcc_atomic::__to_gcc_order(__order));
+  return __ret;
+}
+
+template <typename _Tp>
+static inline bool __c11_atomic_compare_exchange_strong(
+    volatile _Atomic(_Tp)* __a, _Tp* __expected, _Tp __value,
+    memory_order __success, memory_order __failure) {
+  return __atomic_compare_exchange(&__a->__a_value, __expected, &__value,
+                                   false,
+                                   __gcc_atomic::__to_gcc_order(__success),
+                                   __gcc_atomic::__to_gcc_failure_order(__failure));
+}
+
+template <typename _Tp>
+static inline bool __c11_atomic_compare_exchange_strong(
+    _Atomic(_Tp)* __a, _Tp* __expected, _Tp __value, memory_order __success,
+    memory_order __failure) {
+  return __atomic_compare_exchange(&__a->__a_value, __expected, &__value,
+                                   false,
+                                   __gcc_atomic::__to_gcc_order(__success),
+                                   __gcc_atomic::__to_gcc_failure_order(__failure));
+}
+
+template <typename _Tp>
+static inline bool __c11_atomic_compare_exchange_weak(
+    volatile _Atomic(_Tp)* __a, _Tp* __expected, _Tp __value,
+    memory_order __success, memory_order __failure) {
+  return __atomic_compare_exchange(&__a->__a_value, __expected, &__value,
+                                   true,
+                                   __gcc_atomic::__to_gcc_order(__success),
+                                   __gcc_atomic::__to_gcc_failure_order(__failure));
+}
+
+template <typename _Tp>
+static inline bool __c11_atomic_compare_exchange_weak(
+    _Atomic(_Tp)* __a, _Tp* __expected, _Tp __value, memory_order __success,
+    memory_order __failure) {
+  return __atomic_compare_exchange(&__a->__a_value, __expected, &__value,
+                                   true,
+                                   __gcc_atomic::__to_gcc_order(__success),
+                                   __gcc_atomic::__to_gcc_failure_order(__failure));
+}
+
+template <typename _Tp>
+struct __skip_amt { enum {value = 1}; };
+
+template <typename _Tp>
+struct __skip_amt<_Tp*> { enum {value = sizeof(_Tp)}; };
+
+// FIXME: Haven't figured out what the spec says about using arrays with
+// atomic_fetch_add. Force a failure rather than creating bad behavior.
+template <typename _Tp>
+struct __skip_amt<_Tp[]> { };
+template <typename _Tp, int n>
+struct __skip_amt<_Tp[n]> { };
+
+template <typename _Tp, typename _Td>
+static inline _Tp __c11_atomic_fetch_add(volatile _Atomic(_Tp)* __a,
+                                         _Td __delta, memory_order __order) {
+  return __atomic_fetch_add(&__a->__a_value, __delta * __skip_amt<_Tp>::value,
+                            __gcc_atomic::__to_gcc_order(__order));
+}
+
+template <typename _Tp, typename _Td>
+static inline _Tp __c11_atomic_fetch_add(_Atomic(_Tp)* __a, _Td __delta,
+                                         memory_order __order) {
+  return __atomic_fetch_add(&__a->__a_value, __delta * __skip_amt<_Tp>::value,
+                            __gcc_atomic::__to_gcc_order(__order));
+}
+
+template <typename _Tp, typename _Td>
+static inline _Tp __c11_atomic_fetch_sub(volatile _Atomic(_Tp)* __a,
+                                         _Td __delta, memory_order __order) {
+  return __atomic_fetch_sub(&__a->__a_value, __delta * __skip_amt<_Tp>::value,
+                            __gcc_atomic::__to_gcc_order(__order));
+}
+
+template <typename _Tp, typename _Td>
+static inline _Tp __c11_atomic_fetch_sub(_Atomic(_Tp)* __a, _Td __delta,
+                                         memory_order __order) {
+  return __atomic_fetch_sub(&__a->__a_value, __delta * __skip_amt<_Tp>::value,
+                            __gcc_atomic::__to_gcc_order(__order));
+}
+
+template <typename _Tp>
+static inline _Tp __c11_atomic_fetch_and(volatile _Atomic(_Tp)* __a,
+                                         _Tp __pattern, memory_order __order) {
+  return __atomic_fetch_and(&__a->__a_value, __pattern,
+                            __gcc_atomic::__to_gcc_order(__order));
+}
+
+template <typename _Tp>
+static inline _Tp __c11_atomic_fetch_and(_Atomic(_Tp)* __a,
+                                         _Tp __pattern, memory_order __order) {
+  return __atomic_fetch_and(&__a->__a_value, __pattern,
+                            __gcc_atomic::__to_gcc_order(__order));
+}
+
+template <typename _Tp>
+static inline _Tp __c11_atomic_fetch_or(volatile _Atomic(_Tp)* __a,
+                                        _Tp __pattern, memory_order __order) {
+  return __atomic_fetch_or(&__a->__a_value, __pattern,
+                           __gcc_atomic::__to_gcc_order(__order));
+}
+
+template <typename _Tp>
+static inline _Tp __c11_atomic_fetch_or(_Atomic(_Tp)* __a, _Tp __pattern,
+                                        memory_order __order) {
+  return __atomic_fetch_or(&__a->__a_value, __pattern,
+                           __gcc_atomic::__to_gcc_order(__order));
+}
+
+template <typename _Tp>
+static inline _Tp __c11_atomic_fetch_xor(volatile _Atomic(_Tp)* __a,
+                                         _Tp __pattern, memory_order __order) {
+  return __atomic_fetch_xor(&__a->__a_value, __pattern,
+                            __gcc_atomic::__to_gcc_order(__order));
+}
+
+template <typename _Tp>
+static inline _Tp __c11_atomic_fetch_xor(_Atomic(_Tp)* __a, _Tp __pattern,
+                                         memory_order __order) {
+  return __atomic_fetch_xor(&__a->__a_value, __pattern,
+                            __gcc_atomic::__to_gcc_order(__order));
+}
+#endif // _GNUC_VER >= 407
+
+template <class _Tp>
+inline _LIBCPP_INLINE_VISIBILITY
+_Tp
+kill_dependency(_Tp __y) _NOEXCEPT
+{
+    return __y;
+}
+
+// general atomic<T>
+
+template <class _Tp, bool = is_integral<_Tp>::value && !is_same<_Tp, bool>::value>
+struct __atomic_base  // false
+{
+    mutable _Atomic(_Tp) __a_;
+
+    _LIBCPP_INLINE_VISIBILITY
+    bool is_lock_free() const volatile _NOEXCEPT
+    {
+#if __has_feature(cxx_atomic)
+    return __c11_atomic_is_lock_free(sizeof(_Tp));
+#else
+    return __atomic_is_lock_free(sizeof(_Tp), 0);
+#endif
+    }
+    _LIBCPP_INLINE_VISIBILITY
+    bool is_lock_free() const _NOEXCEPT
+        {return static_cast<__atomic_base const volatile*>(this)->is_lock_free();}
+    _LIBCPP_INLINE_VISIBILITY
+    void store(_Tp __d, memory_order __m = memory_order_seq_cst) volatile _NOEXCEPT
+        {__c11_atomic_store(&__a_, __d, __m);}
+    _LIBCPP_INLINE_VISIBILITY
+    void store(_Tp __d, memory_order __m = memory_order_seq_cst) _NOEXCEPT
+        {__c11_atomic_store(&__a_, __d, __m);}
+    _LIBCPP_INLINE_VISIBILITY
+    _Tp load(memory_order __m = memory_order_seq_cst) const volatile _NOEXCEPT
+        {return __c11_atomic_load(&__a_, __m);}
+    _LIBCPP_INLINE_VISIBILITY
+    _Tp load(memory_order __m = memory_order_seq_cst) const _NOEXCEPT
+        {return __c11_atomic_load(&__a_, __m);}
+    _LIBCPP_INLINE_VISIBILITY
+    operator _Tp() const volatile _NOEXCEPT {return load();}
+    _LIBCPP_INLINE_VISIBILITY
+    operator _Tp() const _NOEXCEPT          {return load();}
+    _LIBCPP_INLINE_VISIBILITY
+    _Tp exchange(_Tp __d, memory_order __m = memory_order_seq_cst) volatile _NOEXCEPT
+        {return __c11_atomic_exchange(&__a_, __d, __m);}
+    _LIBCPP_INLINE_VISIBILITY
+    _Tp exchange(_Tp __d, memory_order __m = memory_order_seq_cst) _NOEXCEPT
+        {return __c11_atomic_exchange(&__a_, __d, __m);}
+    _LIBCPP_INLINE_VISIBILITY
+    bool compare_exchange_weak(_Tp& __e, _Tp __d,
+                               memory_order __s, memory_order __f) volatile _NOEXCEPT
+        {return __c11_atomic_compare_exchange_weak(&__a_, &__e, __d, __s, __f);}
+    _LIBCPP_INLINE_VISIBILITY
+    bool compare_exchange_weak(_Tp& __e, _Tp __d,
+                               memory_order __s, memory_order __f) _NOEXCEPT
+        {return __c11_atomic_compare_exchange_weak(&__a_, &__e, __d, __s, __f);}
+    _LIBCPP_INLINE_VISIBILITY
+    bool compare_exchange_strong(_Tp& __e, _Tp __d,
+                                 memory_order __s, memory_order __f) volatile _NOEXCEPT
+        {return __c11_atomic_compare_exchange_strong(&__a_, &__e, __d, __s, __f);}
+    _LIBCPP_INLINE_VISIBILITY
+    bool compare_exchange_strong(_Tp& __e, _Tp __d,
+                                 memory_order __s, memory_order __f) _NOEXCEPT
+        {return __c11_atomic_compare_exchange_strong(&__a_, &__e, __d, __s, __f);}
+    _LIBCPP_INLINE_VISIBILITY
+    bool compare_exchange_weak(_Tp& __e, _Tp __d,
+                              memory_order __m = memory_order_seq_cst) volatile _NOEXCEPT
+        {return __c11_atomic_compare_exchange_weak(&__a_, &__e, __d, __m, __m);}
+    _LIBCPP_INLINE_VISIBILITY
+    bool compare_exchange_weak(_Tp& __e, _Tp __d,
+                               memory_order __m = memory_order_seq_cst) _NOEXCEPT
+        {return __c11_atomic_compare_exchange_weak(&__a_, &__e, __d, __m, __m);}
+    _LIBCPP_INLINE_VISIBILITY
+    bool compare_exchange_strong(_Tp& __e, _Tp __d,
+                              memory_order __m = memory_order_seq_cst) volatile _NOEXCEPT
+        {return __c11_atomic_compare_exchange_strong(&__a_, &__e, __d, __m, __m);}
+    _LIBCPP_INLINE_VISIBILITY
+    bool compare_exchange_strong(_Tp& __e, _Tp __d,
+                                 memory_order __m = memory_order_seq_cst) _NOEXCEPT
+        {return __c11_atomic_compare_exchange_strong(&__a_, &__e, __d, __m, __m);}
+
+    _LIBCPP_INLINE_VISIBILITY
+#ifndef _LIBCPP_HAS_NO_DEFAULTED_FUNCTIONS
+    __atomic_base() _NOEXCEPT = default;
+#else
+    __atomic_base() _NOEXCEPT : __a_() {}
+#endif // _LIBCPP_HAS_NO_DEFAULTED_FUNCTIONS
+
+    _LIBCPP_INLINE_VISIBILITY
+    _LIBCPP_CONSTEXPR __atomic_base(_Tp __d) _NOEXCEPT : __a_(__d) {}
+#ifndef _LIBCPP_HAS_NO_DELETED_FUNCTIONS
+    __atomic_base(const __atomic_base&) = delete;
+    __atomic_base& operator=(const __atomic_base&) = delete;
+    __atomic_base& operator=(const __atomic_base&) volatile = delete;
+#else  // _LIBCPP_HAS_NO_DELETED_FUNCTIONS
+private:
+    __atomic_base(const __atomic_base&);
+    __atomic_base& operator=(const __atomic_base&);
+    __atomic_base& operator=(const __atomic_base&) volatile;
+#endif  // _LIBCPP_HAS_NO_DELETED_FUNCTIONS
+};
+
+// atomic<Integral>
+
+template <class _Tp>
+struct __atomic_base<_Tp, true>
+    : public __atomic_base<_Tp, false>
+{
+    typedef __atomic_base<_Tp, false> __base;
+    _LIBCPP_INLINE_VISIBILITY
+    __atomic_base() _NOEXCEPT _LIBCPP_DEFAULT
+    _LIBCPP_INLINE_VISIBILITY
+    _LIBCPP_CONSTEXPR __atomic_base(_Tp __d) _NOEXCEPT : __base(__d) {}
+
+    _LIBCPP_INLINE_VISIBILITY
+    _Tp fetch_add(_Tp __op, memory_order __m = memory_order_seq_cst) volatile _NOEXCEPT
+        {return __c11_atomic_fetch_add(&this->__a_, __op, __m);}
+    _LIBCPP_INLINE_VISIBILITY
+    _Tp fetch_add(_Tp __op, memory_order __m = memory_order_seq_cst) _NOEXCEPT
+        {return __c11_atomic_fetch_add(&this->__a_, __op, __m);}
+    _LIBCPP_INLINE_VISIBILITY
+    _Tp fetch_sub(_Tp __op, memory_order __m = memory_order_seq_cst) volatile _NOEXCEPT
+        {return __c11_atomic_fetch_sub(&this->__a_, __op, __m);}
+    _LIBCPP_INLINE_VISIBILITY
+    _Tp fetch_sub(_Tp __op, memory_order __m = memory_order_seq_cst) _NOEXCEPT
+        {return __c11_atomic_fetch_sub(&this->__a_, __op, __m);}
+    _LIBCPP_INLINE_VISIBILITY
+    _Tp fetch_and(_Tp __op, memory_order __m = memory_order_seq_cst) volatile _NOEXCEPT
+        {return __c11_atomic_fetch_and(&this->__a_, __op, __m);}
+    _LIBCPP_INLINE_VISIBILITY
+    _Tp fetch_and(_Tp __op, memory_order __m = memory_order_seq_cst) _NOEXCEPT
+        {return __c11_atomic_fetch_and(&this->__a_, __op, __m);}
+    _LIBCPP_INLINE_VISIBILITY
+    _Tp fetch_or(_Tp __op, memory_order __m = memory_order_seq_cst) volatile _NOEXCEPT
+        {return __c11_atomic_fetch_or(&this->__a_, __op, __m);}
+    _LIBCPP_INLINE_VISIBILITY
+    _Tp fetch_or(_Tp __op, memory_order __m = memory_order_seq_cst) _NOEXCEPT
+        {return __c11_atomic_fetch_or(&this->__a_, __op, __m);}
+    _LIBCPP_INLINE_VISIBILITY
+    _Tp fetch_xor(_Tp __op, memory_order __m = memory_order_seq_cst) volatile _NOEXCEPT
+        {return __c11_atomic_fetch_xor(&this->__a_, __op, __m);}
+    _LIBCPP_INLINE_VISIBILITY
+    _Tp fetch_xor(_Tp __op, memory_order __m = memory_order_seq_cst) _NOEXCEPT
+        {return __c11_atomic_fetch_xor(&this->__a_, __op, __m);}
+
+    _LIBCPP_INLINE_VISIBILITY
+    _Tp operator++(int) volatile _NOEXCEPT      {return fetch_add(_Tp(1));}
+    _LIBCPP_INLINE_VISIBILITY
+    _Tp operator++(int) _NOEXCEPT               {return fetch_add(_Tp(1));}
+    _LIBCPP_INLINE_VISIBILITY
+    _Tp operator--(int) volatile _NOEXCEPT      {return fetch_sub(_Tp(1));}
+    _LIBCPP_INLINE_VISIBILITY
+    _Tp operator--(int) _NOEXCEPT               {return fetch_sub(_Tp(1));}
+    _LIBCPP_INLINE_VISIBILITY
+    _Tp operator++() volatile _NOEXCEPT         {return fetch_add(_Tp(1)) + _Tp(1);}
+    _LIBCPP_INLINE_VISIBILITY
+    _Tp operator++() _NOEXCEPT                  {return fetch_add(_Tp(1)) + _Tp(1);}
+    _LIBCPP_INLINE_VISIBILITY
+    _Tp operator--() volatile _NOEXCEPT         {return fetch_sub(_Tp(1)) - _Tp(1);}
+    _LIBCPP_INLINE_VISIBILITY
+    _Tp operator--() _NOEXCEPT                  {return fetch_sub(_Tp(1)) - _Tp(1);}
+    _LIBCPP_INLINE_VISIBILITY
+    _Tp operator+=(_Tp __op) volatile _NOEXCEPT {return fetch_add(__op) + __op;}
+    _LIBCPP_INLINE_VISIBILITY
+    _Tp operator+=(_Tp __op) _NOEXCEPT          {return fetch_add(__op) + __op;}
+    _LIBCPP_INLINE_VISIBILITY
+    _Tp operator-=(_Tp __op) volatile _NOEXCEPT {return fetch_sub(__op) - __op;}
+    _LIBCPP_INLINE_VISIBILITY
+    _Tp operator-=(_Tp __op) _NOEXCEPT          {return fetch_sub(__op) - __op;}
+    _LIBCPP_INLINE_VISIBILITY
+    _Tp operator&=(_Tp __op) volatile _NOEXCEPT {return fetch_and(__op) & __op;}
+    _LIBCPP_INLINE_VISIBILITY
+    _Tp operator&=(_Tp __op) _NOEXCEPT          {return fetch_and(__op) & __op;}
+    _LIBCPP_INLINE_VISIBILITY
+    _Tp operator|=(_Tp __op) volatile _NOEXCEPT {return fetch_or(__op) | __op;}
+    _LIBCPP_INLINE_VISIBILITY
+    _Tp operator|=(_Tp __op) _NOEXCEPT          {return fetch_or(__op) | __op;}
+    _LIBCPP_INLINE_VISIBILITY
+    _Tp operator^=(_Tp __op) volatile _NOEXCEPT {return fetch_xor(__op) ^ __op;}
+    _LIBCPP_INLINE_VISIBILITY
+    _Tp operator^=(_Tp __op) _NOEXCEPT          {return fetch_xor(__op) ^ __op;}
+};
+
+// atomic<T>
+
+template <class _Tp>
+struct atomic
+    : public __atomic_base<_Tp>
+{
+    typedef __atomic_base<_Tp> __base;
+    _LIBCPP_INLINE_VISIBILITY
+    atomic() _NOEXCEPT _LIBCPP_DEFAULT
+    _LIBCPP_INLINE_VISIBILITY
+    _LIBCPP_CONSTEXPR atomic(_Tp __d) _NOEXCEPT : __base(__d) {}
+
+    _LIBCPP_INLINE_VISIBILITY
+    _Tp operator=(_Tp __d) volatile _NOEXCEPT
+        {__base::store(__d); return __d;}
+    _LIBCPP_INLINE_VISIBILITY
+    _Tp operator=(_Tp __d) _NOEXCEPT
+        {__base::store(__d); return __d;}
+};
+
+// atomic<T*>
+
+template <class _Tp>
+struct atomic<_Tp*>
+    : public __atomic_base<_Tp*>
+{
+    typedef __atomic_base<_Tp*> __base;
+    _LIBCPP_INLINE_VISIBILITY
+    atomic() _NOEXCEPT _LIBCPP_DEFAULT
+    _LIBCPP_INLINE_VISIBILITY
+    _LIBCPP_CONSTEXPR atomic(_Tp* __d) _NOEXCEPT : __base(__d) {}
+
+    _LIBCPP_INLINE_VISIBILITY
+    _Tp* operator=(_Tp* __d) volatile _NOEXCEPT
+        {__base::store(__d); return __d;}
+    _LIBCPP_INLINE_VISIBILITY
+    _Tp* operator=(_Tp* __d) _NOEXCEPT
+        {__base::store(__d); return __d;}
+
+    _LIBCPP_INLINE_VISIBILITY
+    _Tp* fetch_add(ptrdiff_t __op, memory_order __m = memory_order_seq_cst)
+                                                                        volatile _NOEXCEPT
+        {return __c11_atomic_fetch_add(&this->__a_, __op, __m);}
+    _LIBCPP_INLINE_VISIBILITY
+    _Tp* fetch_add(ptrdiff_t __op, memory_order __m = memory_order_seq_cst) _NOEXCEPT
+        {return __c11_atomic_fetch_add(&this->__a_, __op, __m);}
+    _LIBCPP_INLINE_VISIBILITY
+    _Tp* fetch_sub(ptrdiff_t __op, memory_order __m = memory_order_seq_cst)
+                                                                        volatile _NOEXCEPT
+        {return __c11_atomic_fetch_sub(&this->__a_, __op, __m);}
+    _LIBCPP_INLINE_VISIBILITY
+    _Tp* fetch_sub(ptrdiff_t __op, memory_order __m = memory_order_seq_cst) _NOEXCEPT
+        {return __c11_atomic_fetch_sub(&this->__a_, __op, __m);}
+
+    _LIBCPP_INLINE_VISIBILITY
+    _Tp* operator++(int) volatile _NOEXCEPT            {return fetch_add(1);}
+    _LIBCPP_INLINE_VISIBILITY
+    _Tp* operator++(int) _NOEXCEPT                     {return fetch_add(1);}
+    _LIBCPP_INLINE_VISIBILITY
+    _Tp* operator--(int) volatile _NOEXCEPT            {return fetch_sub(1);}
+    _LIBCPP_INLINE_VISIBILITY
+    _Tp* operator--(int) _NOEXCEPT                     {return fetch_sub(1);}
+    _LIBCPP_INLINE_VISIBILITY
+    _Tp* operator++() volatile _NOEXCEPT               {return fetch_add(1) + 1;}
+    _LIBCPP_INLINE_VISIBILITY
+    _Tp* operator++() _NOEXCEPT                        {return fetch_add(1) + 1;}
+    _LIBCPP_INLINE_VISIBILITY
+    _Tp* operator--() volatile _NOEXCEPT               {return fetch_sub(1) - 1;}
+    _LIBCPP_INLINE_VISIBILITY
+    _Tp* operator--() _NOEXCEPT                        {return fetch_sub(1) - 1;}
+    _LIBCPP_INLINE_VISIBILITY
+    _Tp* operator+=(ptrdiff_t __op) volatile _NOEXCEPT {return fetch_add(__op) + __op;}
+    _LIBCPP_INLINE_VISIBILITY
+    _Tp* operator+=(ptrdiff_t __op) _NOEXCEPT          {return fetch_add(__op) + __op;}
+    _LIBCPP_INLINE_VISIBILITY
+    _Tp* operator-=(ptrdiff_t __op) volatile _NOEXCEPT {return fetch_sub(__op) - __op;}
+    _LIBCPP_INLINE_VISIBILITY
+    _Tp* operator-=(ptrdiff_t __op) _NOEXCEPT          {return fetch_sub(__op) - __op;}
+};
+
+// atomic_is_lock_free
+
+template <class _Tp>
+inline _LIBCPP_INLINE_VISIBILITY
+bool
+atomic_is_lock_free(const volatile atomic<_Tp>* __o) _NOEXCEPT
+{
+    return __o->is_lock_free();
+}
+
+template <class _Tp>
+inline _LIBCPP_INLINE_VISIBILITY
+bool
+atomic_is_lock_free(const atomic<_Tp>* __o) _NOEXCEPT
+{
+    return __o->is_lock_free();
+}
+
+// atomic_init
+
+template <class _Tp>
+inline _LIBCPP_INLINE_VISIBILITY
+void
+atomic_init(volatile atomic<_Tp>* __o, _Tp __d) _NOEXCEPT
+{
+    __c11_atomic_init(&__o->__a_, __d);
+}
+
+template <class _Tp>
+inline _LIBCPP_INLINE_VISIBILITY
+void
+atomic_init(atomic<_Tp>* __o, _Tp __d) _NOEXCEPT
+{
+    __c11_atomic_init(&__o->__a_, __d);
+}
+
+// atomic_store
+
+template <class _Tp>
+inline _LIBCPP_INLINE_VISIBILITY
+void
+atomic_store(volatile atomic<_Tp>* __o, _Tp __d) _NOEXCEPT
+{
+    __o->store(__d);
+}
+
+template <class _Tp>
+inline _LIBCPP_INLINE_VISIBILITY
+void
+atomic_store(atomic<_Tp>* __o, _Tp __d) _NOEXCEPT
+{
+    __o->store(__d);
+}
+
+// atomic_store_explicit
+
+template <class _Tp>
+inline _LIBCPP_INLINE_VISIBILITY
+void
+atomic_store_explicit(volatile atomic<_Tp>* __o, _Tp __d, memory_order __m) _NOEXCEPT
+{
+    __o->store(__d, __m);
+}
+
+template <class _Tp>
+inline _LIBCPP_INLINE_VISIBILITY
+void
+atomic_store_explicit(atomic<_Tp>* __o, _Tp __d, memory_order __m) _NOEXCEPT
+{
+    __o->store(__d, __m);
+}
+
+// atomic_load
+
+template <class _Tp>
+inline _LIBCPP_INLINE_VISIBILITY
+_Tp
+atomic_load(const volatile atomic<_Tp>* __o) _NOEXCEPT
+{
+    return __o->load();
+}
+
+template <class _Tp>
+inline _LIBCPP_INLINE_VISIBILITY
+_Tp
+atomic_load(const atomic<_Tp>* __o) _NOEXCEPT
+{
+    return __o->load();
+}
+
+// atomic_load_explicit
+
+template <class _Tp>
+inline _LIBCPP_INLINE_VISIBILITY
+_Tp
+atomic_load_explicit(const volatile atomic<_Tp>* __o, memory_order __m) _NOEXCEPT
+{
+    return __o->load(__m);
+}
+
+template <class _Tp>
+inline _LIBCPP_INLINE_VISIBILITY
+_Tp
+atomic_load_explicit(const atomic<_Tp>* __o, memory_order __m) _NOEXCEPT
+{
+    return __o->load(__m);
+}
+
+// atomic_exchange
+
+template <class _Tp>
+inline _LIBCPP_INLINE_VISIBILITY
+_Tp
+atomic_exchange(volatile atomic<_Tp>* __o, _Tp __d) _NOEXCEPT
+{
+    return __o->exchange(__d);
+}
+
+template <class _Tp>
+inline _LIBCPP_INLINE_VISIBILITY
+_Tp
+atomic_exchange(atomic<_Tp>* __o, _Tp __d) _NOEXCEPT
+{
+    return __o->exchange(__d);
+}
+
+// atomic_exchange_explicit
+
+template <class _Tp>
+inline _LIBCPP_INLINE_VISIBILITY
+_Tp
+atomic_exchange_explicit(volatile atomic<_Tp>* __o, _Tp __d, memory_order __m) _NOEXCEPT
+{
+    return __o->exchange(__d, __m);
+}
+
+template <class _Tp>
+inline _LIBCPP_INLINE_VISIBILITY
+_Tp
+atomic_exchange_explicit(atomic<_Tp>* __o, _Tp __d, memory_order __m) _NOEXCEPT
+{
+    return __o->exchange(__d, __m);
+}
+
+// atomic_compare_exchange_weak
+
+template <class _Tp>
+inline _LIBCPP_INLINE_VISIBILITY
+bool
+atomic_compare_exchange_weak(volatile atomic<_Tp>* __o, _Tp* __e, _Tp __d) _NOEXCEPT
+{
+    return __o->compare_exchange_weak(*__e, __d);
+}
+
+template <class _Tp>
+inline _LIBCPP_INLINE_VISIBILITY
+bool
+atomic_compare_exchange_weak(atomic<_Tp>* __o, _Tp* __e, _Tp __d) _NOEXCEPT
+{
+    return __o->compare_exchange_weak(*__e, __d);
+}
+
+// atomic_compare_exchange_strong
+
+template <class _Tp>
+inline _LIBCPP_INLINE_VISIBILITY
+bool
+atomic_compare_exchange_strong(volatile atomic<_Tp>* __o, _Tp* __e, _Tp __d) _NOEXCEPT
+{
+    return __o->compare_exchange_strong(*__e, __d);
+}
+
+template <class _Tp>
+inline _LIBCPP_INLINE_VISIBILITY
+bool
+atomic_compare_exchange_strong(atomic<_Tp>* __o, _Tp* __e, _Tp __d) _NOEXCEPT
+{
+    return __o->compare_exchange_strong(*__e, __d);
+}
+
+// atomic_compare_exchange_weak_explicit
+
+template <class _Tp>
+inline _LIBCPP_INLINE_VISIBILITY
+bool
+atomic_compare_exchange_weak_explicit(volatile atomic<_Tp>* __o, _Tp* __e,
+                                      _Tp __d,
+                                      memory_order __s, memory_order __f) _NOEXCEPT
+{
+    return __o->compare_exchange_weak(*__e, __d, __s, __f);
+}
+
+template <class _Tp>
+inline _LIBCPP_INLINE_VISIBILITY
+bool
+atomic_compare_exchange_weak_explicit(atomic<_Tp>* __o, _Tp* __e, _Tp __d,
+                                      memory_order __s, memory_order __f) _NOEXCEPT
+{
+    return __o->compare_exchange_weak(*__e, __d, __s, __f);
+}
+
+// atomic_compare_exchange_strong_explicit
+
+template <class _Tp>
+inline _LIBCPP_INLINE_VISIBILITY
+bool
+atomic_compare_exchange_strong_explicit(volatile atomic<_Tp>* __o,
+                                        _Tp* __e, _Tp __d,
+                                        memory_order __s, memory_order __f) _NOEXCEPT
+{
+    return __o->compare_exchange_strong(*__e, __d, __s, __f);
+}
+
+template <class _Tp>
+inline _LIBCPP_INLINE_VISIBILITY
+bool
+atomic_compare_exchange_strong_explicit(atomic<_Tp>* __o, _Tp* __e,
+                                        _Tp __d,
+                                        memory_order __s, memory_order __f) _NOEXCEPT
+{
+    return __o->compare_exchange_strong(*__e, __d, __s, __f);
+}
+
+// atomic_fetch_add
+
+template <class _Tp>
+inline _LIBCPP_INLINE_VISIBILITY
+typename enable_if
+<
+    is_integral<_Tp>::value && !is_same<_Tp, bool>::value,
+    _Tp
+>::type
+atomic_fetch_add(volatile atomic<_Tp>* __o, _Tp __op) _NOEXCEPT
+{
+    return __o->fetch_add(__op);
+}
+
+template <class _Tp>
+inline _LIBCPP_INLINE_VISIBILITY
+typename enable_if
+<
+    is_integral<_Tp>::value && !is_same<_Tp, bool>::value,
+    _Tp
+>::type
+atomic_fetch_add(atomic<_Tp>* __o, _Tp __op) _NOEXCEPT
+{
+    return __o->fetch_add(__op);
+}
+
+template <class _Tp>
+inline _LIBCPP_INLINE_VISIBILITY
+_Tp*
+atomic_fetch_add(volatile atomic<_Tp*>* __o, ptrdiff_t __op) _NOEXCEPT
+{
+    return __o->fetch_add(__op);
+}
+
+template <class _Tp>
+inline _LIBCPP_INLINE_VISIBILITY
+_Tp*
+atomic_fetch_add(atomic<_Tp*>* __o, ptrdiff_t __op) _NOEXCEPT
+{
+    return __o->fetch_add(__op);
+}
+
+// atomic_fetch_add_explicit
+
+template <class _Tp>
+inline _LIBCPP_INLINE_VISIBILITY
+typename enable_if
+<
+    is_integral<_Tp>::value && !is_same<_Tp, bool>::value,
+    _Tp
+>::type
+atomic_fetch_add_explicit(volatile atomic<_Tp>* __o, _Tp __op, memory_order __m) _NOEXCEPT
+{
+    return __o->fetch_add(__op, __m);
+}
+
+template <class _Tp>
+inline _LIBCPP_INLINE_VISIBILITY
+typename enable_if
+<
+    is_integral<_Tp>::value && !is_same<_Tp, bool>::value,
+    _Tp
+>::type
+atomic_fetch_add_explicit(atomic<_Tp>* __o, _Tp __op, memory_order __m) _NOEXCEPT
+{
+    return __o->fetch_add(__op, __m);
+}
+
+template <class _Tp>
+inline _LIBCPP_INLINE_VISIBILITY
+_Tp*
+atomic_fetch_add_explicit(volatile atomic<_Tp*>* __o, ptrdiff_t __op,
+                          memory_order __m) _NOEXCEPT
+{
+    return __o->fetch_add(__op, __m);
+}
+
+template <class _Tp>
+inline _LIBCPP_INLINE_VISIBILITY
+_Tp*
+atomic_fetch_add_explicit(atomic<_Tp*>* __o, ptrdiff_t __op, memory_order __m) _NOEXCEPT
+{
+    return __o->fetch_add(__op, __m);
+}
+
+// atomic_fetch_sub
+
+template <class _Tp>
+inline _LIBCPP_INLINE_VISIBILITY
+typename enable_if
+<
+    is_integral<_Tp>::value && !is_same<_Tp, bool>::value,
+    _Tp
+>::type
+atomic_fetch_sub(volatile atomic<_Tp>* __o, _Tp __op) _NOEXCEPT
+{
+    return __o->fetch_sub(__op);
+}
+
+template <class _Tp>
+inline _LIBCPP_INLINE_VISIBILITY
+typename enable_if
+<
+    is_integral<_Tp>::value && !is_same<_Tp, bool>::value,
+    _Tp
+>::type
+atomic_fetch_sub(atomic<_Tp>* __o, _Tp __op) _NOEXCEPT
+{
+    return __o->fetch_sub(__op);
+}
+
+template <class _Tp>
+inline _LIBCPP_INLINE_VISIBILITY
+_Tp*
+atomic_fetch_sub(volatile atomic<_Tp*>* __o, ptrdiff_t __op) _NOEXCEPT
+{
+    return __o->fetch_sub(__op);
+}
+
+template <class _Tp>
+inline _LIBCPP_INLINE_VISIBILITY
+_Tp*
+atomic_fetch_sub(atomic<_Tp*>* __o, ptrdiff_t __op) _NOEXCEPT
+{
+    return __o->fetch_sub(__op);
+}
+
+// atomic_fetch_sub_explicit
+
+template <class _Tp>
+inline _LIBCPP_INLINE_VISIBILITY
+typename enable_if
+<
+    is_integral<_Tp>::value && !is_same<_Tp, bool>::value,
+    _Tp
+>::type
+atomic_fetch_sub_explicit(volatile atomic<_Tp>* __o, _Tp __op, memory_order __m) _NOEXCEPT
+{
+    return __o->fetch_sub(__op, __m);
+}
+
+template <class _Tp>
+inline _LIBCPP_INLINE_VISIBILITY
+typename enable_if
+<
+    is_integral<_Tp>::value && !is_same<_Tp, bool>::value,
+    _Tp
+>::type
+atomic_fetch_sub_explicit(atomic<_Tp>* __o, _Tp __op, memory_order __m) _NOEXCEPT
+{
+    return __o->fetch_sub(__op, __m);
+}
+
+template <class _Tp>
+inline _LIBCPP_INLINE_VISIBILITY
+_Tp*
+atomic_fetch_sub_explicit(volatile atomic<_Tp*>* __o, ptrdiff_t __op,
+                          memory_order __m) _NOEXCEPT
+{
+    return __o->fetch_sub(__op, __m);
+}
+
+template <class _Tp>
+inline _LIBCPP_INLINE_VISIBILITY
+_Tp*
+atomic_fetch_sub_explicit(atomic<_Tp*>* __o, ptrdiff_t __op, memory_order __m) _NOEXCEPT
+{
+    return __o->fetch_sub(__op, __m);
+}
+
+// atomic_fetch_and
+
+template <class _Tp>
+inline _LIBCPP_INLINE_VISIBILITY
+typename enable_if
+<
+    is_integral<_Tp>::value && !is_same<_Tp, bool>::value,
+    _Tp
+>::type
+atomic_fetch_and(volatile atomic<_Tp>* __o, _Tp __op) _NOEXCEPT
+{
+    return __o->fetch_and(__op);
+}
+
+template <class _Tp>
+inline _LIBCPP_INLINE_VISIBILITY
+typename enable_if
+<
+    is_integral<_Tp>::value && !is_same<_Tp, bool>::value,
+    _Tp
+>::type
+atomic_fetch_and(atomic<_Tp>* __o, _Tp __op) _NOEXCEPT
+{
+    return __o->fetch_and(__op);
+}
+
+// atomic_fetch_and_explicit
+
+template <class _Tp>
+inline _LIBCPP_INLINE_VISIBILITY
+typename enable_if
+<
+    is_integral<_Tp>::value && !is_same<_Tp, bool>::value,
+    _Tp
+>::type
+atomic_fetch_and_explicit(volatile atomic<_Tp>* __o, _Tp __op, memory_order __m) _NOEXCEPT
+{
+    return __o->fetch_and(__op, __m);
+}
+
+template <class _Tp>
+inline _LIBCPP_INLINE_VISIBILITY
+typename enable_if
+<
+    is_integral<_Tp>::value && !is_same<_Tp, bool>::value,
+    _Tp
+>::type
+atomic_fetch_and_explicit(atomic<_Tp>* __o, _Tp __op, memory_order __m) _NOEXCEPT
+{
+    return __o->fetch_and(__op, __m);
+}
+
+// atomic_fetch_or
+
+template <class _Tp>
+inline _LIBCPP_INLINE_VISIBILITY
+typename enable_if
+<
+    is_integral<_Tp>::value && !is_same<_Tp, bool>::value,
+    _Tp
+>::type
+atomic_fetch_or(volatile atomic<_Tp>* __o, _Tp __op) _NOEXCEPT
+{
+    return __o->fetch_or(__op);
+}
+
+template <class _Tp>
+inline _LIBCPP_INLINE_VISIBILITY
+typename enable_if
+<
+    is_integral<_Tp>::value && !is_same<_Tp, bool>::value,
+    _Tp
+>::type
+atomic_fetch_or(atomic<_Tp>* __o, _Tp __op) _NOEXCEPT
+{
+    return __o->fetch_or(__op);
+}
+
+// atomic_fetch_or_explicit
+
+template <class _Tp>
+inline _LIBCPP_INLINE_VISIBILITY
+typename enable_if
+<
+    is_integral<_Tp>::value && !is_same<_Tp, bool>::value,
+    _Tp
+>::type
+atomic_fetch_or_explicit(volatile atomic<_Tp>* __o, _Tp __op, memory_order __m) _NOEXCEPT
+{
+    return __o->fetch_or(__op, __m);
+}
+
+template <class _Tp>
+inline _LIBCPP_INLINE_VISIBILITY
+typename enable_if
+<
+    is_integral<_Tp>::value && !is_same<_Tp, bool>::value,
+    _Tp
+>::type
+atomic_fetch_or_explicit(atomic<_Tp>* __o, _Tp __op, memory_order __m) _NOEXCEPT
+{
+    return __o->fetch_or(__op, __m);
+}
+
+// atomic_fetch_xor
+
+template <class _Tp>
+inline _LIBCPP_INLINE_VISIBILITY
+typename enable_if
+<
+    is_integral<_Tp>::value && !is_same<_Tp, bool>::value,
+    _Tp
+>::type
+atomic_fetch_xor(volatile atomic<_Tp>* __o, _Tp __op) _NOEXCEPT
+{
+    return __o->fetch_xor(__op);
+}
+
+template <class _Tp>
+inline _LIBCPP_INLINE_VISIBILITY
+typename enable_if
+<
+    is_integral<_Tp>::value && !is_same<_Tp, bool>::value,
+    _Tp
+>::type
+atomic_fetch_xor(atomic<_Tp>* __o, _Tp __op) _NOEXCEPT
+{
+    return __o->fetch_xor(__op);
+}
+
+// atomic_fetch_xor_explicit
+
+template <class _Tp>
+inline _LIBCPP_INLINE_VISIBILITY
+typename enable_if
+<
+    is_integral<_Tp>::value && !is_same<_Tp, bool>::value,
+    _Tp
+>::type
+atomic_fetch_xor_explicit(volatile atomic<_Tp>* __o, _Tp __op, memory_order __m) _NOEXCEPT
+{
+    return __o->fetch_xor(__op, __m);
+}
+
+template <class _Tp>
+inline _LIBCPP_INLINE_VISIBILITY
+typename enable_if
+<
+    is_integral<_Tp>::value && !is_same<_Tp, bool>::value,
+    _Tp
+>::type
+atomic_fetch_xor_explicit(atomic<_Tp>* __o, _Tp __op, memory_order __m) _NOEXCEPT
+{
+    return __o->fetch_xor(__op, __m);
+}
+
+// flag type and operations
+
+typedef struct atomic_flag
+{
+    _Atomic(bool) __a_;
+
+    _LIBCPP_INLINE_VISIBILITY
+    bool test_and_set(memory_order __m = memory_order_seq_cst) volatile _NOEXCEPT
+        {return __c11_atomic_exchange(&__a_, true, __m);}
+    _LIBCPP_INLINE_VISIBILITY
+    bool test_and_set(memory_order __m = memory_order_seq_cst) _NOEXCEPT
+        {return __c11_atomic_exchange(&__a_, true, __m);}
+    _LIBCPP_INLINE_VISIBILITY
+    void clear(memory_order __m = memory_order_seq_cst) volatile _NOEXCEPT
+        {__c11_atomic_store(&__a_, false, __m);}
+    _LIBCPP_INLINE_VISIBILITY
+    void clear(memory_order __m = memory_order_seq_cst) _NOEXCEPT
+        {__c11_atomic_store(&__a_, false, __m);}
+
+    _LIBCPP_INLINE_VISIBILITY
+#ifndef _LIBCPP_HAS_NO_DEFAULTED_FUNCTIONS
+    atomic_flag() _NOEXCEPT = default;
+#else
+    atomic_flag() _NOEXCEPT : __a_() {}
+#endif // _LIBCPP_HAS_NO_DEFAULTED_FUNCTIONS
+
+    _LIBCPP_INLINE_VISIBILITY
+    atomic_flag(bool __b) _NOEXCEPT : __a_(__b) {}
+
+#ifndef _LIBCPP_HAS_NO_DELETED_FUNCTIONS
+    atomic_flag(const atomic_flag&) = delete;
+    atomic_flag& operator=(const atomic_flag&) = delete;
+    atomic_flag& operator=(const atomic_flag&) volatile = delete;
+#else  // _LIBCPP_HAS_NO_DELETED_FUNCTIONS
+private:
+    atomic_flag(const atomic_flag&);
+    atomic_flag& operator=(const atomic_flag&);
+    atomic_flag& operator=(const atomic_flag&) volatile;
+#endif  // _LIBCPP_HAS_NO_DELETED_FUNCTIONS
+} atomic_flag;
+
+inline _LIBCPP_INLINE_VISIBILITY
+bool
+atomic_flag_test_and_set(volatile atomic_flag* __o) _NOEXCEPT
+{
+    return __o->test_and_set();
+}
+
+inline _LIBCPP_INLINE_VISIBILITY
+bool
+atomic_flag_test_and_set(atomic_flag* __o) _NOEXCEPT
+{
+    return __o->test_and_set();
+}
+
+inline _LIBCPP_INLINE_VISIBILITY
+bool
+atomic_flag_test_and_set_explicit(volatile atomic_flag* __o, memory_order __m) _NOEXCEPT
+{
+    return __o->test_and_set(__m);
+}
+
+inline _LIBCPP_INLINE_VISIBILITY
+bool
+atomic_flag_test_and_set_explicit(atomic_flag* __o, memory_order __m) _NOEXCEPT
+{
+    return __o->test_and_set(__m);
+}
+
+inline _LIBCPP_INLINE_VISIBILITY
+void
+atomic_flag_clear(volatile atomic_flag* __o) _NOEXCEPT
+{
+    __o->clear();
+}
+
+inline _LIBCPP_INLINE_VISIBILITY
+void
+atomic_flag_clear(atomic_flag* __o) _NOEXCEPT
+{
+    __o->clear();
+}
+
+inline _LIBCPP_INLINE_VISIBILITY
+void
+atomic_flag_clear_explicit(volatile atomic_flag* __o, memory_order __m) _NOEXCEPT
+{
+    __o->clear(__m);
+}
+
+inline _LIBCPP_INLINE_VISIBILITY
+void
+atomic_flag_clear_explicit(atomic_flag* __o, memory_order __m) _NOEXCEPT
+{
+    __o->clear(__m);
+}
+
+// fences
+
+inline _LIBCPP_INLINE_VISIBILITY
+void
+atomic_thread_fence(memory_order __m) _NOEXCEPT
+{
+    __c11_atomic_thread_fence(__m);
+}
+
+inline _LIBCPP_INLINE_VISIBILITY
+void
+atomic_signal_fence(memory_order __m) _NOEXCEPT
+{
+    __c11_atomic_signal_fence(__m);
+}
+
+// Atomics for standard typedef types
+
+typedef atomic<bool>               atomic_bool;
+typedef atomic<char>               atomic_char;
+typedef atomic<signed char>        atomic_schar;
+typedef atomic<unsigned char>      atomic_uchar;
+typedef atomic<short>              atomic_short;
+typedef atomic<unsigned short>     atomic_ushort;
+typedef atomic<int>                atomic_int;
+typedef atomic<unsigned int>       atomic_uint;
+typedef atomic<long>               atomic_long;
+typedef atomic<unsigned long>      atomic_ulong;
+typedef atomic<long long>          atomic_llong;
+typedef atomic<unsigned long long> atomic_ullong;
+typedef atomic<char16_t>           atomic_char16_t;
+typedef atomic<char32_t>           atomic_char32_t;
+typedef atomic<wchar_t>            atomic_wchar_t;
+
+typedef atomic<int_least8_t>   atomic_int_least8_t;
+typedef atomic<uint_least8_t>  atomic_uint_least8_t;
+typedef atomic<int_least16_t>  atomic_int_least16_t;
+typedef atomic<uint_least16_t> atomic_uint_least16_t;
+typedef atomic<int_least32_t>  atomic_int_least32_t;
+typedef atomic<uint_least32_t> atomic_uint_least32_t;
+typedef atomic<int_least64_t>  atomic_int_least64_t;
+typedef atomic<uint_least64_t> atomic_uint_least64_t;
+
+typedef atomic<int_fast8_t>   atomic_int_fast8_t;
+typedef atomic<uint_fast8_t>  atomic_uint_fast8_t;
+typedef atomic<int_fast16_t>  atomic_int_fast16_t;
+typedef atomic<uint_fast16_t> atomic_uint_fast16_t;
+typedef atomic<int_fast32_t>  atomic_int_fast32_t;
+typedef atomic<uint_fast32_t> atomic_uint_fast32_t;
+typedef atomic<int_fast64_t>  atomic_int_fast64_t;
+typedef atomic<uint_fast64_t> atomic_uint_fast64_t;
+
+typedef atomic<intptr_t>  atomic_intptr_t;
+typedef atomic<uintptr_t> atomic_uintptr_t;
+typedef atomic<size_t>    atomic_size_t;
+typedef atomic<ptrdiff_t> atomic_ptrdiff_t;
+typedef atomic<intmax_t>  atomic_intmax_t;
+typedef atomic<uintmax_t> atomic_uintmax_t;
+
+#define ATOMIC_FLAG_INIT {false}
+#define ATOMIC_VAR_INIT(__v) {__v}
+
+// lock-free property
+
+#define ATOMIC_BOOL_LOCK_FREE      __GCC_ATOMIC_BOOL_LOCK_FREE
+#define ATOMIC_CHAR_LOCK_FREE      __GCC_ATOMIC_CHAR_LOCK_FREE
+#define ATOMIC_CHAR16_T_LOCK_FREE  __GCC_ATOMIC_CHAR16_T_LOCK_FREE
+#define ATOMIC_CHAR32_T_LOCK_FREE  __GCC_ATOMIC_CHAR32_T_LOCK_FREE
+#define ATOMIC_WCHAR_T_LOCK_FREE   __GCC_ATOMIC_WCHAR_T_LOCK_FREE
+#define ATOMIC_SHORT_LOCK_FREE     __GCC_ATOMIC_SHORT_LOCK_FREE
+#define ATOMIC_INT_LOCK_FREE       __GCC_ATOMIC_INT_LOCK_FREE
+#define ATOMIC_LONG_LOCK_FREE      __GCC_ATOMIC_LONG_LOCK_FREE
+#define ATOMIC_LLONG_LOCK_FREE     __GCC_ATOMIC_LLONG_LOCK_FREE
+#define ATOMIC_POINTER_LOCK_FREE   __GCC_ATOMIC_POINTER_LOCK_FREE
+
+#endif  //  !__has_feature(cxx_atomic)
+
+_LIBCPP_END_NAMESPACE_STD
+
+#endif  // !_LIBCPP_HAS_NO_THREADS
+
+#endif  // _LIBCPP_ATOMIC
diff -uNr libcxx-3.7.0.src.orig/include/cmath libcxx-3.7.0.src/include/cmath
--- libcxx-3.7.0.src.orig/include/cmath	2015-03-19 11:40:26.000000000 -0400
+++ libcxx-3.7.0.src/include/cmath	2015-07-04 22:33:31.000000000 -0400
@@ -298,7 +298,27 @@
 */
 
 #include <__config>
+
+// The C++11 standard requires C99, but whether or not __STDC_VERSION__
+// is accordingly set is implementation-defined.
+// on darwin10: C99 is explicltly required to enable long long returning 
+// functions, like llrint and llround.
+// Alternatively, undefine __STRICT_ANSI__ for those symbols.
+// This is just a convenient, isolated workaround.
+// #if defined(__APPLE__) && (__cplusplus >= 201101L) && !defined(__STDC_VERSION__)
+#if defined(__APPLE__) && (__cplusplus >= 201101L) && !defined(__STDC_VERSION__) && defined(__STRICT_ANSI__)
+#define	__IMPLICIT_STDC_VERSION_C99__
+// #define	__STDC_VERSION__	199901L
+#undef	__STRICT_ANSI__
+#endif
 #include <math.h>
+#ifdef	__IMPLICIT_STDC_VERSION_C99__
+// undo the abvoe
+// #undef	__STDC_VERSION__
+#define	__STRICT_ANSI__
+// __IMPLICIT_STDC_VERSION_C99__ remains defined as evidence of what happened
+#endif
+
 #include <type_traits>
 
 #ifdef _LIBCPP_MSVCRT
diff -uNr libcxx-3.7.0.src.orig/include/iterator libcxx-3.7.0.src/include/iterator
--- libcxx-3.7.0.src.orig/include/iterator	2015-04-17 00:25:49.000000000 -0400
+++ libcxx-3.7.0.src/include/iterator	2015-07-04 22:33:31.000000000 -0400
@@ -346,7 +346,7 @@
 #include <iosfwd>
 #include <initializer_list>
 #ifdef __APPLE__
-#include <Availability.h>
+#include <AvailabilityMacros.h>
 #endif
 
 #include <__debug>
@@ -920,8 +920,8 @@
     _LIBCPP_INLINE_VISIBILITY bool failed() const _NOEXCEPT {return __sbuf_ == 0;}
 
 #if !defined(__APPLE__) || \
-    (defined(__MAC_OS_X_VERSION_MIN_REQUIRED) && __MAC_OS_X_VERSION_MIN_REQUIRED > __MAC_10_8) || \
-    (defined(__IPHONE_OS_VERSION_MIN_REQUIRED) && __IPHONE_OS_VERSION_MIN_REQUIRED > __IPHONE_6_0)
+    (defined(__MAC_OS_X_VERSION_MIN_REQUIRED) && defined(__MAC_10_8) && __MAC_OS_X_VERSION_MIN_REQUIRED > __MAC_10_8) || \
+    (defined(__IPHONE_OS_VERSION_MIN_REQUIRED) && defined(__IPHONE_6_0) && __IPHONE_OS_VERSION_MIN_REQUIRED > __IPHONE_6_0)
 
     template <class _Ch, class _Tr>
     friend
diff -uNr libcxx-3.7.0.src.orig/include/locale libcxx-3.7.0.src/include/locale
--- libcxx-3.7.0.src.orig/include/locale	2015-03-19 11:40:26.000000000 -0400
+++ libcxx-3.7.0.src/include/locale	2015-07-04 22:33:31.000000000 -0400
@@ -204,7 +204,7 @@
 #endif
 
 #ifdef __APPLE__
-#include <Availability.h>
+#include <AvailabilityMacros.h>
 #endif
 
 #include <__undef_min_max>
@@ -1474,8 +1474,8 @@
 }
 
 #if !defined(__APPLE__) || \
-    (defined(__MAC_OS_X_VERSION_MIN_REQUIRED) && __MAC_OS_X_VERSION_MIN_REQUIRED > __MAC_10_8) || \
-    (defined(__IPHONE_OS_VERSION_MIN_REQUIRED) && __IPHONE_OS_VERSION_MIN_REQUIRED > __IPHONE_6_0)
+    (defined(__MAC_OS_X_VERSION_MIN_REQUIRED) && defined(__MAC_10_8) && __MAC_OS_X_VERSION_MIN_REQUIRED > __MAC_10_8) || \
+    (defined(__IPHONE_OS_VERSION_MIN_REQUIRED) && defined(__IPHONE_6_0) && __IPHONE_OS_VERSION_MIN_REQUIRED > __IPHONE_6_0)
 
 template <class _CharT, class _Traits>
 _LIBCPP_HIDDEN
diff -uNr libcxx-3.7.0.src.orig/include/locale.orig libcxx-3.7.0.src/include/locale.orig
--- libcxx-3.7.0.src.orig/include/locale.orig	1969-12-31 19:00:00.000000000 -0500
+++ libcxx-3.7.0.src/include/locale.orig	2015-03-19 11:40:26.000000000 -0400
@@ -0,0 +1,4474 @@
+// -*- C++ -*-
+//===-------------------------- locale ------------------------------------===//
+//
+//                     The LLVM Compiler Infrastructure
+//
+// This file is dual licensed under the MIT and the University of Illinois Open
+// Source Licenses. See LICENSE.TXT for details.
+//
+//===----------------------------------------------------------------------===//
+
+#ifndef _LIBCPP_LOCALE
+#define _LIBCPP_LOCALE
+
+/*
+    locale synopsis
+
+namespace std
+{
+
+class locale
+{
+public:
+    // types:
+    class facet;
+    class id;
+
+    typedef int category;
+    static const category // values assigned here are for exposition only
+        none     = 0x000,
+        collate  = 0x010,
+        ctype    = 0x020,
+        monetary = 0x040,
+        numeric  = 0x080,
+        time     = 0x100,
+        messages = 0x200,
+        all = collate | ctype | monetary | numeric | time | messages;
+
+    // construct/copy/destroy:
+    locale() noexcept;
+    locale(const locale& other) noexcept;
+    explicit locale(const char* std_name);
+    explicit locale(const string& std_name);
+    locale(const locale& other, const char* std_name, category);
+    locale(const locale& other, const string& std_name, category);
+    template <class Facet> locale(const locale& other, Facet* f);
+    locale(const locale& other, const locale& one, category);
+
+    ~locale(); // not virtual
+
+    const locale& operator=(const locale& other) noexcept;
+
+    template <class Facet> locale combine(const locale& other) const;
+
+    // locale operations:
+    basic_string<char> name() const;
+    bool operator==(const locale& other) const;
+    bool operator!=(const locale& other) const;
+    template <class charT, class Traits, class Allocator>
+      bool operator()(const basic_string<charT,Traits,Allocator>& s1,
+                      const basic_string<charT,Traits,Allocator>& s2) const;
+
+    // global locale objects:
+    static locale global(const locale&);
+    static const locale& classic();
+};
+
+template <class Facet> const Facet& use_facet(const locale&);
+template <class Facet> bool has_facet(const locale&) noexcept;
+
+// 22.3.3, convenience interfaces:
+template <class charT> bool isspace (charT c, const locale& loc);
+template <class charT> bool isprint (charT c, const locale& loc);
+template <class charT> bool iscntrl (charT c, const locale& loc);
+template <class charT> bool isupper (charT c, const locale& loc);
+template <class charT> bool islower (charT c, const locale& loc);
+template <class charT> bool isalpha (charT c, const locale& loc);
+template <class charT> bool isdigit (charT c, const locale& loc);
+template <class charT> bool ispunct (charT c, const locale& loc);
+template <class charT> bool isxdigit(charT c, const locale& loc);
+template <class charT> bool isalnum (charT c, const locale& loc);
+template <class charT> bool isgraph (charT c, const locale& loc);
+template <class charT> charT toupper(charT c, const locale& loc);
+template <class charT> charT tolower(charT c, const locale& loc);
+
+template<class Codecvt, class Elem = wchar_t,
+         class Wide_alloc = allocator<Elem>,
+         class Byte_alloc = allocator<char>>
+class wstring_convert
+{
+public:
+    typedef basic_string<char, char_traits<char>, Byte_alloc> byte_string;
+    typedef basic_string<Elem, char_traits<Elem>, Wide_alloc> wide_string;
+    typedef typename Codecvt::state_type                      state_type;
+    typedef typename wide_string::traits_type::int_type       int_type;
+
+    explicit wstring_convert(Codecvt* pcvt = new Codecvt);          // explicit in C++14
+    wstring_convert(Codecvt* pcvt, state_type state);
+    explicit wstring_convert(const byte_string& byte_err,           // explicit in C++14
+                    const wide_string& wide_err = wide_string());
+    wstring_convert(const wstring_convert&) = delete;               // C++14
+    wstring_convert & operator=(const wstring_convert &) = delete;  // C++14
+    ~wstring_convert();
+
+    wide_string from_bytes(char byte);
+    wide_string from_bytes(const char* ptr);
+    wide_string from_bytes(const byte_string& str);
+    wide_string from_bytes(const char* first, const char* last);
+
+    byte_string to_bytes(Elem wchar);
+    byte_string to_bytes(const Elem* wptr);
+    byte_string to_bytes(const wide_string& wstr);
+    byte_string to_bytes(const Elem* first, const Elem* last);
+
+    size_t converted() const; // noexcept in C++14
+    state_type state() const;
+};
+
+template <class Codecvt, class Elem = wchar_t, class Tr = char_traits<Elem>>
+class wbuffer_convert
+    : public basic_streambuf<Elem, Tr>
+{
+public:
+    typedef typename Tr::state_type state_type;
+
+    explicit wbuffer_convert(streambuf* bytebuf = 0, Codecvt* pcvt = new Codecvt,
+                    state_type state = state_type());       // explicit in C++14
+    wbuffer_convert(const wbuffer_convert&) = delete;               // C++14
+    wbuffer_convert & operator=(const wbuffer_convert &) = delete;  // C++14
+    ~wbuffer_convert();                                             // C++14
+    
+    streambuf* rdbuf() const;
+    streambuf* rdbuf(streambuf* bytebuf);
+
+    state_type state() const;
+};
+
+// 22.4.1 and 22.4.1.3, ctype:
+class ctype_base;
+template <class charT> class ctype;
+template <> class ctype<char>; // specialization
+template <class charT> class ctype_byname;
+template <> class ctype_byname<char>; // specialization
+
+class codecvt_base;
+template <class internT, class externT, class stateT> class codecvt;
+template <class internT, class externT, class stateT> class codecvt_byname;
+
+// 22.4.2 and 22.4.3, numeric:
+template <class charT, class InputIterator> class num_get;
+template <class charT, class OutputIterator> class num_put;
+template <class charT> class numpunct;
+template <class charT> class numpunct_byname;
+
+// 22.4.4, col lation:
+template <class charT> class collate;
+template <class charT> class collate_byname;
+
+// 22.4.5, date and time:
+class time_base;
+template <class charT, class InputIterator> class time_get;
+template <class charT, class InputIterator> class time_get_byname;
+template <class charT, class OutputIterator> class time_put;
+template <class charT, class OutputIterator> class time_put_byname;
+
+// 22.4.6, money:
+class money_base;
+template <class charT, class InputIterator> class money_get;
+template <class charT, class OutputIterator> class money_put;
+template <class charT, bool Intl> class moneypunct;
+template <class charT, bool Intl> class moneypunct_byname;
+
+// 22.4.7, message retrieval:
+class messages_base;
+template <class charT> class messages;
+template <class charT> class messages_byname;
+
+}  // std
+
+*/
+
+#include <__config>
+#include <__locale>
+#include <algorithm>
+#include <memory>
+#include <ios>
+#include <streambuf>
+#include <iterator>
+#include <limits>
+#ifndef __APPLE__
+#include <cstdarg>
+#endif
+#include <cstdlib>
+#include <ctime>
+#if defined(_LIBCPP_MSVCRT) || defined(__MINGW32__)
+#include <support/win32/locale_win32.h>
+#elif defined(_NEWLIB_VERSION)
+// FIXME: replace all the uses of _NEWLIB_VERSION with __NEWLIB__ preceded by an
+// include of <sys/cdefs.h> once https://sourceware.org/ml/newlib-cvs/2014-q3/msg00038.html
+// has had a chance to bake for a bit
+#include <support/newlib/xlocale.h>
+#endif
+#ifdef _LIBCPP_HAS_CATOPEN
+#include <nl_types.h>
+#endif
+
+#ifdef __APPLE__
+#include <Availability.h>
+#endif
+
+#include <__undef_min_max>
+
+#if !defined(_LIBCPP_HAS_NO_PRAGMA_SYSTEM_HEADER)
+#pragma GCC system_header
+#endif
+
+_LIBCPP_BEGIN_NAMESPACE_STD
+
+#if defined(__APPLE__) || defined(__FreeBSD__)
+#  define _LIBCPP_GET_C_LOCALE 0
+#elif defined(__CloudABI__) || defined(__NetBSD__)
+#  define _LIBCPP_GET_C_LOCALE LC_C_LOCALE
+#else
+#  define _LIBCPP_GET_C_LOCALE __cloc()
+   // Get the C locale object
+   _LIBCPP_FUNC_VIS locale_t __cloc();
+#define __cloc_defined
+#endif
+
+typedef _VSTD::remove_pointer<locale_t>::type __locale_struct;
+typedef _VSTD::unique_ptr<__locale_struct, decltype(&freelocale)> __locale_unique_ptr;
+#ifndef _LIBCPP_LOCALE__L_EXTENSIONS
+typedef _VSTD::unique_ptr<__locale_struct, decltype(&uselocale)> __locale_raii;
+#endif
+
+// OSX has nice foo_l() functions that let you turn off use of the global
+// locale.  Linux, not so much.  The following functions avoid the locale when
+// that's possible and otherwise do the wrong thing.  FIXME.
+#if defined(__linux__) || defined(__EMSCRIPTEN__) || defined(_AIX) || \
+    defined(_NEWLIB_VERSION) || defined(__GLIBC__)
+
+#ifdef _LIBCPP_LOCALE__L_EXTENSIONS
+decltype(MB_CUR_MAX_L(_VSTD::declval<locale_t>()))
+inline _LIBCPP_INLINE_VISIBILITY
+__mb_cur_max_l(locale_t __l)
+{
+  return MB_CUR_MAX_L(__l);
+}
+#else  // _LIBCPP_LOCALE__L_EXTENSIONS
+inline _LIBCPP_ALWAYS_INLINE
+decltype(MB_CUR_MAX) __mb_cur_max_l(locale_t __l)
+{
+  __locale_raii __current(uselocale(__l), uselocale);
+  return MB_CUR_MAX;
+}
+#endif // _LIBCPP_LOCALE__L_EXTENSIONS
+
+inline _LIBCPP_ALWAYS_INLINE
+wint_t __btowc_l(int __c, locale_t __l)
+{
+#ifdef _LIBCPP_LOCALE__L_EXTENSIONS
+  return btowc_l(__c, __l);
+#else
+  __locale_raii __current(uselocale(__l), uselocale);
+  return btowc(__c);
+#endif
+}
+
+inline _LIBCPP_ALWAYS_INLINE
+int __wctob_l(wint_t __c, locale_t __l)
+{
+#ifdef _LIBCPP_LOCALE__L_EXTENSIONS
+  return wctob_l(__c, __l);
+#else
+  __locale_raii __current(uselocale(__l), uselocale);
+  return wctob(__c);
+#endif
+}
+
+inline _LIBCPP_ALWAYS_INLINE
+size_t __wcsnrtombs_l(char *__dest, const wchar_t **__src, size_t __nwc,
+                      size_t __len, mbstate_t *__ps, locale_t __l)
+{
+#ifdef _LIBCPP_LOCALE__L_EXTENSIONS
+  return wcsnrtombs_l(__dest, __src, __nwc, __len, __ps, __l);
+#else
+  __locale_raii __current(uselocale(__l), uselocale);
+  return wcsnrtombs(__dest, __src, __nwc, __len, __ps);
+#endif
+}
+
+inline _LIBCPP_ALWAYS_INLINE
+size_t __wcrtomb_l(char *__s, wchar_t __wc, mbstate_t *__ps, locale_t __l)
+{
+#ifdef _LIBCPP_LOCALE__L_EXTENSIONS
+  return wcrtomb_l(__s, __wc, __ps, __l);
+#else
+  __locale_raii __current(uselocale(__l), uselocale);
+  return wcrtomb(__s, __wc, __ps);
+#endif
+}
+
+inline _LIBCPP_ALWAYS_INLINE
+size_t __mbsnrtowcs_l(wchar_t * __dest, const char **__src, size_t __nms,
+                      size_t __len, mbstate_t *__ps, locale_t __l)
+{
+#ifdef _LIBCPP_LOCALE__L_EXTENSIONS
+  return mbsnrtowcs_l(__dest, __src, __nms, __len, __ps, __l);
+#else
+  __locale_raii __current(uselocale(__l), uselocale);
+  return mbsnrtowcs(__dest, __src, __nms, __len, __ps);
+#endif
+}
+
+inline _LIBCPP_ALWAYS_INLINE
+size_t __mbrtowc_l(wchar_t *__pwc, const char *__s, size_t __n,
+                   mbstate_t *__ps, locale_t __l)
+{
+#ifdef _LIBCPP_LOCALE__L_EXTENSIONS
+  return mbrtowc_l(__pwc, __s, __n, __ps, __l);
+#else
+  __locale_raii __current(uselocale(__l), uselocale);
+  return mbrtowc(__pwc, __s, __n, __ps);
+#endif
+}
+
+inline _LIBCPP_ALWAYS_INLINE
+int __mbtowc_l(wchar_t *__pwc, const char *__pmb, size_t __max, locale_t __l)
+{
+#ifdef _LIBCPP_LOCALE__L_EXTENSIONS
+  return mbtowc_l(__pwc, __pmb, __max, __l);
+#else
+  __locale_raii __current(uselocale(__l), uselocale);
+  return mbtowc(__pwc, __pmb, __max);
+#endif
+}
+
+inline _LIBCPP_ALWAYS_INLINE
+size_t __mbrlen_l(const char *__s, size_t __n, mbstate_t *__ps, locale_t __l)
+{
+#ifdef _LIBCPP_LOCALE__L_EXTENSIONS
+  return mbrlen_l(__s, __n, __ps, __l);
+#else
+  __locale_raii __current(uselocale(__l), uselocale);
+  return mbrlen(__s, __n, __ps);
+#endif
+}
+
+inline _LIBCPP_ALWAYS_INLINE
+lconv *__localeconv_l(locale_t __l)
+{
+#ifdef _LIBCPP_LOCALE__L_EXTENSIONS
+  return localeconv_l(__l);
+#else
+  __locale_raii __current(uselocale(__l), uselocale);
+  return localeconv();
+#endif
+}
+
+inline _LIBCPP_ALWAYS_INLINE
+size_t __mbsrtowcs_l(wchar_t *__dest, const char **__src, size_t __len,
+                     mbstate_t *__ps, locale_t __l)
+{
+#ifdef _LIBCPP_LOCALE__L_EXTENSIONS
+  return mbsrtowcs_l(__dest, __src, __len, __ps, __l);
+#else
+  __locale_raii __current(uselocale(__l), uselocale);
+  return mbsrtowcs(__dest, __src, __len, __ps);
+#endif
+}
+
+inline
+int __snprintf_l(char *__s, size_t __n, locale_t __l, const char *__format, ...) {
+  va_list __va;
+  va_start(__va, __format);
+#ifdef _LIBCPP_LOCALE__L_EXTENSIONS
+  int __res = vsnprintf_l(__s, __n, __l, __format, __va);
+#else
+  __locale_raii __current(uselocale(__l), uselocale);
+  int __res = vsnprintf(__s, __n, __format, __va);
+#endif
+  va_end(__va);
+  return __res;
+}
+
+inline
+int __asprintf_l(char **__s, locale_t __l, const char *__format, ...) {
+  va_list __va;
+  va_start(__va, __format);
+#ifdef _LIBCPP_LOCALE__L_EXTENSIONS
+  int __res = vasprintf_l(__s, __l, __format, __va);
+#else
+  __locale_raii __current(uselocale(__l), uselocale);
+  int __res = vasprintf(__s, __format, __va);
+#endif
+  va_end(__va);
+  return __res;
+}
+
+inline
+int __sscanf_l(const char *__s, locale_t __l, const char *__format, ...) {
+  va_list __va;
+  va_start(__va, __format);
+#ifdef _LIBCPP_LOCALE__L_EXTENSIONS
+  int __res = vsscanf_l(__s, __l, __format, __va);
+#else
+  __locale_raii __current(uselocale(__l), uselocale);
+  int __res = vsscanf(__s, __format, __va);
+#endif
+  va_end(__va);
+  return __res;
+}
+
+#endif  // __linux__
+
+// __scan_keyword
+// Scans [__b, __e) until a match is found in the basic_strings range
+//  [__kb, __ke) or until it can be shown that there is no match in [__kb, __ke).
+//  __b will be incremented (visibly), consuming CharT until a match is found
+//  or proved to not exist.  A keyword may be "", in which will match anything.
+//  If one keyword is a prefix of another, and the next CharT in the input
+//  might match another keyword, the algorithm will attempt to find the longest
+//  matching keyword.  If the longer matching keyword ends up not matching, then
+//  no keyword match is found.  If no keyword match is found, __ke is returned
+//  and failbit is set in __err.
+//  Else an iterator pointing to the matching keyword is found.  If more than
+//  one keyword matches, an iterator to the first matching keyword is returned.
+//  If on exit __b == __e, eofbit is set in __err.  If __case_sensitive is false,
+//  __ct is used to force to lower case before comparing characters.
+//  Examples:
+//  Keywords:  "a", "abb"
+//  If the input is "a", the first keyword matches and eofbit is set.
+//  If the input is "abc", no match is found and "ab" are consumed.
+template <class _InputIterator, class _ForwardIterator, class _Ctype>
+_LIBCPP_HIDDEN
+_ForwardIterator
+__scan_keyword(_InputIterator& __b, _InputIterator __e,
+               _ForwardIterator __kb, _ForwardIterator __ke,
+               const _Ctype& __ct, ios_base::iostate& __err,
+               bool __case_sensitive = true)
+{
+    typedef typename iterator_traits<_InputIterator>::value_type _CharT;
+    size_t __nkw = static_cast<size_t>(_VSTD::distance(__kb, __ke));
+    const unsigned char __doesnt_match = '\0';
+    const unsigned char __might_match = '\1';
+    const unsigned char __does_match = '\2';
+    unsigned char __statbuf[100];
+    unsigned char* __status = __statbuf;
+    unique_ptr<unsigned char, void(*)(void*)> __stat_hold(0, free);
+    if (__nkw > sizeof(__statbuf))
+    {
+        __status = (unsigned char*)malloc(__nkw);
+        if (__status == 0)
+            __throw_bad_alloc();
+        __stat_hold.reset(__status);
+    }
+    size_t __n_might_match = __nkw;  // At this point, any keyword might match
+    size_t __n_does_match = 0;       // but none of them definitely do
+    // Initialize all statuses to __might_match, except for "" keywords are __does_match
+    unsigned char* __st = __status;
+    for (_ForwardIterator __ky = __kb; __ky != __ke; ++__ky, (void) ++__st)
+    {
+        if (!__ky->empty())
+            *__st = __might_match;
+        else
+        {
+            *__st = __does_match;
+            --__n_might_match;
+            ++__n_does_match;
+        }
+    }
+    // While there might be a match, test keywords against the next CharT
+    for (size_t __indx = 0; __b != __e && __n_might_match > 0; ++__indx)
+    {
+        // Peek at the next CharT but don't consume it
+        _CharT __c = *__b;
+        if (!__case_sensitive)
+            __c = __ct.toupper(__c);
+        bool __consume = false;
+        // For each keyword which might match, see if the __indx character is __c
+        // If a match if found, consume __c
+        // If a match is found, and that is the last character in the keyword,
+        //    then that keyword matches.
+        // If the keyword doesn't match this character, then change the keyword
+        //    to doesn't match
+        __st = __status;
+        for (_ForwardIterator __ky = __kb; __ky != __ke; ++__ky, (void) ++__st)
+        {
+            if (*__st == __might_match)
+            {
+                _CharT __kc = (*__ky)[__indx];
+                if (!__case_sensitive)
+                    __kc = __ct.toupper(__kc);
+                if (__c == __kc)
+                {
+                    __consume = true;
+                    if (__ky->size() == __indx+1)
+                    {
+                        *__st = __does_match;
+                        --__n_might_match;
+                        ++__n_does_match;
+                    }
+                }
+                else
+                {
+                    *__st = __doesnt_match;
+                    --__n_might_match;
+                }
+            }
+        }
+        // consume if we matched a character
+        if (__consume)
+        {
+            ++__b;
+            // If we consumed a character and there might be a matched keyword that
+            //   was marked matched on a previous iteration, then such keywords
+            //   which are now marked as not matching.
+            if (__n_might_match + __n_does_match > 1)
+            {
+                __st = __status;
+                for (_ForwardIterator __ky = __kb; __ky != __ke; ++__ky, (void) ++__st)
+                {
+                    if (*__st == __does_match && __ky->size() != __indx+1)
+                    {
+                        *__st = __doesnt_match;
+                        --__n_does_match;
+                    }
+                }
+            }
+        }
+    }
+    // We've exited the loop because we hit eof and/or we have no more "might matches".
+    if (__b == __e)
+        __err |= ios_base::eofbit;
+    // Return the first matching result
+    for (__st = __status; __kb != __ke; ++__kb, (void) ++__st)
+        if (*__st == __does_match)
+            break;
+    if (__kb == __ke)
+        __err |= ios_base::failbit;
+    return __kb;
+}
+
+struct _LIBCPP_TYPE_VIS __num_get_base
+{
+    static const int __num_get_buf_sz = 40;
+
+    static int __get_base(ios_base&);
+    static const char __src[33];
+};
+
+_LIBCPP_FUNC_VIS
+void __check_grouping(const string& __grouping, unsigned* __g, unsigned* __g_end,
+                      ios_base::iostate& __err);
+
+template <class _CharT>
+struct __num_get
+    : protected __num_get_base
+{
+    static string __stage2_int_prep(ios_base& __iob, _CharT* __atoms, _CharT& __thousands_sep);
+    static string __stage2_float_prep(ios_base& __iob, _CharT* __atoms, _CharT& __decimal_point,
+                                      _CharT& __thousands_sep);
+    static int __stage2_int_loop(_CharT __ct, int __base, char* __a, char*& __a_end,
+                  unsigned& __dc, _CharT __thousands_sep, const string& __grouping,
+                  unsigned* __g, unsigned*& __g_end, _CharT* __atoms);
+    static int __stage2_float_loop(_CharT __ct, bool& __in_units, char& __exp,
+                                   char* __a, char*& __a_end,
+                                   _CharT __decimal_point, _CharT __thousands_sep,
+                                   const string& __grouping, unsigned* __g,
+                                   unsigned*& __g_end, unsigned& __dc, _CharT* __atoms);
+};
+
+template <class _CharT>
+string
+__num_get<_CharT>::__stage2_int_prep(ios_base& __iob, _CharT* __atoms, _CharT& __thousands_sep)
+{
+    locale __loc = __iob.getloc();
+    use_facet<ctype<_CharT> >(__loc).widen(__src, __src + 26, __atoms);
+    const numpunct<_CharT>& __np = use_facet<numpunct<_CharT> >(__loc);
+    __thousands_sep = __np.thousands_sep();
+    return __np.grouping();
+}
+
+template <class _CharT>
+string
+__num_get<_CharT>::__stage2_float_prep(ios_base& __iob, _CharT* __atoms, _CharT& __decimal_point,
+                    _CharT& __thousands_sep)
+{
+    locale __loc = __iob.getloc();
+    use_facet<ctype<_CharT> >(__loc).widen(__src, __src + 32, __atoms);
+    const numpunct<_CharT>& __np = use_facet<numpunct<_CharT> >(__loc);
+    __decimal_point = __np.decimal_point();
+    __thousands_sep = __np.thousands_sep();
+    return __np.grouping();
+}
+
+template <class _CharT>
+int
+__num_get<_CharT>::__stage2_int_loop(_CharT __ct, int __base, char* __a, char*& __a_end,
+                  unsigned& __dc, _CharT __thousands_sep, const string& __grouping,
+                  unsigned* __g, unsigned*& __g_end, _CharT* __atoms)
+{
+    if (__a_end == __a && (__ct == __atoms[24] || __ct == __atoms[25]))
+    {
+        *__a_end++ = __ct == __atoms[24] ? '+' : '-';
+        __dc = 0;
+        return 0;
+    }
+    if (__grouping.size() != 0 && __ct == __thousands_sep)
+    {
+        if (__g_end-__g < __num_get_buf_sz)
+        {
+            *__g_end++ = __dc;
+            __dc = 0;
+        }
+        return 0;
+    }
+    ptrdiff_t __f = find(__atoms, __atoms + 26, __ct) - __atoms;
+    if (__f >= 24)
+        return -1;
+    switch (__base)
+    {
+    case 8:
+    case 10:
+        if (__f >= __base)
+            return -1;
+        break;
+    case 16:
+        if (__f < 22)
+            break;
+        if (__a_end != __a && __a_end - __a <= 2 && __a_end[-1] == '0')
+        {
+            __dc = 0;
+            *__a_end++ = __src[__f];
+            return 0;
+        }
+        return -1;
+    }
+    *__a_end++ = __src[__f];
+    ++__dc;
+    return 0;
+}
+
+template <class _CharT>
+int
+__num_get<_CharT>::__stage2_float_loop(_CharT __ct, bool& __in_units, char& __exp, char* __a, char*& __a_end,
+                    _CharT __decimal_point, _CharT __thousands_sep, const string& __grouping,
+                    unsigned* __g, unsigned*& __g_end, unsigned& __dc, _CharT* __atoms)
+{
+    if (__ct == __decimal_point)
+    {
+        if (!__in_units)
+            return -1;
+        __in_units = false;
+        *__a_end++ = '.';
+        if (__grouping.size() != 0 && __g_end-__g < __num_get_buf_sz)
+            *__g_end++ = __dc;
+        return 0;
+    }
+    if (__ct == __thousands_sep && __grouping.size() != 0)
+    {
+        if (!__in_units)
+            return -1;
+        if (__g_end-__g < __num_get_buf_sz)
+        {
+            *__g_end++ = __dc;
+            __dc = 0;
+        }
+        return 0;
+    }
+    ptrdiff_t __f = find(__atoms, __atoms + 32, __ct) - __atoms;
+    if (__f >= 32)
+        return -1;
+    char __x = __src[__f];
+    if (__x == '-' || __x == '+')
+    {
+        if (__a_end == __a || (__a_end[-1] & 0x5F) == (__exp & 0x7F))
+        {
+            *__a_end++ = __x;
+            return 0;
+        }
+        return -1;
+    }
+    if (__x == 'x' || __x == 'X')
+        __exp = 'P';
+    else if ((__x & 0x5F) == __exp)
+    {
+        __exp |= 0x80;
+        if (__in_units)
+        {
+            __in_units = false;
+            if (__grouping.size() != 0 && __g_end-__g < __num_get_buf_sz)
+                *__g_end++ = __dc;
+        }
+    }
+    *__a_end++ = __x;
+    if (__f >= 22)
+        return 0;
+    ++__dc;
+    return 0;
+}
+
+_LIBCPP_EXTERN_TEMPLATE2(struct _LIBCPP_TYPE_VIS __num_get<char>)
+_LIBCPP_EXTERN_TEMPLATE2(struct _LIBCPP_TYPE_VIS __num_get<wchar_t>)
+
+template <class _CharT, class _InputIterator = istreambuf_iterator<_CharT> >
+class _LIBCPP_TYPE_VIS_ONLY num_get
+    : public locale::facet,
+      private __num_get<_CharT>
+{
+public:
+    typedef _CharT char_type;
+    typedef _InputIterator iter_type;
+
+    _LIBCPP_ALWAYS_INLINE
+    explicit num_get(size_t __refs = 0)
+        : locale::facet(__refs) {}
+
+    _LIBCPP_ALWAYS_INLINE
+    iter_type get(iter_type __b, iter_type __e, ios_base& __iob,
+                  ios_base::iostate& __err, bool& __v) const
+    {
+        return do_get(__b, __e, __iob, __err, __v);
+    }
+
+    _LIBCPP_ALWAYS_INLINE
+    iter_type get(iter_type __b, iter_type __e, ios_base& __iob,
+                  ios_base::iostate& __err, long& __v) const
+    {
+        return do_get(__b, __e, __iob, __err, __v);
+    }
+
+    _LIBCPP_ALWAYS_INLINE
+    iter_type get(iter_type __b, iter_type __e, ios_base& __iob,
+                  ios_base::iostate& __err, long long& __v) const
+    {
+        return do_get(__b, __e, __iob, __err, __v);
+    }
+
+    _LIBCPP_ALWAYS_INLINE
+    iter_type get(iter_type __b, iter_type __e, ios_base& __iob,
+                  ios_base::iostate& __err, unsigned short& __v) const
+    {
+        return do_get(__b, __e, __iob, __err, __v);
+    }
+
+    _LIBCPP_ALWAYS_INLINE
+    iter_type get(iter_type __b, iter_type __e, ios_base& __iob,
+                  ios_base::iostate& __err, unsigned int& __v) const
+    {
+        return do_get(__b, __e, __iob, __err, __v);
+    }
+
+    _LIBCPP_ALWAYS_INLINE
+    iter_type get(iter_type __b, iter_type __e, ios_base& __iob,
+                  ios_base::iostate& __err, unsigned long& __v) const
+    {
+        return do_get(__b, __e, __iob, __err, __v);
+    }
+
+    _LIBCPP_ALWAYS_INLINE
+    iter_type get(iter_type __b, iter_type __e, ios_base& __iob,
+                  ios_base::iostate& __err, unsigned long long& __v) const
+    {
+        return do_get(__b, __e, __iob, __err, __v);
+    }
+
+    _LIBCPP_ALWAYS_INLINE
+    iter_type get(iter_type __b, iter_type __e, ios_base& __iob,
+                  ios_base::iostate& __err, float& __v) const
+    {
+        return do_get(__b, __e, __iob, __err, __v);
+    }
+
+    _LIBCPP_ALWAYS_INLINE
+    iter_type get(iter_type __b, iter_type __e, ios_base& __iob,
+                  ios_base::iostate& __err, double& __v) const
+    {
+        return do_get(__b, __e, __iob, __err, __v);
+    }
+
+    _LIBCPP_ALWAYS_INLINE
+    iter_type get(iter_type __b, iter_type __e, ios_base& __iob,
+                  ios_base::iostate& __err, long double& __v) const
+    {
+        return do_get(__b, __e, __iob, __err, __v);
+    }
+
+    _LIBCPP_ALWAYS_INLINE
+    iter_type get(iter_type __b, iter_type __e, ios_base& __iob,
+                  ios_base::iostate& __err, void*& __v) const
+    {
+        return do_get(__b, __e, __iob, __err, __v);
+    }
+
+    static locale::id id;
+
+protected:
+    _LIBCPP_ALWAYS_INLINE
+    ~num_get() {}
+
+    template <class _Fp>
+    iter_type __do_get_floating_point
+                            (iter_type __b, iter_type __e, ios_base& __iob,
+                             ios_base::iostate& __err, _Fp& __v) const;
+
+    template <class _Signed>
+    iter_type __do_get_signed
+                            (iter_type __b, iter_type __e, ios_base& __iob,
+                             ios_base::iostate& __err, _Signed& __v) const;
+
+    template <class _Unsigned>
+    iter_type __do_get_unsigned
+                            (iter_type __b, iter_type __e, ios_base& __iob,
+                             ios_base::iostate& __err, _Unsigned& __v) const;
+
+
+    virtual iter_type do_get(iter_type __b, iter_type __e, ios_base& __iob,
+                             ios_base::iostate& __err, bool& __v) const;
+
+    virtual iter_type do_get(iter_type __b, iter_type __e, ios_base& __iob,
+                             ios_base::iostate& __err, long& __v) const
+    { return this->__do_get_signed ( __b, __e, __iob, __err, __v ); }
+
+    virtual iter_type do_get(iter_type __b, iter_type __e, ios_base& __iob,
+                             ios_base::iostate& __err, long long& __v) const
+    { return this->__do_get_signed ( __b, __e, __iob, __err, __v ); }
+
+    virtual iter_type do_get(iter_type __b, iter_type __e, ios_base& __iob,
+                             ios_base::iostate& __err, unsigned short& __v) const
+    { return this->__do_get_unsigned ( __b, __e, __iob, __err, __v ); }
+
+    virtual iter_type do_get(iter_type __b, iter_type __e, ios_base& __iob,
+                             ios_base::iostate& __err, unsigned int& __v) const
+    { return this->__do_get_unsigned ( __b, __e, __iob, __err, __v ); }
+
+    virtual iter_type do_get(iter_type __b, iter_type __e, ios_base& __iob,
+                             ios_base::iostate& __err, unsigned long& __v) const
+    { return this->__do_get_unsigned ( __b, __e, __iob, __err, __v ); }
+
+    virtual iter_type do_get(iter_type __b, iter_type __e, ios_base& __iob,
+                             ios_base::iostate& __err, unsigned long long& __v) const
+    { return this->__do_get_unsigned ( __b, __e, __iob, __err, __v ); }
+
+    virtual iter_type do_get(iter_type __b, iter_type __e, ios_base& __iob,
+                             ios_base::iostate& __err, float& __v) const
+    { return this->__do_get_floating_point ( __b, __e, __iob, __err, __v ); }
+
+    virtual iter_type do_get(iter_type __b, iter_type __e, ios_base& __iob,
+                             ios_base::iostate& __err, double& __v) const
+    { return this->__do_get_floating_point ( __b, __e, __iob, __err, __v ); }
+
+    virtual iter_type do_get(iter_type __b, iter_type __e, ios_base& __iob,
+                             ios_base::iostate& __err, long double& __v) const
+    { return this->__do_get_floating_point ( __b, __e, __iob, __err, __v ); }
+
+    virtual iter_type do_get(iter_type __b, iter_type __e, ios_base& __iob,
+                             ios_base::iostate& __err, void*& __v) const;
+};
+
+template <class _CharT, class _InputIterator>
+locale::id
+num_get<_CharT, _InputIterator>::id;
+
+template <class _Tp>
+_Tp
+__num_get_signed_integral(const char* __a, const char* __a_end,
+                          ios_base::iostate& __err, int __base)
+{
+    if (__a != __a_end)
+    {
+        typename remove_reference<decltype(errno)>::type __save_errno = errno;
+        errno = 0;
+        char *__p2;
+        long long __ll = strtoll_l(__a, &__p2, __base, _LIBCPP_GET_C_LOCALE);
+        typename remove_reference<decltype(errno)>::type __current_errno = errno;
+        if (__current_errno == 0)
+            errno = __save_errno;
+        if (__p2 != __a_end)
+        {
+            __err = ios_base::failbit;
+            return 0;
+        }
+        else if (__current_errno == ERANGE         ||
+                 __ll < numeric_limits<_Tp>::min() ||
+                 numeric_limits<_Tp>::max() < __ll)
+        {
+            __err = ios_base::failbit;
+            if (__ll > 0)
+                return numeric_limits<_Tp>::max();
+            else
+                return numeric_limits<_Tp>::min();
+        }
+        return static_cast<_Tp>(__ll);
+    }
+    __err = ios_base::failbit;
+    return 0;
+}
+
+template <class _Tp>
+_Tp
+__num_get_unsigned_integral(const char* __a, const char* __a_end,
+                            ios_base::iostate& __err, int __base)
+{
+    if (__a != __a_end)
+    {
+        if (*__a == '-')
+        {
+            __err = ios_base::failbit;
+            return 0;
+        }
+        typename remove_reference<decltype(errno)>::type __save_errno = errno;
+        errno = 0;
+        char *__p2;
+        unsigned long long __ll = strtoull_l(__a, &__p2, __base, _LIBCPP_GET_C_LOCALE);
+        typename remove_reference<decltype(errno)>::type __current_errno = errno;
+        if (__current_errno == 0)
+            errno = __save_errno;
+        if (__p2 != __a_end)
+        {
+            __err = ios_base::failbit;
+            return 0;
+        }
+        else if (__current_errno == ERANGE ||
+                 numeric_limits<_Tp>::max() < __ll)
+        {
+            __err = ios_base::failbit;
+            return numeric_limits<_Tp>::max();
+        }
+        return static_cast<_Tp>(__ll);
+    }
+    __err = ios_base::failbit;
+    return 0;
+}
+
+template <class _Tp>
+_Tp
+__num_get_float(const char* __a, const char* __a_end, ios_base::iostate& __err)
+{
+    if (__a != __a_end)
+    {
+        typename remove_reference<decltype(errno)>::type __save_errno = errno;
+        errno = 0;
+        char *__p2;
+        long double __ld = strtold_l(__a, &__p2, _LIBCPP_GET_C_LOCALE);
+        typename remove_reference<decltype(errno)>::type __current_errno = errno;
+        if (__current_errno == 0)
+            errno = __save_errno;
+        if (__p2 != __a_end)
+        {
+            __err = ios_base::failbit;
+            return 0;
+        }
+        else if (__current_errno == ERANGE)
+            __err = ios_base::failbit;
+        return static_cast<_Tp>(__ld);
+    }
+    __err = ios_base::failbit;
+    return 0;
+}
+
+template <class _CharT, class _InputIterator>
+_InputIterator
+num_get<_CharT, _InputIterator>::do_get(iter_type __b, iter_type __e,
+                                        ios_base& __iob,
+                                        ios_base::iostate& __err,
+                                        bool& __v) const
+{
+    if ((__iob.flags() & ios_base::boolalpha) == 0)
+    {
+        long __lv = -1;
+        __b = do_get(__b, __e, __iob, __err, __lv);
+        switch (__lv)
+        {
+        case 0:
+            __v = false;
+            break;
+        case 1:
+            __v = true;
+            break;
+        default:
+            __v = true;
+            __err = ios_base::failbit;
+            break;
+        }
+        return __b;
+    }
+    const ctype<_CharT>& __ct = use_facet<ctype<_CharT> >(__iob.getloc());
+    const numpunct<_CharT>& __np = use_facet<numpunct<_CharT> >(__iob.getloc());
+    typedef typename numpunct<_CharT>::string_type string_type;
+    const string_type __names[2] = {__np.truename(), __np.falsename()};
+    const string_type* __i = __scan_keyword(__b, __e, __names, __names+2,
+                                            __ct, __err);
+    __v = __i == __names;
+    return __b;
+}
+
+// signed
+
+template <class _CharT, class _InputIterator>
+template <class _Signed>
+_InputIterator
+num_get<_CharT, _InputIterator>::__do_get_signed(iter_type __b, iter_type __e,
+                                        ios_base& __iob,
+                                        ios_base::iostate& __err,
+                                        _Signed& __v) const
+{
+    // Stage 1
+    int __base = this->__get_base(__iob);
+    // Stage 2
+    char_type __atoms[26];
+    char_type __thousands_sep;
+    string __grouping = this->__stage2_int_prep(__iob, __atoms, __thousands_sep);
+    string __buf;
+    __buf.resize(__buf.capacity());
+    char* __a = &__buf[0];
+    char* __a_end = __a;
+    unsigned __g[__num_get_base::__num_get_buf_sz];
+    unsigned* __g_end = __g;
+    unsigned __dc = 0;
+    for (; __b != __e; ++__b)
+    {
+        if (__a_end == __a + __buf.size())
+        {
+            size_t __tmp = __buf.size();
+            __buf.resize(2*__buf.size());
+            __buf.resize(__buf.capacity());
+            __a = &__buf[0];
+            __a_end = __a + __tmp;
+        }
+        if (this->__stage2_int_loop(*__b, __base, __a, __a_end, __dc,
+                                    __thousands_sep, __grouping, __g, __g_end,
+                                    __atoms))
+            break;
+    }
+    if (__grouping.size() != 0 && __g_end-__g < __num_get_base::__num_get_buf_sz)
+        *__g_end++ = __dc;
+    // Stage 3
+    __v = __num_get_signed_integral<_Signed>(__a, __a_end, __err, __base);
+    // Digit grouping checked
+    __check_grouping(__grouping, __g, __g_end, __err);
+    // EOF checked
+    if (__b == __e)
+        __err |= ios_base::eofbit;
+    return __b;
+}
+
+// unsigned
+
+template <class _CharT, class _InputIterator>
+template <class _Unsigned>
+_InputIterator
+num_get<_CharT, _InputIterator>::__do_get_unsigned(iter_type __b, iter_type __e,
+                                        ios_base& __iob,
+                                        ios_base::iostate& __err,
+                                        _Unsigned& __v) const
+{
+    // Stage 1
+    int __base = this->__get_base(__iob);
+    // Stage 2
+    char_type __atoms[26];
+    char_type __thousands_sep;
+    string __grouping = this->__stage2_int_prep(__iob, __atoms, __thousands_sep);
+    string __buf;
+    __buf.resize(__buf.capacity());
+    char* __a = &__buf[0];
+    char* __a_end = __a;
+    unsigned __g[__num_get_base::__num_get_buf_sz];
+    unsigned* __g_end = __g;
+    unsigned __dc = 0;
+    for (; __b != __e; ++__b)
+    {
+        if (__a_end == __a + __buf.size())
+        {
+            size_t __tmp = __buf.size();
+            __buf.resize(2*__buf.size());
+            __buf.resize(__buf.capacity());
+            __a = &__buf[0];
+            __a_end = __a + __tmp;
+        }
+        if (this->__stage2_int_loop(*__b, __base, __a, __a_end, __dc,
+                                    __thousands_sep, __grouping, __g, __g_end,
+                                    __atoms))
+            break;
+    }
+    if (__grouping.size() != 0 && __g_end-__g < __num_get_base::__num_get_buf_sz)
+        *__g_end++ = __dc;
+    // Stage 3
+    __v = __num_get_unsigned_integral<_Unsigned>(__a, __a_end, __err, __base);
+    // Digit grouping checked
+    __check_grouping(__grouping, __g, __g_end, __err);
+    // EOF checked
+    if (__b == __e)
+        __err |= ios_base::eofbit;
+    return __b;
+}
+
+// floating point
+
+template <class _CharT, class _InputIterator>
+template <class _Fp>
+_InputIterator
+num_get<_CharT, _InputIterator>::__do_get_floating_point(iter_type __b, iter_type __e,
+                                        ios_base& __iob,
+                                        ios_base::iostate& __err,
+                                        _Fp& __v) const
+{
+    // Stage 1, nothing to do
+    // Stage 2
+    char_type __atoms[32];
+    char_type __decimal_point;
+    char_type __thousands_sep;
+    string __grouping = this->__stage2_float_prep(__iob, __atoms,
+                                                  __decimal_point,
+                                                  __thousands_sep);
+    string __buf;
+    __buf.resize(__buf.capacity());
+    char* __a = &__buf[0];
+    char* __a_end = __a;
+    unsigned __g[__num_get_base::__num_get_buf_sz];
+    unsigned* __g_end = __g;
+    unsigned __dc = 0;
+    bool __in_units = true;
+    char __exp = 'E';
+    for (; __b != __e; ++__b)
+    {
+        if (__a_end == __a + __buf.size())
+        {
+            size_t __tmp = __buf.size();
+            __buf.resize(2*__buf.size());
+            __buf.resize(__buf.capacity());
+            __a = &__buf[0];
+            __a_end = __a + __tmp;
+        }
+        if (this->__stage2_float_loop(*__b, __in_units, __exp, __a, __a_end,
+                                      __decimal_point, __thousands_sep,
+                                      __grouping, __g, __g_end,
+                                      __dc, __atoms))
+            break;
+    }
+    if (__grouping.size() != 0 && __in_units && __g_end-__g < __num_get_base::__num_get_buf_sz)
+        *__g_end++ = __dc;
+    // Stage 3
+    __v = __num_get_float<_Fp>(__a, __a_end, __err);
+    // Digit grouping checked
+    __check_grouping(__grouping, __g, __g_end, __err);
+    // EOF checked
+    if (__b == __e)
+        __err |= ios_base::eofbit;
+    return __b;
+}
+
+template <class _CharT, class _InputIterator>
+_InputIterator
+num_get<_CharT, _InputIterator>::do_get(iter_type __b, iter_type __e,
+                                        ios_base& __iob,
+                                        ios_base::iostate& __err,
+                                        void*& __v) const
+{
+    // Stage 1
+    int __base = 16;
+    // Stage 2
+    char_type __atoms[26];
+    char_type __thousands_sep = 0;
+    string __grouping;
+    use_facet<ctype<_CharT> >(__iob.getloc()).widen(__num_get_base::__src,
+                                                    __num_get_base::__src + 26, __atoms);
+    string __buf;
+    __buf.resize(__buf.capacity());
+    char* __a = &__buf[0];
+    char* __a_end = __a;
+    unsigned __g[__num_get_base::__num_get_buf_sz];
+    unsigned* __g_end = __g;
+    unsigned __dc = 0;
+    for (; __b != __e; ++__b)
+    {
+        if (__a_end == __a + __buf.size())
+        {
+            size_t __tmp = __buf.size();
+            __buf.resize(2*__buf.size());
+            __buf.resize(__buf.capacity());
+            __a = &__buf[0];
+            __a_end = __a + __tmp;
+        }
+        if (this->__stage2_int_loop(*__b, __base, __a, __a_end, __dc,
+                                    __thousands_sep, __grouping,
+                                    __g, __g_end, __atoms))
+            break;
+    }
+    // Stage 3
+    __buf.resize(__a_end - __a);
+#ifdef _LIBCPP_LOCALE__L_EXTENSIONS
+    if (sscanf_l(__buf.c_str(), _LIBCPP_GET_C_LOCALE, "%p", &__v) != 1)
+#else
+    if (__sscanf_l(__buf.c_str(), __cloc(), "%p", &__v) != 1)
+#endif
+        __err = ios_base::failbit;
+    // EOF checked
+    if (__b == __e)
+        __err |= ios_base::eofbit;
+    return __b;
+}
+
+_LIBCPP_EXTERN_TEMPLATE2(class _LIBCPP_TYPE_VIS num_get<char>)
+_LIBCPP_EXTERN_TEMPLATE2(class _LIBCPP_TYPE_VIS num_get<wchar_t>)
+
+struct _LIBCPP_TYPE_VIS __num_put_base
+{
+protected:
+    static void __format_int(char* __fmt, const char* __len, bool __signd,
+                             ios_base::fmtflags __flags);
+    static bool __format_float(char* __fmt, const char* __len,
+                               ios_base::fmtflags __flags);
+    static char* __identify_padding(char* __nb, char* __ne,
+                                    const ios_base& __iob);
+};
+
+template <class _CharT>
+struct __num_put
+    : protected __num_put_base
+{
+    static void __widen_and_group_int(char* __nb, char* __np, char* __ne,
+                                      _CharT* __ob, _CharT*& __op, _CharT*& __oe,
+                                      const locale& __loc);
+    static void __widen_and_group_float(char* __nb, char* __np, char* __ne,
+                                        _CharT* __ob, _CharT*& __op, _CharT*& __oe,
+                                        const locale& __loc);
+};
+
+template <class _CharT>
+void
+__num_put<_CharT>::__widen_and_group_int(char* __nb, char* __np, char* __ne,
+                                         _CharT* __ob, _CharT*& __op, _CharT*& __oe,
+                                         const locale& __loc)
+{
+    const ctype<_CharT>&    __ct = use_facet<ctype<_CharT> >   (__loc);
+    const numpunct<_CharT>& __npt = use_facet<numpunct<_CharT> >(__loc);
+    string __grouping = __npt.grouping();
+    if (__grouping.empty())
+    {
+        __ct.widen(__nb, __ne, __ob);
+        __oe = __ob + (__ne - __nb);
+    }
+    else
+    {
+        __oe = __ob;
+        char* __nf = __nb;
+        if (*__nf == '-' || *__nf == '+')
+            *__oe++ = __ct.widen(*__nf++);
+        if (__ne - __nf >= 2 && __nf[0] == '0' && (__nf[1] == 'x' ||
+                                                   __nf[1] == 'X'))
+        {
+            *__oe++ = __ct.widen(*__nf++);
+            *__oe++ = __ct.widen(*__nf++);
+        }
+        reverse(__nf, __ne);
+        _CharT __thousands_sep = __npt.thousands_sep();
+        unsigned __dc = 0;
+        unsigned __dg = 0;
+        for (char* __p = __nf; __p < __ne; ++__p)
+        {
+            if (static_cast<unsigned>(__grouping[__dg]) > 0 &&
+                __dc == static_cast<unsigned>(__grouping[__dg]))
+            {
+                *__oe++ = __thousands_sep;
+                __dc = 0;
+                if (__dg < __grouping.size()-1)
+                    ++__dg;
+            }
+            *__oe++ = __ct.widen(*__p);
+            ++__dc;
+        }
+        reverse(__ob + (__nf - __nb), __oe);
+    }
+    if (__np == __ne)
+        __op = __oe;
+    else
+        __op = __ob + (__np - __nb);
+}
+
+template <class _CharT>
+void
+__num_put<_CharT>::__widen_and_group_float(char* __nb, char* __np, char* __ne,
+                                           _CharT* __ob, _CharT*& __op, _CharT*& __oe,
+                                           const locale& __loc)
+{
+    const ctype<_CharT>&    __ct = use_facet<ctype<_CharT> >   (__loc);
+    const numpunct<_CharT>& __npt = use_facet<numpunct<_CharT> >(__loc);
+    string __grouping = __npt.grouping();
+    __oe = __ob;
+    char* __nf = __nb;
+    if (*__nf == '-' || *__nf == '+')
+        *__oe++ = __ct.widen(*__nf++);
+    char* __ns;
+    if (__ne - __nf >= 2 && __nf[0] == '0' && (__nf[1] == 'x' ||
+                                               __nf[1] == 'X'))
+    {
+        *__oe++ = __ct.widen(*__nf++);
+        *__oe++ = __ct.widen(*__nf++);
+        for (__ns = __nf; __ns < __ne; ++__ns)
+            if (!isxdigit_l(*__ns, _LIBCPP_GET_C_LOCALE))
+                break;
+    }
+    else
+    {
+        for (__ns = __nf; __ns < __ne; ++__ns)
+            if (!isdigit_l(*__ns, _LIBCPP_GET_C_LOCALE))
+                break;
+    }
+    if (__grouping.empty())
+    {
+        __ct.widen(__nf, __ns, __oe);
+        __oe += __ns - __nf;
+    }
+    else
+    {
+        reverse(__nf, __ns);
+        _CharT __thousands_sep = __npt.thousands_sep();
+        unsigned __dc = 0;
+        unsigned __dg = 0;
+        for (char* __p = __nf; __p < __ns; ++__p)
+        {
+            if (__grouping[__dg] > 0 && __dc == static_cast<unsigned>(__grouping[__dg]))
+            {
+                *__oe++ = __thousands_sep;
+                __dc = 0;
+                if (__dg < __grouping.size()-1)
+                    ++__dg;
+            }
+            *__oe++ = __ct.widen(*__p);
+            ++__dc;
+        }
+        reverse(__ob + (__nf - __nb), __oe);
+    }
+    for (__nf = __ns; __nf < __ne; ++__nf)
+    {
+        if (*__nf == '.')
+        {
+            *__oe++ = __npt.decimal_point();
+            ++__nf;
+            break;
+        }
+        else
+            *__oe++ = __ct.widen(*__nf);
+    }
+    __ct.widen(__nf, __ne, __oe);
+    __oe += __ne - __nf;
+    if (__np == __ne)
+        __op = __oe;
+    else
+        __op = __ob + (__np - __nb);
+}
+
+_LIBCPP_EXTERN_TEMPLATE2(struct _LIBCPP_TYPE_VIS __num_put<char>)
+_LIBCPP_EXTERN_TEMPLATE2(struct _LIBCPP_TYPE_VIS __num_put<wchar_t>)
+
+template <class _CharT, class _OutputIterator = ostreambuf_iterator<_CharT> >
+class _LIBCPP_TYPE_VIS_ONLY num_put
+    : public locale::facet,
+      private __num_put<_CharT>
+{
+public:
+    typedef _CharT char_type;
+    typedef _OutputIterator iter_type;
+
+    _LIBCPP_ALWAYS_INLINE
+    explicit num_put(size_t __refs = 0)
+        : locale::facet(__refs) {}
+
+    _LIBCPP_ALWAYS_INLINE
+    iter_type put(iter_type __s, ios_base& __iob, char_type __fl,
+                  bool __v) const
+    {
+        return do_put(__s, __iob, __fl, __v);
+    }
+
+    _LIBCPP_ALWAYS_INLINE
+    iter_type put(iter_type __s, ios_base& __iob, char_type __fl,
+                  long __v) const
+    {
+        return do_put(__s, __iob, __fl, __v);
+    }
+
+    _LIBCPP_ALWAYS_INLINE
+    iter_type put(iter_type __s, ios_base& __iob, char_type __fl,
+                  long long __v) const
+    {
+        return do_put(__s, __iob, __fl, __v);
+    }
+
+    _LIBCPP_ALWAYS_INLINE
+    iter_type put(iter_type __s, ios_base& __iob, char_type __fl,
+                  unsigned long __v) const
+    {
+        return do_put(__s, __iob, __fl, __v);
+    }
+
+    _LIBCPP_ALWAYS_INLINE
+    iter_type put(iter_type __s, ios_base& __iob, char_type __fl,
+                  unsigned long long __v) const
+    {
+        return do_put(__s, __iob, __fl, __v);
+    }
+
+    _LIBCPP_ALWAYS_INLINE
+    iter_type put(iter_type __s, ios_base& __iob, char_type __fl,
+                  double __v) const
+    {
+        return do_put(__s, __iob, __fl, __v);
+    }
+
+    _LIBCPP_ALWAYS_INLINE
+    iter_type put(iter_type __s, ios_base& __iob, char_type __fl,
+                  long double __v) const
+    {
+        return do_put(__s, __iob, __fl, __v);
+    }
+
+    _LIBCPP_ALWAYS_INLINE
+    iter_type put(iter_type __s, ios_base& __iob, char_type __fl,
+                  const void* __v) const
+    {
+        return do_put(__s, __iob, __fl, __v);
+    }
+
+    static locale::id id;
+
+protected:
+    _LIBCPP_ALWAYS_INLINE
+    ~num_put() {}
+
+    virtual iter_type do_put(iter_type __s, ios_base& __iob, char_type __fl,
+                             bool __v) const;
+    virtual iter_type do_put(iter_type __s, ios_base& __iob, char_type __fl,
+                             long __v) const;
+    virtual iter_type do_put(iter_type __s, ios_base& __iob, char_type __fl,
+                             long long __v) const;
+    virtual iter_type do_put(iter_type __s, ios_base& __iob, char_type __fl,
+                             unsigned long) const;
+    virtual iter_type do_put(iter_type __s, ios_base& __iob, char_type __fl,
+                             unsigned long long) const;
+    virtual iter_type do_put(iter_type __s, ios_base& __iob, char_type __fl,
+                             double __v) const;
+    virtual iter_type do_put(iter_type __s, ios_base& __iob, char_type __fl,
+                             long double __v) const;
+    virtual iter_type do_put(iter_type __s, ios_base& __iob, char_type __fl,
+                             const void* __v) const;
+};
+
+template <class _CharT, class _OutputIterator>
+locale::id
+num_put<_CharT, _OutputIterator>::id;
+
+template <class _CharT, class _OutputIterator>
+_LIBCPP_HIDDEN
+_OutputIterator
+__pad_and_output(_OutputIterator __s,
+                 const _CharT* __ob, const _CharT* __op, const _CharT* __oe,
+                 ios_base& __iob, _CharT __fl)
+{
+    streamsize __sz = __oe - __ob;
+    streamsize __ns = __iob.width();
+    if (__ns > __sz)
+        __ns -= __sz;
+    else
+        __ns = 0;
+    for (;__ob < __op; ++__ob, ++__s)
+        *__s = *__ob;
+    for (; __ns; --__ns, ++__s)
+        *__s = __fl;
+    for (; __ob < __oe; ++__ob, ++__s)
+        *__s = *__ob;
+    __iob.width(0);
+    return __s;
+}
+
+#if !defined(__APPLE__) || \
+    (defined(__MAC_OS_X_VERSION_MIN_REQUIRED) && __MAC_OS_X_VERSION_MIN_REQUIRED > __MAC_10_8) || \
+    (defined(__IPHONE_OS_VERSION_MIN_REQUIRED) && __IPHONE_OS_VERSION_MIN_REQUIRED > __IPHONE_6_0)
+
+template <class _CharT, class _Traits>
+_LIBCPP_HIDDEN
+ostreambuf_iterator<_CharT, _Traits>
+__pad_and_output(ostreambuf_iterator<_CharT, _Traits> __s,
+                 const _CharT* __ob, const _CharT* __op, const _CharT* __oe,
+                 ios_base& __iob, _CharT __fl)
+{
+    if (__s.__sbuf_ == nullptr)
+        return __s;
+    streamsize __sz = __oe - __ob;
+    streamsize __ns = __iob.width();
+    if (__ns > __sz)
+        __ns -= __sz;
+    else
+        __ns = 0;
+    streamsize __np = __op - __ob;
+    if (__np > 0)
+    {
+        if (__s.__sbuf_->sputn(__ob, __np) != __np)
+        {
+            __s.__sbuf_ = nullptr;
+            return __s;
+        }
+    }
+    if (__ns > 0)
+    {
+        basic_string<_CharT, _Traits> __sp(__ns, __fl);
+        if (__s.__sbuf_->sputn(__sp.data(), __ns) != __ns)
+        {
+            __s.__sbuf_ = nullptr;
+            return __s;
+        }
+    }
+    __np = __oe - __op;
+    if (__np > 0)
+    {
+        if (__s.__sbuf_->sputn(__op, __np) != __np)
+        {
+            __s.__sbuf_ = nullptr;
+            return __s;
+        }
+    }
+    __iob.width(0);
+    return __s;
+}
+
+#endif
+
+template <class _CharT, class _OutputIterator>
+_OutputIterator
+num_put<_CharT, _OutputIterator>::do_put(iter_type __s, ios_base& __iob,
+                                         char_type __fl, bool __v) const
+{
+    if ((__iob.flags() & ios_base::boolalpha) == 0)
+        return do_put(__s, __iob, __fl, (unsigned long)__v);
+    const numpunct<char_type>& __np = use_facet<numpunct<char_type> >(__iob.getloc());
+    typedef typename numpunct<char_type>::string_type string_type;
+#if _LIBCPP_DEBUG_LEVEL >= 2
+    string_type __tmp(__v ? __np.truename() : __np.falsename());
+    string_type __nm = _VSTD::move(__tmp);
+#else
+    string_type __nm = __v ? __np.truename() : __np.falsename();
+#endif
+    for (typename string_type::iterator __i = __nm.begin(); __i != __nm.end(); ++__i, ++__s)
+        *__s = *__i;
+    return __s;
+}
+
+template <class _CharT, class _OutputIterator>
+_OutputIterator
+num_put<_CharT, _OutputIterator>::do_put(iter_type __s, ios_base& __iob,
+                                         char_type __fl, long __v) const
+{
+    // Stage 1 - Get number in narrow char
+    char __fmt[6] = {'%', 0};
+    const char* __len = "l";
+    this->__format_int(__fmt+1, __len, true, __iob.flags());
+    const unsigned __nbuf = (numeric_limits<long>::digits / 3)
+                          + ((numeric_limits<long>::digits % 3) != 0)
+                          + 1;
+    char __nar[__nbuf];
+#ifdef _LIBCPP_LOCALE__L_EXTENSIONS
+    int __nc = snprintf_l(__nar, sizeof(__nar), _LIBCPP_GET_C_LOCALE, __fmt, __v);
+#else
+    int __nc = __snprintf_l(__nar, sizeof(__nar), __cloc(), __fmt, __v);
+#endif
+    char* __ne = __nar + __nc;
+    char* __np = this->__identify_padding(__nar, __ne, __iob);
+    // Stage 2 - Widen __nar while adding thousands separators
+    char_type __o[2*(__nbuf-1) - 1];
+    char_type* __op;  // pad here
+    char_type* __oe;  // end of output
+    this->__widen_and_group_int(__nar, __np, __ne, __o, __op, __oe, __iob.getloc());
+    // [__o, __oe) contains thousands_sep'd wide number
+    // Stage 3 & 4
+    return __pad_and_output(__s, __o, __op, __oe, __iob, __fl);
+}
+
+template <class _CharT, class _OutputIterator>
+_OutputIterator
+num_put<_CharT, _OutputIterator>::do_put(iter_type __s, ios_base& __iob,
+                                         char_type __fl, long long __v) const
+{
+    // Stage 1 - Get number in narrow char
+    char __fmt[8] = {'%', 0};
+    const char* __len = "ll";
+    this->__format_int(__fmt+1, __len, true, __iob.flags());
+    const unsigned __nbuf = (numeric_limits<long long>::digits / 3)
+                          + ((numeric_limits<long long>::digits % 3) != 0)
+                          + 2;
+    char __nar[__nbuf];
+#ifdef _LIBCPP_LOCALE__L_EXTENSIONS
+    int __nc = snprintf_l(__nar, sizeof(__nar), _LIBCPP_GET_C_LOCALE, __fmt, __v);
+#else
+    int __nc = __snprintf_l(__nar, sizeof(__nar), __cloc(), __fmt, __v);
+#endif
+    char* __ne = __nar + __nc;
+    char* __np = this->__identify_padding(__nar, __ne, __iob);
+    // Stage 2 - Widen __nar while adding thousands separators
+    char_type __o[2*(__nbuf-1) - 1];
+    char_type* __op;  // pad here
+    char_type* __oe;  // end of output
+    this->__widen_and_group_int(__nar, __np, __ne, __o, __op, __oe, __iob.getloc());
+    // [__o, __oe) contains thousands_sep'd wide number
+    // Stage 3 & 4
+    return __pad_and_output(__s, __o, __op, __oe, __iob, __fl);
+}
+
+template <class _CharT, class _OutputIterator>
+_OutputIterator
+num_put<_CharT, _OutputIterator>::do_put(iter_type __s, ios_base& __iob,
+                                         char_type __fl, unsigned long __v) const
+{
+    // Stage 1 - Get number in narrow char
+    char __fmt[6] = {'%', 0};
+    const char* __len = "l";
+    this->__format_int(__fmt+1, __len, false, __iob.flags());
+    const unsigned __nbuf = (numeric_limits<unsigned long>::digits / 3)
+                          + ((numeric_limits<unsigned long>::digits % 3) != 0)
+                          + 1;
+    char __nar[__nbuf];
+#ifdef _LIBCPP_LOCALE__L_EXTENSIONS
+    int __nc = snprintf_l(__nar, sizeof(__nar), _LIBCPP_GET_C_LOCALE, __fmt, __v);
+#else
+    int __nc = __snprintf_l(__nar, sizeof(__nar), __cloc(), __fmt, __v);
+#endif
+    char* __ne = __nar + __nc;
+    char* __np = this->__identify_padding(__nar, __ne, __iob);
+    // Stage 2 - Widen __nar while adding thousands separators
+    char_type __o[2*(__nbuf-1) - 1];
+    char_type* __op;  // pad here
+    char_type* __oe;  // end of output
+    this->__widen_and_group_int(__nar, __np, __ne, __o, __op, __oe, __iob.getloc());
+    // [__o, __oe) contains thousands_sep'd wide number
+    // Stage 3 & 4
+    return __pad_and_output(__s, __o, __op, __oe, __iob, __fl);
+}
+
+template <class _CharT, class _OutputIterator>
+_OutputIterator
+num_put<_CharT, _OutputIterator>::do_put(iter_type __s, ios_base& __iob,
+                                         char_type __fl, unsigned long long __v) const
+{
+    // Stage 1 - Get number in narrow char
+    char __fmt[8] = {'%', 0};
+    const char* __len = "ll";
+    this->__format_int(__fmt+1, __len, false, __iob.flags());
+    const unsigned __nbuf = (numeric_limits<unsigned long long>::digits / 3)
+                          + ((numeric_limits<unsigned long long>::digits % 3) != 0)
+                          + 1;
+    char __nar[__nbuf];
+#ifdef _LIBCPP_LOCALE__L_EXTENSIONS
+    int __nc = snprintf_l(__nar, sizeof(__nar), _LIBCPP_GET_C_LOCALE, __fmt, __v);
+#else
+    int __nc = __snprintf_l(__nar, sizeof(__nar), __cloc(), __fmt, __v);
+#endif
+    char* __ne = __nar + __nc;
+    char* __np = this->__identify_padding(__nar, __ne, __iob);
+    // Stage 2 - Widen __nar while adding thousands separators
+    char_type __o[2*(__nbuf-1) - 1];
+    char_type* __op;  // pad here
+    char_type* __oe;  // end of output
+    this->__widen_and_group_int(__nar, __np, __ne, __o, __op, __oe, __iob.getloc());
+    // [__o, __oe) contains thousands_sep'd wide number
+    // Stage 3 & 4
+    return __pad_and_output(__s, __o, __op, __oe, __iob, __fl);
+}
+
+template <class _CharT, class _OutputIterator>
+_OutputIterator
+num_put<_CharT, _OutputIterator>::do_put(iter_type __s, ios_base& __iob,
+                                         char_type __fl, double __v) const
+{
+    // Stage 1 - Get number in narrow char
+    char __fmt[8] = {'%', 0};
+    const char* __len = "";
+    bool __specify_precision = this->__format_float(__fmt+1, __len, __iob.flags());
+    const unsigned __nbuf = 30;
+    char __nar[__nbuf];
+    char* __nb = __nar;
+    int __nc;
+    if (__specify_precision)
+#ifdef _LIBCPP_LOCALE__L_EXTENSIONS
+        __nc = snprintf_l(__nb, __nbuf, _LIBCPP_GET_C_LOCALE, __fmt,
+                                   (int)__iob.precision(), __v);
+#else
+        __nc = __snprintf_l(__nb, __nbuf, __cloc(), __fmt,
+                            (int)__iob.precision(), __v);
+#endif
+    else
+#ifdef _LIBCPP_LOCALE__L_EXTENSIONS
+        __nc = snprintf_l(__nb, __nbuf, _LIBCPP_GET_C_LOCALE, __fmt, __v);
+#else
+        __nc = __snprintf_l(__nb, __nbuf, __cloc(), __fmt, __v);
+#endif
+    unique_ptr<char, void(*)(void*)> __nbh(0, free);
+    if (__nc > static_cast<int>(__nbuf-1))
+    {
+        if (__specify_precision)
+#ifdef _LIBCPP_LOCALE__L_EXTENSIONS
+            __nc = asprintf_l(&__nb, _LIBCPP_GET_C_LOCALE, __fmt, (int)__iob.precision(), __v);
+#else
+            __nc = __asprintf_l(&__nb, __cloc(), __fmt,
+                              (int)__iob.precision(), __v);
+#endif
+        else
+#ifdef _LIBCPP_LOCALE__L_EXTENSIONS
+            __nc = asprintf_l(&__nb, _LIBCPP_GET_C_LOCALE, __fmt, __v);
+#else
+            __nc = __asprintf_l(&__nb, __cloc(), __fmt, (int)__iob.precision(), __v);
+#endif
+        if (__nb == 0)
+            __throw_bad_alloc();
+        __nbh.reset(__nb);
+    }
+    char* __ne = __nb + __nc;
+    char* __np = this->__identify_padding(__nb, __ne, __iob);
+    // Stage 2 - Widen __nar while adding thousands separators
+    char_type __o[2*(__nbuf-1) - 1];
+    char_type* __ob = __o;
+    unique_ptr<char_type, void(*)(void*)> __obh(0, free);
+    if (__nb != __nar)
+    {
+        __ob = (char_type*)malloc(2*static_cast<size_t>(__nc)*sizeof(char_type));
+        if (__ob == 0)
+            __throw_bad_alloc();
+        __obh.reset(__ob);
+    }
+    char_type* __op;  // pad here
+    char_type* __oe;  // end of output
+    this->__widen_and_group_float(__nb, __np, __ne, __ob, __op, __oe, __iob.getloc());
+    // [__o, __oe) contains thousands_sep'd wide number
+    // Stage 3 & 4
+    __s = __pad_and_output(__s, __ob, __op, __oe, __iob, __fl);
+    return __s;
+}
+
+template <class _CharT, class _OutputIterator>
+_OutputIterator
+num_put<_CharT, _OutputIterator>::do_put(iter_type __s, ios_base& __iob,
+                                         char_type __fl, long double __v) const
+{
+    // Stage 1 - Get number in narrow char
+    char __fmt[8] = {'%', 0};
+    const char* __len = "L";
+    bool __specify_precision = this->__format_float(__fmt+1, __len, __iob.flags());
+    const unsigned __nbuf = 30;
+    char __nar[__nbuf];
+    char* __nb = __nar;
+    int __nc;
+    if (__specify_precision)
+#ifdef _LIBCPP_LOCALE__L_EXTENSIONS
+        __nc = snprintf_l(__nb, __nbuf, _LIBCPP_GET_C_LOCALE, __fmt,
+                                   (int)__iob.precision(), __v);
+#else
+        __nc = __snprintf_l(__nb, __nbuf, __cloc(), __fmt,
+                            (int)__iob.precision(), __v);
+#endif
+    else
+#ifdef _LIBCPP_LOCALE__L_EXTENSIONS
+        __nc = snprintf_l(__nb, __nbuf, _LIBCPP_GET_C_LOCALE, __fmt, __v);
+#else
+        __nc = __snprintf_l(__nb, __nbuf, __cloc(), __fmt, __v);
+#endif
+    unique_ptr<char, void(*)(void*)> __nbh(0, free);
+    if (__nc > static_cast<int>(__nbuf-1))
+    {
+        if (__specify_precision)
+#ifdef _LIBCPP_LOCALE__L_EXTENSIONS
+            __nc = asprintf_l(&__nb, _LIBCPP_GET_C_LOCALE, __fmt, (int)__iob.precision(), __v);
+#else
+            __nc = __asprintf_l(&__nb, __cloc(), __fmt,
+                              (int)__iob.precision(), __v);
+#endif
+        else
+#ifdef _LIBCPP_LOCALE__L_EXTENSIONS
+            __nc = asprintf_l(&__nb, _LIBCPP_GET_C_LOCALE, __fmt, __v);
+#else
+            __nc = __asprintf_l(&__nb, __cloc(), __fmt, __v);
+#endif
+        if (__nb == 0)
+            __throw_bad_alloc();
+        __nbh.reset(__nb);
+    }
+    char* __ne = __nb + __nc;
+    char* __np = this->__identify_padding(__nb, __ne, __iob);
+    // Stage 2 - Widen __nar while adding thousands separators
+    char_type __o[2*(__nbuf-1) - 1];
+    char_type* __ob = __o;
+    unique_ptr<char_type, void(*)(void*)> __obh(0, free);
+    if (__nb != __nar)
+    {
+        __ob = (char_type*)malloc(2*static_cast<size_t>(__nc)*sizeof(char_type));
+        if (__ob == 0)
+            __throw_bad_alloc();
+        __obh.reset(__ob);
+    }
+    char_type* __op;  // pad here
+    char_type* __oe;  // end of output
+    this->__widen_and_group_float(__nb, __np, __ne, __ob, __op, __oe, __iob.getloc());
+    // [__o, __oe) contains thousands_sep'd wide number
+    // Stage 3 & 4
+    __s = __pad_and_output(__s, __ob, __op, __oe, __iob, __fl);
+    return __s;
+}
+
+template <class _CharT, class _OutputIterator>
+_OutputIterator
+num_put<_CharT, _OutputIterator>::do_put(iter_type __s, ios_base& __iob,
+                                         char_type __fl, const void* __v) const
+{
+    // Stage 1 - Get pointer in narrow char
+    char __fmt[6] = "%p";
+    const unsigned __nbuf = 20;
+    char __nar[__nbuf];
+#ifdef _LIBCPP_LOCALE__L_EXTENSIONS
+    int __nc = snprintf_l(__nar, sizeof(__nar), _LIBCPP_GET_C_LOCALE, __fmt, __v);
+#else
+    int __nc = __snprintf_l(__nar, sizeof(__nar), __cloc(), __fmt, __v);
+#endif
+    char* __ne = __nar + __nc;
+    char* __np = this->__identify_padding(__nar, __ne, __iob);
+    // Stage 2 - Widen __nar
+    char_type __o[2*(__nbuf-1) - 1];
+    char_type* __op;  // pad here
+    char_type* __oe;  // end of output
+    const ctype<char_type>& __ct = use_facet<ctype<char_type> >(__iob.getloc());
+    __ct.widen(__nar, __ne, __o);
+    __oe = __o + (__ne - __nar);
+    if (__np == __ne)
+        __op = __oe;
+    else
+        __op = __o + (__np - __nar);
+    // [__o, __oe) contains wide number
+    // Stage 3 & 4
+    return __pad_and_output(__s, __o, __op, __oe, __iob, __fl);
+}
+
+_LIBCPP_EXTERN_TEMPLATE2(class _LIBCPP_TYPE_VIS num_put<char>)
+_LIBCPP_EXTERN_TEMPLATE2(class _LIBCPP_TYPE_VIS num_put<wchar_t>)
+
+template <class _CharT, class _InputIterator>
+_LIBCPP_HIDDEN
+int
+__get_up_to_n_digits(_InputIterator& __b, _InputIterator __e,
+                     ios_base::iostate& __err, const ctype<_CharT>& __ct, int __n)
+{
+    // Precondition:  __n >= 1
+    if (__b == __e)
+    {
+        __err |= ios_base::eofbit | ios_base::failbit;
+        return 0;
+    }
+    // get first digit
+    _CharT __c = *__b;
+    if (!__ct.is(ctype_base::digit, __c))
+    {
+        __err |= ios_base::failbit;
+        return 0;
+    }
+    int __r = __ct.narrow(__c, 0) - '0';
+    for (++__b, (void) --__n; __b != __e && __n > 0; ++__b, (void) --__n)
+    {
+        // get next digit
+        __c = *__b;
+        if (!__ct.is(ctype_base::digit, __c))
+            return __r;
+        __r = __r * 10 + __ct.narrow(__c, 0) - '0';
+    }
+    if (__b == __e)
+        __err |= ios_base::eofbit;
+    return __r;
+}
+
+class _LIBCPP_TYPE_VIS time_base
+{
+public:
+    enum dateorder {no_order, dmy, mdy, ymd, ydm};
+};
+
+template <class _CharT>
+class _LIBCPP_TYPE_VIS_ONLY __time_get_c_storage
+{
+protected:
+    typedef basic_string<_CharT> string_type;
+
+    virtual const string_type* __weeks() const;
+    virtual const string_type* __months() const;
+    virtual const string_type* __am_pm() const;
+    virtual const string_type& __c() const;
+    virtual const string_type& __r() const;
+    virtual const string_type& __x() const;
+    virtual const string_type& __X() const;
+};
+
+template <class _CharT, class _InputIterator = istreambuf_iterator<_CharT> >
+class _LIBCPP_TYPE_VIS_ONLY time_get
+    : public locale::facet,
+      public time_base,
+      private __time_get_c_storage<_CharT>
+{
+public:
+    typedef _CharT                  char_type;
+    typedef _InputIterator          iter_type;
+    typedef time_base::dateorder    dateorder;
+    typedef basic_string<char_type> string_type;
+
+    _LIBCPP_ALWAYS_INLINE
+    explicit time_get(size_t __refs = 0)
+        : locale::facet(__refs) {}
+
+    _LIBCPP_ALWAYS_INLINE
+    dateorder date_order() const
+    {
+        return this->do_date_order();
+    }
+
+    _LIBCPP_ALWAYS_INLINE
+    iter_type get_time(iter_type __b, iter_type __e, ios_base& __iob,
+                       ios_base::iostate& __err, tm* __tm) const
+    {
+        return do_get_time(__b, __e, __iob, __err, __tm);
+    }
+
+    _LIBCPP_ALWAYS_INLINE
+    iter_type get_date(iter_type __b, iter_type __e, ios_base& __iob,
+                       ios_base::iostate& __err, tm* __tm) const
+    {
+        return do_get_date(__b, __e, __iob, __err, __tm);
+    }
+
+    _LIBCPP_ALWAYS_INLINE
+    iter_type get_weekday(iter_type __b, iter_type __e, ios_base& __iob,
+                          ios_base::iostate& __err, tm* __tm) const
+    {
+        return do_get_weekday(__b, __e, __iob, __err, __tm);
+    }
+
+    _LIBCPP_ALWAYS_INLINE
+    iter_type get_monthname(iter_type __b, iter_type __e, ios_base& __iob,
+                            ios_base::iostate& __err, tm* __tm) const
+    {
+        return do_get_monthname(__b, __e, __iob, __err, __tm);
+    }
+
+    _LIBCPP_ALWAYS_INLINE
+    iter_type get_year(iter_type __b, iter_type __e, ios_base& __iob,
+                       ios_base::iostate& __err, tm* __tm) const
+    {
+        return do_get_year(__b, __e, __iob, __err, __tm);
+    }
+
+    _LIBCPP_ALWAYS_INLINE
+    iter_type get(iter_type __b, iter_type __e, ios_base& __iob,
+                  ios_base::iostate& __err, tm *__tm,
+                  char __fmt, char __mod = 0) const
+    {
+        return do_get(__b, __e, __iob, __err, __tm, __fmt, __mod);
+    }
+
+    iter_type get(iter_type __b, iter_type __e, ios_base& __iob,
+                  ios_base::iostate& __err, tm* __tm,
+                  const char_type* __fmtb, const char_type* __fmte) const;
+
+    static locale::id id;
+
+protected:
+    _LIBCPP_ALWAYS_INLINE
+    ~time_get() {}
+
+    virtual dateorder do_date_order() const;
+    virtual iter_type do_get_time(iter_type __b, iter_type __e, ios_base& __iob,
+                                  ios_base::iostate& __err, tm* __tm) const;
+    virtual iter_type do_get_date(iter_type __b, iter_type __e, ios_base& __iob,
+                                  ios_base::iostate& __err, tm* __tm) const;
+    virtual iter_type do_get_weekday(iter_type __b, iter_type __e, ios_base& __iob,
+                                     ios_base::iostate& __err, tm* __tm) const;
+    virtual iter_type do_get_monthname(iter_type __b, iter_type __e, ios_base& __iob,
+                                       ios_base::iostate& __err, tm* __tm) const;
+    virtual iter_type do_get_year(iter_type __b, iter_type __e, ios_base& __iob,
+                                  ios_base::iostate& __err, tm* __tm) const;
+    virtual iter_type do_get(iter_type __b, iter_type __e, ios_base& __iob,
+                             ios_base::iostate& __err, tm* __tm,
+                             char __fmt, char __mod) const;
+private:
+    void __get_white_space(iter_type& __b, iter_type __e,
+                           ios_base::iostate& __err, const ctype<char_type>& __ct) const;
+    void __get_percent(iter_type& __b, iter_type __e, ios_base::iostate& __err,
+                       const ctype<char_type>& __ct) const;
+
+    void __get_weekdayname(int& __m,
+                           iter_type& __b, iter_type __e,
+                           ios_base::iostate& __err,
+                           const ctype<char_type>& __ct) const;
+    void __get_monthname(int& __m,
+                         iter_type& __b, iter_type __e,
+                         ios_base::iostate& __err,
+                         const ctype<char_type>& __ct) const;
+    void __get_day(int& __d,
+                   iter_type& __b, iter_type __e,
+                   ios_base::iostate& __err,
+                   const ctype<char_type>& __ct) const;
+    void __get_month(int& __m,
+                     iter_type& __b, iter_type __e,
+                     ios_base::iostate& __err,
+                     const ctype<char_type>& __ct) const;
+    void __get_year(int& __y,
+                   iter_type& __b, iter_type __e,
+                   ios_base::iostate& __err,
+                   const ctype<char_type>& __ct) const;
+    void __get_year4(int& __y,
+                    iter_type& __b, iter_type __e,
+                    ios_base::iostate& __err,
+                    const ctype<char_type>& __ct) const;
+    void __get_hour(int& __d,
+                    iter_type& __b, iter_type __e,
+                    ios_base::iostate& __err,
+                    const ctype<char_type>& __ct) const;
+    void __get_12_hour(int& __h,
+                       iter_type& __b, iter_type __e,
+                       ios_base::iostate& __err,
+                       const ctype<char_type>& __ct) const;
+    void __get_am_pm(int& __h,
+                     iter_type& __b, iter_type __e,
+                     ios_base::iostate& __err,
+                     const ctype<char_type>& __ct) const;
+    void __get_minute(int& __m,
+                      iter_type& __b, iter_type __e,
+                      ios_base::iostate& __err,
+                      const ctype<char_type>& __ct) const;
+    void __get_second(int& __s,
+                      iter_type& __b, iter_type __e,
+                      ios_base::iostate& __err,
+                      const ctype<char_type>& __ct) const;
+    void __get_weekday(int& __w,
+                       iter_type& __b, iter_type __e,
+                       ios_base::iostate& __err,
+                       const ctype<char_type>& __ct) const;
+    void __get_day_year_num(int& __w,
+                            iter_type& __b, iter_type __e,
+                            ios_base::iostate& __err,
+                            const ctype<char_type>& __ct) const;
+};
+
+template <class _CharT, class _InputIterator>
+locale::id
+time_get<_CharT, _InputIterator>::id;
+
+// time_get primitives
+
+template <class _CharT, class _InputIterator>
+void
+time_get<_CharT, _InputIterator>::__get_weekdayname(int& __w,
+                                                    iter_type& __b, iter_type __e,
+                                                    ios_base::iostate& __err,
+                                                    const ctype<char_type>& __ct) const
+{
+    // Note:  ignoring case comes from the POSIX strptime spec
+    const string_type* __wk = this->__weeks();
+    ptrdiff_t __i = __scan_keyword(__b, __e, __wk, __wk+14, __ct, __err, false) - __wk;
+    if (__i < 14)
+        __w = __i % 7;
+}
+
+template <class _CharT, class _InputIterator>
+void
+time_get<_CharT, _InputIterator>::__get_monthname(int& __m,
+                                                  iter_type& __b, iter_type __e,
+                                                  ios_base::iostate& __err,
+                                                  const ctype<char_type>& __ct) const
+{
+    // Note:  ignoring case comes from the POSIX strptime spec
+    const string_type* __month = this->__months();
+    ptrdiff_t __i = __scan_keyword(__b, __e, __month, __month+24, __ct, __err, false) - __month;
+    if (__i < 24)
+        __m = __i % 12;
+}
+
+template <class _CharT, class _InputIterator>
+void
+time_get<_CharT, _InputIterator>::__get_day(int& __d,
+                                            iter_type& __b, iter_type __e,
+                                            ios_base::iostate& __err,
+                                            const ctype<char_type>& __ct) const
+{
+    int __t = __get_up_to_n_digits(__b, __e, __err, __ct, 2);
+    if (!(__err & ios_base::failbit) && 1 <= __t && __t <= 31)
+        __d = __t;
+    else
+        __err |= ios_base::failbit;
+}
+
+template <class _CharT, class _InputIterator>
+void
+time_get<_CharT, _InputIterator>::__get_month(int& __m,
+                                              iter_type& __b, iter_type __e,
+                                              ios_base::iostate& __err,
+                                              const ctype<char_type>& __ct) const
+{
+    int __t = __get_up_to_n_digits(__b, __e, __err, __ct, 2) - 1;
+    if (!(__err & ios_base::failbit) && __t <= 11)
+        __m = __t;
+    else
+        __err |= ios_base::failbit;
+}
+
+template <class _CharT, class _InputIterator>
+void
+time_get<_CharT, _InputIterator>::__get_year(int& __y,
+                                             iter_type& __b, iter_type __e,
+                                             ios_base::iostate& __err,
+                                             const ctype<char_type>& __ct) const
+{
+    int __t = __get_up_to_n_digits(__b, __e, __err, __ct, 4);
+    if (!(__err & ios_base::failbit))
+    {
+        if (__t < 69)
+            __t += 2000;
+        else if (69 <= __t && __t <= 99)
+            __t += 1900;
+        __y = __t - 1900;
+    }
+}
+
+template <class _CharT, class _InputIterator>
+void
+time_get<_CharT, _InputIterator>::__get_year4(int& __y,
+                                              iter_type& __b, iter_type __e,
+                                              ios_base::iostate& __err,
+                                              const ctype<char_type>& __ct) const
+{
+    int __t = __get_up_to_n_digits(__b, __e, __err, __ct, 4);
+    if (!(__err & ios_base::failbit))
+        __y = __t - 1900;
+}
+
+template <class _CharT, class _InputIterator>
+void
+time_get<_CharT, _InputIterator>::__get_hour(int& __h,
+                                             iter_type& __b, iter_type __e,
+                                             ios_base::iostate& __err,
+                                             const ctype<char_type>& __ct) const
+{
+    int __t = __get_up_to_n_digits(__b, __e, __err, __ct, 2);
+    if (!(__err & ios_base::failbit) && __t <= 23)
+        __h = __t;
+    else
+        __err |= ios_base::failbit;
+}
+
+template <class _CharT, class _InputIterator>
+void
+time_get<_CharT, _InputIterator>::__get_12_hour(int& __h,
+                                                iter_type& __b, iter_type __e,
+                                                ios_base::iostate& __err,
+                                                const ctype<char_type>& __ct) const
+{
+    int __t = __get_up_to_n_digits(__b, __e, __err, __ct, 2);
+    if (!(__err & ios_base::failbit) && 1 <= __t && __t <= 12)
+        __h = __t;
+    else
+        __err |= ios_base::failbit;
+}
+
+template <class _CharT, class _InputIterator>
+void
+time_get<_CharT, _InputIterator>::__get_minute(int& __m,
+                                               iter_type& __b, iter_type __e,
+                                               ios_base::iostate& __err,
+                                               const ctype<char_type>& __ct) const
+{
+    int __t = __get_up_to_n_digits(__b, __e, __err, __ct, 2);
+    if (!(__err & ios_base::failbit) && __t <= 59)
+        __m = __t;
+    else
+        __err |= ios_base::failbit;
+}
+
+template <class _CharT, class _InputIterator>
+void
+time_get<_CharT, _InputIterator>::__get_second(int& __s,
+                                               iter_type& __b, iter_type __e,
+                                               ios_base::iostate& __err,
+                                               const ctype<char_type>& __ct) const
+{
+    int __t = __get_up_to_n_digits(__b, __e, __err, __ct, 2);
+    if (!(__err & ios_base::failbit) && __t <= 60)
+        __s = __t;
+    else
+        __err |= ios_base::failbit;
+}
+
+template <class _CharT, class _InputIterator>
+void
+time_get<_CharT, _InputIterator>::__get_weekday(int& __w,
+                                                iter_type& __b, iter_type __e,
+                                                ios_base::iostate& __err,
+                                                const ctype<char_type>& __ct) const
+{
+    int __t = __get_up_to_n_digits(__b, __e, __err, __ct, 1);
+    if (!(__err & ios_base::failbit) && __t <= 6)
+        __w = __t;
+    else
+        __err |= ios_base::failbit;
+}
+
+template <class _CharT, class _InputIterator>
+void
+time_get<_CharT, _InputIterator>::__get_day_year_num(int& __d,
+                                                     iter_type& __b, iter_type __e,
+                                                     ios_base::iostate& __err,
+                                                     const ctype<char_type>& __ct) const
+{
+    int __t = __get_up_to_n_digits(__b, __e, __err, __ct, 3);
+    if (!(__err & ios_base::failbit) && __t <= 365)
+        __d = __t;
+    else
+        __err |= ios_base::failbit;
+}
+
+template <class _CharT, class _InputIterator>
+void
+time_get<_CharT, _InputIterator>::__get_white_space(iter_type& __b, iter_type __e,
+                                                    ios_base::iostate& __err,
+                                                    const ctype<char_type>& __ct) const
+{
+    for (; __b != __e && __ct.is(ctype_base::space, *__b); ++__b)
+        ;
+    if (__b == __e)
+        __err |= ios_base::eofbit;
+}
+
+template <class _CharT, class _InputIterator>
+void
+time_get<_CharT, _InputIterator>::__get_am_pm(int& __h,
+                                              iter_type& __b, iter_type __e,
+                                              ios_base::iostate& __err,
+                                              const ctype<char_type>& __ct) const
+{
+    const string_type* __ap = this->__am_pm();
+    if (__ap[0].size() + __ap[1].size() == 0)
+    {
+        __err |= ios_base::failbit;
+        return;
+    }
+    ptrdiff_t __i = __scan_keyword(__b, __e, __ap, __ap+2, __ct, __err, false) - __ap;
+    if (__i == 0 && __h == 12)
+        __h = 0;
+    else if (__i == 1 && __h < 12)
+        __h += 12;
+}
+
+template <class _CharT, class _InputIterator>
+void
+time_get<_CharT, _InputIterator>::__get_percent(iter_type& __b, iter_type __e,
+                                                ios_base::iostate& __err,
+                                                const ctype<char_type>& __ct) const
+{
+    if (__b == __e)
+    {
+        __err |= ios_base::eofbit | ios_base::failbit;
+        return;
+    }
+    if (__ct.narrow(*__b, 0) != '%')
+        __err |= ios_base::failbit;
+    else if(++__b == __e)
+        __err |= ios_base::eofbit;
+}
+
+// time_get end primitives
+
+template <class _CharT, class _InputIterator>
+_InputIterator
+time_get<_CharT, _InputIterator>::get(iter_type __b, iter_type __e,
+                                      ios_base& __iob,
+                                      ios_base::iostate& __err, tm* __tm,
+                                      const char_type* __fmtb, const char_type* __fmte) const
+{
+    const ctype<char_type>& __ct = use_facet<ctype<char_type> >(__iob.getloc());
+    __err = ios_base::goodbit;
+    while (__fmtb != __fmte && __err == ios_base::goodbit)
+    {
+        if (__b == __e)
+        {
+            __err = ios_base::failbit;
+            break;
+        }
+        if (__ct.narrow(*__fmtb, 0) == '%')
+        {
+            if (++__fmtb == __fmte)
+            {
+                __err = ios_base::failbit;
+                break;
+            }
+            char __cmd = __ct.narrow(*__fmtb, 0);
+            char __opt = '\0';
+            if (__cmd == 'E' || __cmd == '0')
+            {
+                if (++__fmtb == __fmte)
+                {
+                    __err = ios_base::failbit;
+                    break;
+                }
+                __opt = __cmd;
+                __cmd = __ct.narrow(*__fmtb, 0);
+            }
+            __b = do_get(__b, __e, __iob, __err, __tm, __cmd, __opt);
+            ++__fmtb;
+        }
+        else if (__ct.is(ctype_base::space, *__fmtb))
+        {
+            for (++__fmtb; __fmtb != __fmte && __ct.is(ctype_base::space, *__fmtb); ++__fmtb)
+                ;
+            for (        ;    __b != __e    && __ct.is(ctype_base::space, *__b);    ++__b)
+                ;
+        }
+        else if (__ct.toupper(*__b) == __ct.toupper(*__fmtb))
+        {
+            ++__b;
+            ++__fmtb;
+        }
+        else
+            __err = ios_base::failbit;
+    }
+    if (__b == __e)
+        __err |= ios_base::eofbit;
+    return __b;
+}
+
+template <class _CharT, class _InputIterator>
+typename time_get<_CharT, _InputIterator>::dateorder
+time_get<_CharT, _InputIterator>::do_date_order() const
+{
+    return mdy;
+}
+
+template <class _CharT, class _InputIterator>
+_InputIterator
+time_get<_CharT, _InputIterator>::do_get_time(iter_type __b, iter_type __e,
+                                              ios_base& __iob,
+                                              ios_base::iostate& __err,
+                                              tm* __tm) const
+{
+    const char_type __fmt[] = {'%', 'H', ':', '%', 'M', ':', '%', 'S'};
+    return get(__b, __e, __iob, __err, __tm, __fmt, __fmt + sizeof(__fmt)/sizeof(__fmt[0]));
+}
+
+template <class _CharT, class _InputIterator>
+_InputIterator
+time_get<_CharT, _InputIterator>::do_get_date(iter_type __b, iter_type __e,
+                                              ios_base& __iob,
+                                              ios_base::iostate& __err,
+                                              tm* __tm) const
+{
+    const string_type& __fmt = this->__x();
+    return get(__b, __e, __iob, __err, __tm, __fmt.data(), __fmt.data() + __fmt.size());
+}
+
+template <class _CharT, class _InputIterator>
+_InputIterator
+time_get<_CharT, _InputIterator>::do_get_weekday(iter_type __b, iter_type __e,
+                                                 ios_base& __iob,
+                                                 ios_base::iostate& __err,
+                                                 tm* __tm) const
+{
+    const ctype<char_type>& __ct = use_facet<ctype<char_type> >(__iob.getloc());
+    __get_weekdayname(__tm->tm_wday, __b, __e, __err, __ct);
+    return __b;
+}
+
+template <class _CharT, class _InputIterator>
+_InputIterator
+time_get<_CharT, _InputIterator>::do_get_monthname(iter_type __b, iter_type __e,
+                                                   ios_base& __iob,
+                                                   ios_base::iostate& __err,
+                                                   tm* __tm) const
+{
+    const ctype<char_type>& __ct = use_facet<ctype<char_type> >(__iob.getloc());
+    __get_monthname(__tm->tm_mon, __b, __e, __err, __ct);
+    return __b;
+}
+
+template <class _CharT, class _InputIterator>
+_InputIterator
+time_get<_CharT, _InputIterator>::do_get_year(iter_type __b, iter_type __e,
+                                              ios_base& __iob,
+                                              ios_base::iostate& __err,
+                                              tm* __tm) const
+{
+    const ctype<char_type>& __ct = use_facet<ctype<char_type> >(__iob.getloc());
+    __get_year(__tm->tm_year, __b, __e, __err, __ct);
+    return __b;
+}
+
+template <class _CharT, class _InputIterator>
+_InputIterator
+time_get<_CharT, _InputIterator>::do_get(iter_type __b, iter_type __e,
+                                         ios_base& __iob,
+                                         ios_base::iostate& __err, tm* __tm,
+                                         char __fmt, char) const
+{
+    __err = ios_base::goodbit;
+    const ctype<char_type>& __ct = use_facet<ctype<char_type> >(__iob.getloc());
+    switch (__fmt)
+    {
+    case 'a':
+    case 'A':
+        __get_weekdayname(__tm->tm_wday, __b, __e, __err, __ct);
+        break;
+    case 'b':
+    case 'B':
+    case 'h':
+        __get_monthname(__tm->tm_mon, __b, __e, __err, __ct);
+        break;
+    case 'c':
+        {
+        const string_type& __fm = this->__c();
+        __b = get(__b, __e, __iob, __err, __tm, __fm.data(), __fm.data() + __fm.size());
+        }
+        break;
+    case 'd':
+    case 'e':
+        __get_day(__tm->tm_mday, __b, __e, __err, __ct);
+        break;
+    case 'D':
+        {
+        const char_type __fm[] = {'%', 'm', '/', '%', 'd', '/', '%', 'y'};
+        __b = get(__b, __e, __iob, __err, __tm, __fm, __fm + sizeof(__fm)/sizeof(__fm[0]));
+        }
+        break;
+    case 'F':
+        {
+        const char_type __fm[] = {'%', 'Y', '-', '%', 'm', '-', '%', 'd'};
+        __b = get(__b, __e, __iob, __err, __tm, __fm, __fm + sizeof(__fm)/sizeof(__fm[0]));
+        }
+        break;
+    case 'H':
+        __get_hour(__tm->tm_hour, __b, __e, __err, __ct);
+        break;
+    case 'I':
+        __get_12_hour(__tm->tm_hour, __b, __e, __err, __ct);
+        break;
+    case 'j':
+        __get_day_year_num(__tm->tm_yday, __b, __e, __err, __ct);
+        break;
+    case 'm':
+        __get_month(__tm->tm_mon, __b, __e, __err, __ct);
+        break;
+    case 'M':
+        __get_minute(__tm->tm_min, __b, __e, __err, __ct);
+        break;
+    case 'n':
+    case 't':
+        __get_white_space(__b, __e, __err, __ct);
+        break;
+    case 'p':
+        __get_am_pm(__tm->tm_hour, __b, __e, __err, __ct);
+        break;
+    case 'r':
+        {
+        const char_type __fm[] = {'%', 'I', ':', '%', 'M', ':', '%', 'S', ' ', '%', 'p'};
+        __b = get(__b, __e, __iob, __err, __tm, __fm, __fm + sizeof(__fm)/sizeof(__fm[0]));
+        }
+        break;
+    case 'R':
+        {
+        const char_type __fm[] = {'%', 'H', ':', '%', 'M'};
+        __b = get(__b, __e, __iob, __err, __tm, __fm, __fm + sizeof(__fm)/sizeof(__fm[0]));
+        }
+        break;
+    case 'S':
+        __get_second(__tm->tm_sec, __b, __e, __err, __ct);
+        break;
+    case 'T':
+        {
+        const char_type __fm[] = {'%', 'H', ':', '%', 'M', ':', '%', 'S'};
+        __b = get(__b, __e, __iob, __err, __tm, __fm, __fm + sizeof(__fm)/sizeof(__fm[0]));
+        }
+        break;
+    case 'w':
+        __get_weekday(__tm->tm_wday, __b, __e, __err, __ct);
+        break;
+    case 'x':
+        return do_get_date(__b, __e, __iob, __err, __tm);
+    case 'X':
+        {
+        const string_type& __fm = this->__X();
+        __b = get(__b, __e, __iob, __err, __tm, __fm.data(), __fm.data() + __fm.size());
+        }
+        break;
+    case 'y':
+        __get_year(__tm->tm_year, __b, __e, __err, __ct);
+        break;
+    case 'Y':
+        __get_year4(__tm->tm_year, __b, __e, __err, __ct);
+        break;
+    case '%':
+        __get_percent(__b, __e, __err, __ct);
+        break;
+    default:
+        __err |= ios_base::failbit;
+    }
+    return __b;
+}
+
+_LIBCPP_EXTERN_TEMPLATE2(class _LIBCPP_TYPE_VIS time_get<char>)
+_LIBCPP_EXTERN_TEMPLATE2(class _LIBCPP_TYPE_VIS time_get<wchar_t>)
+
+class _LIBCPP_TYPE_VIS __time_get
+{
+protected:
+    locale_t __loc_;
+
+    __time_get(const char* __nm);
+    __time_get(const string& __nm);
+    ~__time_get();
+};
+
+template <class _CharT>
+class _LIBCPP_TYPE_VIS_ONLY __time_get_storage
+    : public __time_get
+{
+protected:
+    typedef basic_string<_CharT> string_type;
+
+    string_type __weeks_[14];
+    string_type __months_[24];
+    string_type __am_pm_[2];
+    string_type __c_;
+    string_type __r_;
+    string_type __x_;
+    string_type __X_;
+
+    explicit __time_get_storage(const char* __nm);
+    explicit __time_get_storage(const string& __nm);
+
+    _LIBCPP_ALWAYS_INLINE ~__time_get_storage() {}
+
+    time_base::dateorder __do_date_order() const;
+
+private:
+    void init(const ctype<_CharT>&);
+    string_type __analyze(char __fmt, const ctype<_CharT>&);
+};
+
+template <class _CharT, class _InputIterator = istreambuf_iterator<_CharT> >
+class _LIBCPP_TYPE_VIS_ONLY time_get_byname
+    : public time_get<_CharT, _InputIterator>,
+      private __time_get_storage<_CharT>
+{
+public:
+    typedef time_base::dateorder    dateorder;
+    typedef _InputIterator          iter_type;
+    typedef _CharT                  char_type;
+    typedef basic_string<char_type> string_type;
+
+    _LIBCPP_INLINE_VISIBILITY
+    explicit time_get_byname(const char* __nm, size_t __refs = 0)
+        : time_get<_CharT, _InputIterator>(__refs),
+          __time_get_storage<_CharT>(__nm) {}
+    _LIBCPP_INLINE_VISIBILITY
+    explicit time_get_byname(const string& __nm, size_t __refs = 0)
+        : time_get<_CharT, _InputIterator>(__refs),
+          __time_get_storage<_CharT>(__nm) {}
+
+protected:
+    _LIBCPP_INLINE_VISIBILITY
+    ~time_get_byname() {}
+
+    _LIBCPP_INLINE_VISIBILITY
+    virtual dateorder do_date_order() const {return this->__do_date_order();}
+private:
+    _LIBCPP_INLINE_VISIBILITY
+    virtual const string_type* __weeks() const  {return this->__weeks_;}
+    _LIBCPP_INLINE_VISIBILITY
+    virtual const string_type* __months() const {return this->__months_;}
+    _LIBCPP_INLINE_VISIBILITY
+    virtual const string_type* __am_pm() const  {return this->__am_pm_;}
+    _LIBCPP_INLINE_VISIBILITY
+    virtual const string_type& __c() const      {return this->__c_;}
+    _LIBCPP_INLINE_VISIBILITY
+    virtual const string_type& __r() const      {return this->__r_;}
+    _LIBCPP_INLINE_VISIBILITY
+    virtual const string_type& __x() const      {return this->__x_;}
+    _LIBCPP_INLINE_VISIBILITY
+    virtual const string_type& __X() const      {return this->__X_;}
+};
+
+_LIBCPP_EXTERN_TEMPLATE2(class _LIBCPP_TYPE_VIS time_get_byname<char>)
+_LIBCPP_EXTERN_TEMPLATE2(class _LIBCPP_TYPE_VIS time_get_byname<wchar_t>)
+
+class _LIBCPP_TYPE_VIS __time_put
+{
+    locale_t __loc_;
+protected:
+    _LIBCPP_ALWAYS_INLINE __time_put() : __loc_(_LIBCPP_GET_C_LOCALE) {}
+    __time_put(const char* __nm);
+    __time_put(const string& __nm);
+    ~__time_put();
+    void __do_put(char* __nb, char*& __ne, const tm* __tm,
+                  char __fmt, char __mod) const;
+    void __do_put(wchar_t* __wb, wchar_t*& __we, const tm* __tm,
+                  char __fmt, char __mod) const;
+};
+
+template <class _CharT, class _OutputIterator = ostreambuf_iterator<_CharT> >
+class _LIBCPP_TYPE_VIS_ONLY time_put
+    : public locale::facet,
+      private __time_put
+{
+public:
+    typedef _CharT char_type;
+    typedef _OutputIterator iter_type;
+
+    _LIBCPP_ALWAYS_INLINE
+    explicit time_put(size_t __refs = 0)
+        : locale::facet(__refs) {}
+
+    iter_type put(iter_type __s, ios_base& __iob, char_type __fl, const tm* __tm,
+                  const char_type* __pb, const char_type* __pe) const;
+
+    _LIBCPP_ALWAYS_INLINE
+    iter_type put(iter_type __s, ios_base& __iob, char_type __fl,
+                  const tm* __tm, char __fmt, char __mod = 0) const
+    {
+        return do_put(__s, __iob, __fl, __tm, __fmt, __mod);
+    }
+
+    static locale::id id;
+
+protected:
+    _LIBCPP_ALWAYS_INLINE
+    ~time_put() {}
+    virtual iter_type do_put(iter_type __s, ios_base&, char_type, const tm* __tm,
+                             char __fmt, char __mod) const;
+
+    _LIBCPP_ALWAYS_INLINE
+    explicit time_put(const char* __nm, size_t __refs)
+        : locale::facet(__refs),
+          __time_put(__nm) {}
+    _LIBCPP_ALWAYS_INLINE
+    explicit time_put(const string& __nm, size_t __refs)
+        : locale::facet(__refs),
+          __time_put(__nm) {}
+};
+
+template <class _CharT, class _OutputIterator>
+locale::id
+time_put<_CharT, _OutputIterator>::id;
+
+template <class _CharT, class _OutputIterator>
+_OutputIterator
+time_put<_CharT, _OutputIterator>::put(iter_type __s, ios_base& __iob,
+                                       char_type __fl, const tm* __tm,
+                                       const char_type* __pb,
+                                       const char_type* __pe) const
+{
+    const ctype<char_type>& __ct = use_facet<ctype<char_type> >(__iob.getloc());
+    for (; __pb != __pe; ++__pb)
+    {
+        if (__ct.narrow(*__pb, 0) == '%')
+        {
+            if (++__pb == __pe)
+            {
+                *__s++ = __pb[-1];
+                break;
+            }
+            char __mod = 0;
+            char __fmt = __ct.narrow(*__pb, 0);
+            if (__fmt == 'E' || __fmt == 'O')
+            {
+                if (++__pb == __pe)
+                {
+                    *__s++ = __pb[-2];
+                    *__s++ = __pb[-1];
+                    break;
+                }
+                __mod = __fmt;
+                __fmt = __ct.narrow(*__pb, 0);
+            }
+            __s = do_put(__s, __iob, __fl, __tm, __fmt, __mod);
+        }
+        else
+            *__s++ = *__pb;
+    }
+    return __s;
+}
+
+template <class _CharT, class _OutputIterator>
+_OutputIterator
+time_put<_CharT, _OutputIterator>::do_put(iter_type __s, ios_base&,
+                                          char_type, const tm* __tm,
+                                          char __fmt, char __mod) const
+{
+    char_type __nar[100];
+    char_type* __nb = __nar;
+    char_type* __ne = __nb + 100;
+    __do_put(__nb, __ne, __tm, __fmt, __mod);
+    return _VSTD::copy(__nb, __ne, __s);
+}
+
+_LIBCPP_EXTERN_TEMPLATE2(class _LIBCPP_TYPE_VIS time_put<char>)
+_LIBCPP_EXTERN_TEMPLATE2(class _LIBCPP_TYPE_VIS time_put<wchar_t>)
+
+template <class _CharT, class _OutputIterator = ostreambuf_iterator<_CharT> >
+class _LIBCPP_TYPE_VIS_ONLY time_put_byname
+    : public time_put<_CharT, _OutputIterator>
+{
+public:
+    _LIBCPP_ALWAYS_INLINE
+    explicit time_put_byname(const char* __nm, size_t __refs = 0)
+        : time_put<_CharT, _OutputIterator>(__nm, __refs) {}
+
+    _LIBCPP_ALWAYS_INLINE
+    explicit time_put_byname(const string& __nm, size_t __refs = 0)
+        : time_put<_CharT, _OutputIterator>(__nm, __refs) {}
+
+protected:
+    _LIBCPP_ALWAYS_INLINE
+    ~time_put_byname() {}
+};
+
+_LIBCPP_EXTERN_TEMPLATE2(class _LIBCPP_TYPE_VIS time_put_byname<char>)
+_LIBCPP_EXTERN_TEMPLATE2(class _LIBCPP_TYPE_VIS time_put_byname<wchar_t>)
+
+// money_base
+
+class _LIBCPP_TYPE_VIS money_base
+{
+public:
+    enum part {none, space, symbol, sign, value};
+    struct pattern {char field[4];};
+
+    _LIBCPP_ALWAYS_INLINE money_base() {}
+};
+
+// moneypunct
+
+template <class _CharT, bool _International = false>
+class _LIBCPP_TYPE_VIS_ONLY moneypunct
+    : public locale::facet,
+      public money_base
+{
+public:
+    typedef _CharT                  char_type;
+    typedef basic_string<char_type> string_type;
+
+    _LIBCPP_ALWAYS_INLINE
+    explicit moneypunct(size_t __refs = 0)
+        : locale::facet(__refs) {}
+
+    _LIBCPP_ALWAYS_INLINE char_type   decimal_point() const {return do_decimal_point();}
+    _LIBCPP_ALWAYS_INLINE char_type   thousands_sep() const {return do_thousands_sep();}
+    _LIBCPP_ALWAYS_INLINE string      grouping()      const {return do_grouping();}
+    _LIBCPP_ALWAYS_INLINE string_type curr_symbol()   const {return do_curr_symbol();}
+    _LIBCPP_ALWAYS_INLINE string_type positive_sign() const {return do_positive_sign();}
+    _LIBCPP_ALWAYS_INLINE string_type negative_sign() const {return do_negative_sign();}
+    _LIBCPP_ALWAYS_INLINE int         frac_digits()   const {return do_frac_digits();}
+    _LIBCPP_ALWAYS_INLINE pattern     pos_format()    const {return do_pos_format();}
+    _LIBCPP_ALWAYS_INLINE pattern     neg_format()    const {return do_neg_format();}
+
+    static locale::id id;
+    static const bool intl = _International;
+
+protected:
+    _LIBCPP_ALWAYS_INLINE
+    ~moneypunct() {}
+
+    virtual char_type   do_decimal_point() const {return numeric_limits<char_type>::max();}
+    virtual char_type   do_thousands_sep() const {return numeric_limits<char_type>::max();}
+    virtual string      do_grouping()      const {return string();}
+    virtual string_type do_curr_symbol()   const {return string_type();}
+    virtual string_type do_positive_sign() const {return string_type();}
+    virtual string_type do_negative_sign() const {return string_type(1, '-');}
+    virtual int         do_frac_digits()   const {return 0;}
+    virtual pattern     do_pos_format()    const
+        {pattern __p = {{symbol, sign, none, value}}; return __p;}
+    virtual pattern     do_neg_format()    const
+        {pattern __p = {{symbol, sign, none, value}}; return __p;}
+};
+
+template <class _CharT, bool _International>
+locale::id
+moneypunct<_CharT, _International>::id;
+
+template <class _CharT, bool _International>
+const bool
+moneypunct<_CharT, _International>::intl;
+
+_LIBCPP_EXTERN_TEMPLATE2(class _LIBCPP_TYPE_VIS moneypunct<char, false>)
+_LIBCPP_EXTERN_TEMPLATE2(class _LIBCPP_TYPE_VIS moneypunct<char, true>)
+_LIBCPP_EXTERN_TEMPLATE2(class _LIBCPP_TYPE_VIS moneypunct<wchar_t, false>)
+_LIBCPP_EXTERN_TEMPLATE2(class _LIBCPP_TYPE_VIS moneypunct<wchar_t, true>)
+
+// moneypunct_byname
+
+template <class _CharT, bool _International = false>
+class _LIBCPP_TYPE_VIS_ONLY moneypunct_byname
+    : public moneypunct<_CharT, _International>
+{
+public:
+    typedef money_base::pattern  pattern;
+    typedef _CharT                  char_type;
+    typedef basic_string<char_type> string_type;
+
+    _LIBCPP_ALWAYS_INLINE
+    explicit moneypunct_byname(const char* __nm, size_t __refs = 0)
+        : moneypunct<_CharT, _International>(__refs) {init(__nm);}
+
+    _LIBCPP_ALWAYS_INLINE
+    explicit moneypunct_byname(const string& __nm, size_t __refs = 0)
+        : moneypunct<_CharT, _International>(__refs) {init(__nm.c_str());}
+
+protected:
+    _LIBCPP_ALWAYS_INLINE
+    ~moneypunct_byname() {}
+
+    virtual char_type   do_decimal_point() const {return __decimal_point_;}
+    virtual char_type   do_thousands_sep() const {return __thousands_sep_;}
+    virtual string      do_grouping()      const {return __grouping_;}
+    virtual string_type do_curr_symbol()   const {return __curr_symbol_;}
+    virtual string_type do_positive_sign() const {return __positive_sign_;}
+    virtual string_type do_negative_sign() const {return __negative_sign_;}
+    virtual int         do_frac_digits()   const {return __frac_digits_;}
+    virtual pattern     do_pos_format()    const {return __pos_format_;}
+    virtual pattern     do_neg_format()    const {return __neg_format_;}
+
+private:
+    char_type   __decimal_point_;
+    char_type   __thousands_sep_;
+    string      __grouping_;
+    string_type __curr_symbol_;
+    string_type __positive_sign_;
+    string_type __negative_sign_;
+    int         __frac_digits_;
+    pattern     __pos_format_;
+    pattern     __neg_format_;
+
+    void init(const char*);
+};
+
+template<> void moneypunct_byname<char, false>::init(const char*);
+template<> void moneypunct_byname<char, true>::init(const char*);
+template<> void moneypunct_byname<wchar_t, false>::init(const char*);
+template<> void moneypunct_byname<wchar_t, true>::init(const char*);
+
+_LIBCPP_EXTERN_TEMPLATE2(class _LIBCPP_TYPE_VIS moneypunct_byname<char, false>)
+_LIBCPP_EXTERN_TEMPLATE2(class _LIBCPP_TYPE_VIS moneypunct_byname<char, true>)
+_LIBCPP_EXTERN_TEMPLATE2(class _LIBCPP_TYPE_VIS moneypunct_byname<wchar_t, false>)
+_LIBCPP_EXTERN_TEMPLATE2(class _LIBCPP_TYPE_VIS moneypunct_byname<wchar_t, true>)
+
+// money_get
+
+template <class _CharT>
+class __money_get
+{
+protected:
+    typedef _CharT                  char_type;
+    typedef basic_string<char_type> string_type;
+
+    _LIBCPP_ALWAYS_INLINE __money_get() {}
+
+    static void __gather_info(bool __intl, const locale& __loc,
+                              money_base::pattern& __pat, char_type& __dp,
+                              char_type& __ts, string& __grp,
+                              string_type& __sym, string_type& __psn,
+                              string_type& __nsn, int& __fd);
+};
+
+template <class _CharT>
+void
+__money_get<_CharT>::__gather_info(bool __intl, const locale& __loc,
+                                   money_base::pattern& __pat, char_type& __dp,
+                                   char_type& __ts, string& __grp,
+                                   string_type& __sym, string_type& __psn,
+                                   string_type& __nsn, int& __fd)
+{
+    if (__intl)
+    {
+        const moneypunct<char_type, true>& __mp =
+            use_facet<moneypunct<char_type, true> >(__loc);
+        __pat = __mp.neg_format();
+        __nsn = __mp.negative_sign();
+        __psn = __mp.positive_sign();
+        __dp = __mp.decimal_point();
+        __ts = __mp.thousands_sep();
+        __grp = __mp.grouping();
+        __sym = __mp.curr_symbol();
+        __fd = __mp.frac_digits();
+    }
+    else
+    {
+        const moneypunct<char_type, false>& __mp =
+            use_facet<moneypunct<char_type, false> >(__loc);
+        __pat = __mp.neg_format();
+        __nsn = __mp.negative_sign();
+        __psn = __mp.positive_sign();
+        __dp = __mp.decimal_point();
+        __ts = __mp.thousands_sep();
+        __grp = __mp.grouping();
+        __sym = __mp.curr_symbol();
+        __fd = __mp.frac_digits();
+    }
+}
+
+_LIBCPP_EXTERN_TEMPLATE2(class _LIBCPP_TYPE_VIS __money_get<char>)
+_LIBCPP_EXTERN_TEMPLATE2(class _LIBCPP_TYPE_VIS __money_get<wchar_t>)
+
+template <class _CharT, class _InputIterator = istreambuf_iterator<_CharT> >
+class _LIBCPP_TYPE_VIS_ONLY money_get
+    : public locale::facet,
+      private __money_get<_CharT>
+{
+public:
+    typedef _CharT                  char_type;
+    typedef _InputIterator          iter_type;
+    typedef basic_string<char_type> string_type;
+
+    _LIBCPP_ALWAYS_INLINE
+    explicit money_get(size_t __refs = 0)
+        : locale::facet(__refs) {}
+
+    _LIBCPP_ALWAYS_INLINE
+    iter_type get(iter_type __b, iter_type __e, bool __intl, ios_base& __iob,
+                  ios_base::iostate& __err, long double& __v) const
+    {
+        return do_get(__b, __e, __intl, __iob, __err, __v);
+    }
+
+    _LIBCPP_ALWAYS_INLINE
+    iter_type get(iter_type __b, iter_type __e, bool __intl, ios_base& __iob,
+                  ios_base::iostate& __err, string_type& __v) const
+    {
+        return do_get(__b, __e, __intl, __iob, __err, __v);
+    }
+
+    static locale::id id;
+
+protected:
+
+    _LIBCPP_ALWAYS_INLINE
+    ~money_get() {}
+
+    virtual iter_type do_get(iter_type __b, iter_type __e, bool __intl,
+                             ios_base& __iob, ios_base::iostate& __err,
+                             long double& __v) const;
+    virtual iter_type do_get(iter_type __b, iter_type __e, bool __intl,
+                             ios_base& __iob, ios_base::iostate& __err,
+                             string_type& __v) const;
+
+private:
+    static bool __do_get(iter_type& __b, iter_type __e,
+                         bool __intl, const locale& __loc,
+                         ios_base::fmtflags __flags, ios_base::iostate& __err,
+                         bool& __neg, const ctype<char_type>& __ct,
+                         unique_ptr<char_type, void(*)(void*)>& __wb,
+                         char_type*& __wn, char_type* __we);
+};
+
+template <class _CharT, class _InputIterator>
+locale::id
+money_get<_CharT, _InputIterator>::id;
+
+_LIBCPP_FUNC_VIS void __do_nothing(void*);
+
+template <class _Tp>
+_LIBCPP_HIDDEN
+void
+__double_or_nothing(unique_ptr<_Tp, void(*)(void*)>& __b, _Tp*& __n, _Tp*& __e)
+{
+    bool __owns = __b.get_deleter() != __do_nothing;
+    size_t __cur_cap = static_cast<size_t>(__e-__b.get()) * sizeof(_Tp);
+    size_t __new_cap = __cur_cap < numeric_limits<size_t>::max() / 2 ?
+                       2 * __cur_cap : numeric_limits<size_t>::max();
+    if (__new_cap == 0)
+        __new_cap = sizeof(_Tp);
+    size_t __n_off = static_cast<size_t>(__n - __b.get());
+    _Tp* __t = (_Tp*)realloc(__owns ? __b.get() : 0, __new_cap);
+    if (__t == 0)
+        __throw_bad_alloc();
+    if (__owns)
+        __b.release();
+    __b = unique_ptr<_Tp, void(*)(void*)>(__t, free);
+    __new_cap /= sizeof(_Tp);
+    __n = __b.get() + __n_off;
+    __e = __b.get() + __new_cap;
+}
+
+// true == success
+template <class _CharT, class _InputIterator>
+bool
+money_get<_CharT, _InputIterator>::__do_get(iter_type& __b, iter_type __e,
+                                            bool __intl, const locale& __loc,
+                                            ios_base::fmtflags __flags,
+                                            ios_base::iostate& __err,
+                                            bool& __neg,
+                                            const ctype<char_type>& __ct,
+                                            unique_ptr<char_type, void(*)(void*)>& __wb,
+                                            char_type*& __wn, char_type* __we)
+{
+    const unsigned __bz = 100;
+    unsigned __gbuf[__bz];
+    unique_ptr<unsigned, void(*)(void*)> __gb(__gbuf, __do_nothing);
+    unsigned* __gn = __gb.get();
+    unsigned* __ge = __gn + __bz;
+    money_base::pattern __pat;
+    char_type __dp;
+    char_type __ts;
+    string __grp;
+    string_type __sym;
+    string_type __psn;
+    string_type __nsn;
+    // Capture the spaces read into money_base::{space,none} so they
+    // can be compared to initial spaces in __sym.
+    string_type __spaces;
+    int __fd;
+    __money_get<_CharT>::__gather_info(__intl, __loc, __pat, __dp, __ts, __grp,
+                                       __sym, __psn, __nsn, __fd);
+    const string_type* __trailing_sign = 0;
+    __wn = __wb.get();
+    for (unsigned __p = 0; __p < 4 && __b != __e; ++__p)
+    {
+        switch (__pat.field[__p])
+        {
+        case money_base::space:
+            if (__p != 3)
+            {
+                if (__ct.is(ctype_base::space, *__b))
+                    __spaces.push_back(*__b++);
+                else
+                {
+                    __err |= ios_base::failbit;
+                    return false;
+                }
+            }
+            // drop through
+        case money_base::none:
+            if (__p != 3)
+            {
+                while (__b != __e && __ct.is(ctype_base::space, *__b))
+                    __spaces.push_back(*__b++);
+            }
+            break;
+        case money_base::sign:
+            if (__psn.size() + __nsn.size() > 0)
+            {
+                if (__psn.size() == 0 || __nsn.size() == 0)
+                {   // sign is optional
+                    if (__psn.size() > 0)
+                    {   // __nsn.size() == 0
+                        if (*__b == __psn[0])
+                        {
+                            ++__b;
+                            if (__psn.size() > 1)
+                                __trailing_sign = &__psn;
+                        }
+                        else
+                            __neg = true;
+                    }
+                    else if (*__b == __nsn[0])  // __nsn.size() > 0 &&  __psn.size() == 0
+                    {
+                        ++__b;
+                        __neg = true;
+                        if (__nsn.size() > 1)
+                            __trailing_sign = &__nsn;
+                    }
+                }
+                else  // sign is required
+                {
+                    if (*__b == __psn[0])
+                    {
+                        ++__b;
+                        if (__psn.size() > 1)
+                            __trailing_sign = &__psn;
+                    }
+                    else if (*__b == __nsn[0])
+                    {
+                        ++__b;
+                        __neg = true;
+                        if (__nsn.size() > 1)
+                            __trailing_sign = &__nsn;
+                    }
+                    else
+                    {
+                        __err |= ios_base::failbit;
+                        return false;
+                    }
+                }
+            }
+            break;
+        case money_base::symbol:
+            {
+            bool __more_needed = __trailing_sign ||
+                                 (__p < 2)       ||
+                                 (__p == 2 && __pat.field[3] != static_cast<char>(money_base::none));
+            bool __sb = (__flags & ios_base::showbase) != 0;
+            if (__sb || __more_needed)
+            {
+                typename string_type::const_iterator __sym_space_end = __sym.begin();
+                if (__p > 0 && (__pat.field[__p - 1] == money_base::none ||
+                                __pat.field[__p - 1] == money_base::space)) {
+                    // Match spaces we've already read against spaces at
+                    // the beginning of __sym.
+                    while (__sym_space_end != __sym.end() &&
+                           __ct.is(ctype_base::space, *__sym_space_end))
+                        ++__sym_space_end;
+                    const size_t __num_spaces = __sym_space_end - __sym.begin();
+                    if (__num_spaces > __spaces.size() ||
+                        !equal(__spaces.end() - __num_spaces, __spaces.end(),
+                               __sym.begin())) {
+                        // No match. Put __sym_space_end back at the
+                        // beginning of __sym, which will prevent a
+                        // match in the next loop.
+                        __sym_space_end = __sym.begin();
+                    }
+                }
+                typename string_type::const_iterator __sym_curr_char = __sym_space_end;
+                while (__sym_curr_char != __sym.end() && __b != __e &&
+                       *__b == *__sym_curr_char) {
+                    ++__b;
+                    ++__sym_curr_char;
+                }
+                if (__sb && __sym_curr_char != __sym.end())
+                {
+                    __err |= ios_base::failbit;
+                    return false;
+                }
+            }
+            }
+            break;
+        case money_base::value:
+            {
+            unsigned __ng = 0;
+            for (; __b != __e; ++__b)
+            {
+                char_type __c = *__b;
+                if (__ct.is(ctype_base::digit, __c))
+                {
+                    if (__wn == __we)
+                        __double_or_nothing(__wb, __wn, __we);
+                    *__wn++ = __c;
+                    ++__ng;
+                }
+                else if (__grp.size() > 0 && __ng > 0 && __c == __ts)
+                {
+                    if (__gn == __ge)
+                        __double_or_nothing(__gb, __gn, __ge);
+                    *__gn++ = __ng;
+                    __ng = 0;
+                }
+                else
+                    break;
+            }
+            if (__gb.get() != __gn && __ng > 0)
+            {
+                if (__gn == __ge)
+                    __double_or_nothing(__gb, __gn, __ge);
+                *__gn++ = __ng;
+            }
+            if (__fd > 0)
+            {
+                if (__b == __e || *__b != __dp)
+                {
+                    __err |= ios_base::failbit;
+                    return false;
+                }
+                for (++__b; __fd > 0; --__fd, ++__b)
+                {
+                    if (__b == __e || !__ct.is(ctype_base::digit, *__b))
+                    {
+                        __err |= ios_base::failbit;
+                        return false;
+                    }
+                    if (__wn == __we)
+                        __double_or_nothing(__wb, __wn, __we);
+                    *__wn++ = *__b;
+                }
+            }
+            if (__wn == __wb.get())
+            {
+                __err |= ios_base::failbit;
+                return false;
+            }
+            }
+            break;
+        }
+    }
+    if (__trailing_sign)
+    {
+        for (unsigned __i = 1; __i < __trailing_sign->size(); ++__i, ++__b)
+        {
+            if (__b == __e || *__b != (*__trailing_sign)[__i])
+            {
+                __err |= ios_base::failbit;
+                return false;
+            }
+        }
+    }
+    if (__gb.get() != __gn)
+    {
+        ios_base::iostate __et = ios_base::goodbit;
+        __check_grouping(__grp, __gb.get(), __gn, __et);
+        if (__et)
+        {
+            __err |= ios_base::failbit;
+            return false;
+        }
+    }
+    return true;
+}
+
+template <class _CharT, class _InputIterator>
+_InputIterator
+money_get<_CharT, _InputIterator>::do_get(iter_type __b, iter_type __e,
+                                          bool __intl, ios_base& __iob,
+                                          ios_base::iostate& __err,
+                                          long double& __v) const
+{
+    const int __bz = 100;
+    char_type __wbuf[__bz];
+    unique_ptr<char_type, void(*)(void*)> __wb(__wbuf, __do_nothing);
+    char_type* __wn;
+    char_type* __we = __wbuf + __bz;
+    locale __loc = __iob.getloc();
+    const ctype<char_type>& __ct = use_facet<ctype<char_type> >(__loc);
+    bool __neg = false;
+    if (__do_get(__b, __e, __intl, __loc, __iob.flags(), __err, __neg, __ct,
+                 __wb, __wn, __we))
+    {
+        const char __src[] = "0123456789";
+        char_type __atoms[sizeof(__src)-1];
+        __ct.widen(__src, __src + (sizeof(__src)-1), __atoms);
+        char __nbuf[__bz];
+        char* __nc = __nbuf;
+        unique_ptr<char, void(*)(void*)> __h(0, free);
+        if (__wn - __wb.get() > __bz-2)
+        {
+            __h.reset((char*)malloc(static_cast<size_t>(__wn - __wb.get() + 2)));
+            if (__h.get() == 0)
+                __throw_bad_alloc();
+            __nc = __h.get();
+        }
+        if (__neg)
+            *__nc++ = '-';
+        for (const char_type* __w = __wb.get(); __w < __wn; ++__w, ++__nc)
+            *__nc = __src[find(__atoms, _VSTD::end(__atoms), *__w) - __atoms];
+        *__nc = char();
+        if (sscanf(__nbuf, "%Lf", &__v) != 1)
+            __throw_runtime_error("money_get error");
+    }
+    if (__b == __e)
+        __err |= ios_base::eofbit;
+    return __b;
+}
+
+template <class _CharT, class _InputIterator>
+_InputIterator
+money_get<_CharT, _InputIterator>::do_get(iter_type __b, iter_type __e,
+                                          bool __intl, ios_base& __iob,
+                                          ios_base::iostate& __err,
+                                          string_type& __v) const
+{
+    const int __bz = 100;
+    char_type __wbuf[__bz];
+    unique_ptr<char_type, void(*)(void*)> __wb(__wbuf, __do_nothing);
+    char_type* __wn;
+    char_type* __we = __wbuf + __bz;
+    locale __loc = __iob.getloc();
+    const ctype<char_type>& __ct = use_facet<ctype<char_type> >(__loc);
+    bool __neg = false;
+    if (__do_get(__b, __e, __intl, __loc, __iob.flags(), __err, __neg, __ct,
+                 __wb, __wn, __we))
+    {
+        __v.clear();
+        if (__neg)
+            __v.push_back(__ct.widen('-'));
+        char_type __z = __ct.widen('0');
+        char_type* __w;
+        for (__w = __wb.get(); __w < __wn-1; ++__w)
+            if (*__w != __z)
+                break;
+        __v.append(__w, __wn);
+    }
+    if (__b == __e)
+        __err |= ios_base::eofbit;
+    return __b;
+}
+
+_LIBCPP_EXTERN_TEMPLATE2(class _LIBCPP_TYPE_VIS money_get<char>)
+_LIBCPP_EXTERN_TEMPLATE2(class _LIBCPP_TYPE_VIS money_get<wchar_t>)
+
+// money_put
+
+template <class _CharT>
+class __money_put
+{
+protected:
+    typedef _CharT                  char_type;
+    typedef basic_string<char_type> string_type;
+
+    _LIBCPP_ALWAYS_INLINE __money_put() {}
+
+    static void __gather_info(bool __intl, bool __neg, const locale& __loc,
+                              money_base::pattern& __pat, char_type& __dp,
+                              char_type& __ts, string& __grp,
+                              string_type& __sym, string_type& __sn,
+                              int& __fd);
+    static void __format(char_type* __mb, char_type*& __mi, char_type*& __me,
+                         ios_base::fmtflags __flags,
+                         const char_type* __db, const char_type* __de,
+                         const ctype<char_type>& __ct, bool __neg,
+                         const money_base::pattern& __pat, char_type __dp,
+                         char_type __ts, const string& __grp,
+                         const string_type& __sym, const string_type& __sn,
+                         int __fd);
+};
+
+template <class _CharT>
+void
+__money_put<_CharT>::__gather_info(bool __intl, bool __neg, const locale& __loc,
+                                   money_base::pattern& __pat, char_type& __dp,
+                                   char_type& __ts, string& __grp,
+                                   string_type& __sym, string_type& __sn,
+                                   int& __fd)
+{
+    if (__intl)
+    {
+        const moneypunct<char_type, true>& __mp =
+            use_facet<moneypunct<char_type, true> >(__loc);
+        if (__neg)
+        {
+            __pat = __mp.neg_format();
+            __sn = __mp.negative_sign();
+        }
+        else
+        {
+            __pat = __mp.pos_format();
+            __sn = __mp.positive_sign();
+        }
+        __dp = __mp.decimal_point();
+        __ts = __mp.thousands_sep();
+        __grp = __mp.grouping();
+        __sym = __mp.curr_symbol();
+        __fd = __mp.frac_digits();
+    }
+    else
+    {
+        const moneypunct<char_type, false>& __mp =
+            use_facet<moneypunct<char_type, false> >(__loc);
+        if (__neg)
+        {
+            __pat = __mp.neg_format();
+            __sn = __mp.negative_sign();
+        }
+        else
+        {
+            __pat = __mp.pos_format();
+            __sn = __mp.positive_sign();
+        }
+        __dp = __mp.decimal_point();
+        __ts = __mp.thousands_sep();
+        __grp = __mp.grouping();
+        __sym = __mp.curr_symbol();
+        __fd = __mp.frac_digits();
+    }
+}
+
+template <class _CharT>
+void
+__money_put<_CharT>::__format(char_type* __mb, char_type*& __mi, char_type*& __me,
+                              ios_base::fmtflags __flags,
+                              const char_type* __db, const char_type* __de,
+                              const ctype<char_type>& __ct, bool __neg,
+                              const money_base::pattern& __pat, char_type __dp,
+                              char_type __ts, const string& __grp,
+                              const string_type& __sym, const string_type& __sn,
+                              int __fd)
+{
+    __me = __mb;
+    for (unsigned __p = 0; __p < 4; ++__p)
+    {
+        switch (__pat.field[__p])
+        {
+        case money_base::none:
+            __mi = __me;
+            break;
+        case money_base::space:
+            __mi = __me;
+            *__me++ = __ct.widen(' ');
+            break;
+        case money_base::sign:
+            if (!__sn.empty())
+                *__me++ = __sn[0];
+            break;
+        case money_base::symbol:
+            if (!__sym.empty() && (__flags & ios_base::showbase))
+                __me = _VSTD::copy(__sym.begin(), __sym.end(), __me);
+            break;
+        case money_base::value:
+            {
+            // remember start of value so we can reverse it
+            char_type* __t = __me;
+            // find beginning of digits
+            if (__neg)
+                ++__db;
+            // find end of digits
+            const char_type* __d;
+            for (__d = __db; __d < __de; ++__d)
+                if (!__ct.is(ctype_base::digit, *__d))
+                    break;
+            // print fractional part
+            if (__fd > 0)
+            {
+                int __f;
+                for (__f = __fd; __d > __db && __f > 0; --__f)
+                    *__me++ = *--__d;
+                char_type __z = __f > 0 ? __ct.widen('0') : char_type();
+                for (; __f > 0; --__f)
+                    *__me++ = __z;
+                *__me++ = __dp;
+            }
+            // print units part
+            if (__d == __db)
+            {
+                *__me++ = __ct.widen('0');
+            }
+            else
+            {
+                unsigned __ng = 0;
+                unsigned __ig = 0;
+                unsigned __gl = __grp.empty() ? numeric_limits<unsigned>::max()
+                                              : static_cast<unsigned>(__grp[__ig]);
+                while (__d != __db)
+                {
+                    if (__ng == __gl)
+                    {
+                        *__me++ = __ts;
+                        __ng = 0;
+                        if (++__ig < __grp.size())
+                            __gl = __grp[__ig] == numeric_limits<char>::max() ?
+                                        numeric_limits<unsigned>::max() :
+                                        static_cast<unsigned>(__grp[__ig]);
+                    }
+                    *__me++ = *--__d;
+                    ++__ng;
+                }
+            }
+            // reverse it
+            reverse(__t, __me);
+            }
+            break;
+        }
+    }
+    // print rest of sign, if any
+    if (__sn.size() > 1)
+        __me = _VSTD::copy(__sn.begin()+1, __sn.end(), __me);
+    // set alignment
+    if ((__flags & ios_base::adjustfield) == ios_base::left)
+        __mi = __me;
+    else if ((__flags & ios_base::adjustfield) != ios_base::internal)
+        __mi = __mb;
+}
+
+_LIBCPP_EXTERN_TEMPLATE2(class _LIBCPP_TYPE_VIS __money_put<char>)
+_LIBCPP_EXTERN_TEMPLATE2(class _LIBCPP_TYPE_VIS __money_put<wchar_t>)
+
+template <class _CharT, class _OutputIterator = ostreambuf_iterator<_CharT> >
+class _LIBCPP_TYPE_VIS_ONLY money_put
+    : public locale::facet,
+      private __money_put<_CharT>
+{
+public:
+    typedef _CharT                  char_type;
+    typedef _OutputIterator         iter_type;
+    typedef basic_string<char_type> string_type;
+
+    _LIBCPP_ALWAYS_INLINE
+    explicit money_put(size_t __refs = 0)
+        : locale::facet(__refs) {}
+
+    _LIBCPP_ALWAYS_INLINE
+    iter_type put(iter_type __s, bool __intl, ios_base& __iob, char_type __fl,
+                  long double __units) const
+    {
+        return do_put(__s, __intl, __iob, __fl, __units);
+    }
+
+    _LIBCPP_ALWAYS_INLINE
+    iter_type put(iter_type __s, bool __intl, ios_base& __iob, char_type __fl,
+                  const string_type& __digits) const
+    {
+        return do_put(__s, __intl, __iob, __fl, __digits);
+    }
+
+    static locale::id id;
+
+protected:
+    _LIBCPP_ALWAYS_INLINE
+    ~money_put() {}
+
+    virtual iter_type do_put(iter_type __s, bool __intl, ios_base& __iob,
+                             char_type __fl, long double __units) const;
+    virtual iter_type do_put(iter_type __s, bool __intl, ios_base& __iob,
+                             char_type __fl, const string_type& __digits) const;
+};
+
+template <class _CharT, class _OutputIterator>
+locale::id
+money_put<_CharT, _OutputIterator>::id;
+
+template <class _CharT, class _OutputIterator>
+_OutputIterator
+money_put<_CharT, _OutputIterator>::do_put(iter_type __s, bool __intl,
+                                           ios_base& __iob, char_type __fl,
+                                           long double __units) const
+{
+    // convert to char
+    const size_t __bs = 100;
+    char __buf[__bs];
+    char* __bb = __buf;
+    char_type __digits[__bs];
+    char_type* __db = __digits;
+    size_t __n = static_cast<size_t>(snprintf(__bb, __bs, "%.0Lf", __units));
+    unique_ptr<char, void(*)(void*)> __hn(0, free);
+    unique_ptr<char_type, void(*)(void*)> __hd(0, free);
+    // secure memory for digit storage
+    if (__n > __bs-1)
+    {
+#ifdef _LIBCPP_LOCALE__L_EXTENSIONS
+        __n = static_cast<size_t>(asprintf_l(&__bb, _LIBCPP_GET_C_LOCALE, "%.0Lf", __units));
+#else
+        __n = __asprintf_l(&__bb, __cloc(), "%.0Lf", __units);
+#endif
+        if (__bb == 0)
+            __throw_bad_alloc();
+        __hn.reset(__bb);
+        __hd.reset((char_type*)malloc(__n * sizeof(char_type)));
+        if (__hd == nullptr)
+            __throw_bad_alloc();
+        __db = __hd.get();
+    }
+    // gather info
+    locale __loc = __iob.getloc();
+    const ctype<char_type>& __ct = use_facet<ctype<char_type> >(__loc);
+    __ct.widen(__bb, __bb + __n, __db);
+    bool __neg = __n > 0 && __bb[0] == '-';
+    money_base::pattern __pat;
+    char_type __dp;
+    char_type __ts;
+    string __grp;
+    string_type __sym;
+    string_type __sn;
+    int __fd;
+    this->__gather_info(__intl, __neg, __loc, __pat, __dp, __ts, __grp, __sym, __sn, __fd);
+    // secure memory for formatting
+    char_type __mbuf[__bs];
+    char_type* __mb = __mbuf;
+    unique_ptr<char_type, void(*)(void*)> __hw(0, free);
+    size_t __exn = static_cast<int>(__n) > __fd ?
+                   (__n - static_cast<size_t>(__fd)) * 2 + __sn.size() +
+                    __sym.size() + static_cast<size_t>(__fd) + 1
+                 : __sn.size() + __sym.size() + static_cast<size_t>(__fd) + 2;
+    if (__exn > __bs)
+    {
+        __hw.reset((char_type*)malloc(__exn * sizeof(char_type)));
+        __mb = __hw.get();
+        if (__mb == 0)
+            __throw_bad_alloc();
+    }
+    // format
+    char_type* __mi;
+    char_type* __me;
+    this->__format(__mb, __mi, __me, __iob.flags(),
+                   __db, __db + __n, __ct,
+                   __neg, __pat, __dp, __ts, __grp, __sym, __sn, __fd);
+    return __pad_and_output(__s, __mb, __mi, __me, __iob, __fl);
+}
+
+template <class _CharT, class _OutputIterator>
+_OutputIterator
+money_put<_CharT, _OutputIterator>::do_put(iter_type __s, bool __intl,
+                                           ios_base& __iob, char_type __fl,
+                                           const string_type& __digits) const
+{
+    // gather info
+    locale __loc = __iob.getloc();
+    const ctype<char_type>& __ct = use_facet<ctype<char_type> >(__loc);
+    bool __neg = __digits.size() > 0 && __digits[0] == __ct.widen('-');
+    money_base::pattern __pat;
+    char_type __dp;
+    char_type __ts;
+    string __grp;
+    string_type __sym;
+    string_type __sn;
+    int __fd;
+    this->__gather_info(__intl, __neg, __loc, __pat, __dp, __ts, __grp, __sym, __sn, __fd);
+    // secure memory for formatting
+    char_type __mbuf[100];
+    char_type* __mb = __mbuf;
+    unique_ptr<char_type, void(*)(void*)> __h(0, free);
+    size_t __exn = static_cast<int>(__digits.size()) > __fd ?
+                   (__digits.size() - static_cast<size_t>(__fd)) * 2 +
+                    __sn.size() + __sym.size() + static_cast<size_t>(__fd) + 1
+                 : __sn.size() + __sym.size() + static_cast<size_t>(__fd) + 2;
+    if (__exn > 100)
+    {
+        __h.reset((char_type*)malloc(__exn * sizeof(char_type)));
+        __mb = __h.get();
+        if (__mb == 0)
+            __throw_bad_alloc();
+    }
+    // format
+    char_type* __mi;
+    char_type* __me;
+    this->__format(__mb, __mi, __me, __iob.flags(),
+                   __digits.data(), __digits.data() + __digits.size(), __ct,
+                   __neg, __pat, __dp, __ts, __grp, __sym, __sn, __fd);
+    return __pad_and_output(__s, __mb, __mi, __me, __iob, __fl);
+}
+
+_LIBCPP_EXTERN_TEMPLATE2(class _LIBCPP_TYPE_VIS money_put<char>)
+_LIBCPP_EXTERN_TEMPLATE2(class _LIBCPP_TYPE_VIS money_put<wchar_t>)
+
+// messages
+
+class _LIBCPP_TYPE_VIS messages_base
+{
+public:
+    typedef ptrdiff_t catalog;
+
+    _LIBCPP_ALWAYS_INLINE messages_base() {}
+};
+
+template <class _CharT>
+class _LIBCPP_TYPE_VIS_ONLY messages
+    : public locale::facet,
+      public messages_base
+{
+public:
+    typedef _CharT               char_type;
+    typedef basic_string<_CharT> string_type;
+
+    _LIBCPP_ALWAYS_INLINE
+    explicit messages(size_t __refs = 0)
+        : locale::facet(__refs) {}
+
+    _LIBCPP_ALWAYS_INLINE
+    catalog open(const basic_string<char>& __nm, const locale& __loc) const
+    {
+        return do_open(__nm, __loc);
+    }
+
+    _LIBCPP_ALWAYS_INLINE
+    string_type get(catalog __c, int __set, int __msgid,
+                    const string_type& __dflt) const
+    {
+        return do_get(__c, __set, __msgid, __dflt);
+    }
+
+    _LIBCPP_ALWAYS_INLINE
+    void close(catalog __c) const
+    {
+        do_close(__c);
+    }
+
+    static locale::id id;
+
+protected:
+    _LIBCPP_ALWAYS_INLINE
+    ~messages() {}
+
+    virtual catalog do_open(const basic_string<char>&, const locale&) const;
+    virtual string_type do_get(catalog, int __set, int __msgid,
+                               const string_type& __dflt) const;
+    virtual void do_close(catalog) const;
+};
+
+template <class _CharT>
+locale::id
+messages<_CharT>::id;
+
+template <class _CharT>
+typename messages<_CharT>::catalog
+messages<_CharT>::do_open(const basic_string<char>& __nm, const locale&) const
+{
+#ifdef _LIBCPP_HAS_CATOPEN
+    catalog __cat = (catalog)catopen(__nm.c_str(), NL_CAT_LOCALE);
+    if (__cat != -1)
+        __cat = static_cast<catalog>((static_cast<size_t>(__cat) >> 1));
+    return __cat;
+#else // !_LIBCPP_HAS_CATOPEN
+    return -1;
+#endif // _LIBCPP_HAS_CATOPEN
+}
+
+template <class _CharT>
+typename messages<_CharT>::string_type
+messages<_CharT>::do_get(catalog __c, int __set, int __msgid,
+                         const string_type& __dflt) const
+{
+#ifdef _LIBCPP_HAS_CATOPEN
+    string __ndflt;
+    __narrow_to_utf8<sizeof(char_type)*__CHAR_BIT__>()(back_inserter(__ndflt),
+                                                       __dflt.c_str(),
+                                                       __dflt.c_str() + __dflt.size());
+    if (__c != -1)
+        __c <<= 1;
+    nl_catd __cat = (nl_catd)__c;
+    char* __n = catgets(__cat, __set, __msgid, __ndflt.c_str());
+    string_type __w;
+    __widen_from_utf8<sizeof(char_type)*__CHAR_BIT__>()(back_inserter(__w),
+                                                        __n, __n + strlen(__n));
+    return __w;
+#else // !_LIBCPP_HAS_CATOPEN
+    return __dflt;
+#endif // _LIBCPP_HAS_CATOPEN
+}
+
+template <class _CharT>
+void
+messages<_CharT>::do_close(catalog __c) const
+{
+#ifdef _LIBCPP_HAS_CATOPEN
+    if (__c != -1)
+        __c <<= 1;
+    nl_catd __cat = (nl_catd)__c;
+    catclose(__cat);
+#endif // _LIBCPP_HAS_CATOPEN
+}
+
+_LIBCPP_EXTERN_TEMPLATE2(class _LIBCPP_TYPE_VIS messages<char>)
+_LIBCPP_EXTERN_TEMPLATE2(class _LIBCPP_TYPE_VIS messages<wchar_t>)
+
+template <class _CharT>
+class _LIBCPP_TYPE_VIS_ONLY messages_byname
+    : public messages<_CharT>
+{
+public:
+    typedef messages_base::catalog catalog;
+    typedef basic_string<_CharT> string_type;
+
+    _LIBCPP_ALWAYS_INLINE
+    explicit messages_byname(const char*, size_t __refs = 0)
+        : messages<_CharT>(__refs) {}
+
+    _LIBCPP_ALWAYS_INLINE
+    explicit messages_byname(const string&, size_t __refs = 0)
+        : messages<_CharT>(__refs) {}
+
+protected:
+    _LIBCPP_ALWAYS_INLINE
+    ~messages_byname() {}
+};
+
+_LIBCPP_EXTERN_TEMPLATE2(class _LIBCPP_TYPE_VIS messages_byname<char>)
+_LIBCPP_EXTERN_TEMPLATE2(class _LIBCPP_TYPE_VIS messages_byname<wchar_t>)
+
+template<class _Codecvt, class _Elem = wchar_t,
+         class _Wide_alloc = allocator<_Elem>,
+         class _Byte_alloc = allocator<char> >
+class _LIBCPP_TYPE_VIS_ONLY wstring_convert
+{
+public:
+    typedef basic_string<char, char_traits<char>, _Byte_alloc>   byte_string;
+    typedef basic_string<_Elem, char_traits<_Elem>, _Wide_alloc> wide_string;
+    typedef typename _Codecvt::state_type                        state_type;
+    typedef typename wide_string::traits_type::int_type          int_type;
+
+private:
+    byte_string __byte_err_string_;
+    wide_string __wide_err_string_;
+    _Codecvt* __cvtptr_;
+    state_type __cvtstate_;
+    size_t __cvtcount_;
+
+    wstring_convert(const wstring_convert& __wc);
+    wstring_convert& operator=(const wstring_convert& __wc);
+public:
+    _LIBCPP_EXPLICIT_AFTER_CXX11 wstring_convert(_Codecvt* __pcvt = new _Codecvt);
+    wstring_convert(_Codecvt* __pcvt, state_type __state);
+    _LIBCPP_EXPLICIT_AFTER_CXX11 wstring_convert(const byte_string& __byte_err,
+                    const wide_string& __wide_err = wide_string());
+#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES
+    wstring_convert(wstring_convert&& __wc);
+#endif
+    ~wstring_convert();
+
+    _LIBCPP_ALWAYS_INLINE
+    wide_string from_bytes(char __byte)
+        {return from_bytes(&__byte, &__byte+1);}
+    _LIBCPP_ALWAYS_INLINE
+    wide_string from_bytes(const char* __ptr)
+        {return from_bytes(__ptr, __ptr + char_traits<char>::length(__ptr));}
+    _LIBCPP_ALWAYS_INLINE
+    wide_string from_bytes(const byte_string& __str)
+        {return from_bytes(__str.data(), __str.data() + __str.size());}
+    wide_string from_bytes(const char* __first, const char* __last);
+
+    _LIBCPP_ALWAYS_INLINE
+    byte_string to_bytes(_Elem __wchar)
+        {return to_bytes(&__wchar, &__wchar+1);}
+    _LIBCPP_ALWAYS_INLINE
+    byte_string to_bytes(const _Elem* __wptr)
+        {return to_bytes(__wptr, __wptr + char_traits<_Elem>::length(__wptr));}
+    _LIBCPP_ALWAYS_INLINE
+    byte_string to_bytes(const wide_string& __wstr)
+        {return to_bytes(__wstr.data(), __wstr.data() + __wstr.size());}
+    byte_string to_bytes(const _Elem* __first, const _Elem* __last);
+
+    _LIBCPP_ALWAYS_INLINE
+    size_t converted() const _NOEXCEPT {return __cvtcount_;}
+    _LIBCPP_ALWAYS_INLINE
+    state_type state() const {return __cvtstate_;}
+};
+
+template<class _Codecvt, class _Elem, class _Wide_alloc, class _Byte_alloc>
+inline _LIBCPP_ALWAYS_INLINE
+wstring_convert<_Codecvt, _Elem, _Wide_alloc, _Byte_alloc>::
+    wstring_convert(_Codecvt* __pcvt)
+        : __cvtptr_(__pcvt), __cvtstate_(), __cvtcount_(0)
+{
+}
+
+template<class _Codecvt, class _Elem, class _Wide_alloc, class _Byte_alloc>
+inline _LIBCPP_ALWAYS_INLINE
+wstring_convert<_Codecvt, _Elem, _Wide_alloc, _Byte_alloc>::
+    wstring_convert(_Codecvt* __pcvt, state_type __state)
+        : __cvtptr_(__pcvt), __cvtstate_(__state), __cvtcount_(0)
+{
+}
+
+template<class _Codecvt, class _Elem, class _Wide_alloc, class _Byte_alloc>
+wstring_convert<_Codecvt, _Elem, _Wide_alloc, _Byte_alloc>::
+    wstring_convert(const byte_string& __byte_err, const wide_string& __wide_err)
+        : __byte_err_string_(__byte_err), __wide_err_string_(__wide_err),
+          __cvtstate_(), __cvtcount_(0)
+{
+    __cvtptr_ = new _Codecvt;
+}
+
+#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES
+
+template<class _Codecvt, class _Elem, class _Wide_alloc, class _Byte_alloc>
+inline _LIBCPP_ALWAYS_INLINE
+wstring_convert<_Codecvt, _Elem, _Wide_alloc, _Byte_alloc>::
+    wstring_convert(wstring_convert&& __wc)
+        : __byte_err_string_(_VSTD::move(__wc.__byte_err_string_)),
+          __wide_err_string_(_VSTD::move(__wc.__wide_err_string_)),
+          __cvtptr_(__wc.__cvtptr_),
+          __cvtstate_(__wc.__cvtstate_), __cvtcount_(__wc.__cvtstate_)
+{
+    __wc.__cvtptr_ = nullptr;
+}
+
+#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES
+
+template<class _Codecvt, class _Elem, class _Wide_alloc, class _Byte_alloc>
+wstring_convert<_Codecvt, _Elem, _Wide_alloc, _Byte_alloc>::~wstring_convert()
+{
+    delete __cvtptr_;
+}
+
+template<class _Codecvt, class _Elem, class _Wide_alloc, class _Byte_alloc>
+typename wstring_convert<_Codecvt, _Elem, _Wide_alloc, _Byte_alloc>::wide_string
+wstring_convert<_Codecvt, _Elem, _Wide_alloc, _Byte_alloc>::
+    from_bytes(const char* __frm, const char* __frm_end)
+{
+    __cvtcount_ = 0;
+    if (__cvtptr_ != nullptr)
+    {
+        wide_string __ws(2*(__frm_end - __frm), _Elem());
+        if (__frm != __frm_end)
+            __ws.resize(__ws.capacity());
+        codecvt_base::result __r = codecvt_base::ok;
+        state_type __st = __cvtstate_;
+        if (__frm != __frm_end)
+        {
+            _Elem* __to = &__ws[0];
+            _Elem* __to_end = __to + __ws.size();
+            const char* __frm_nxt;
+            do
+            {
+                _Elem* __to_nxt;
+                __r = __cvtptr_->in(__st, __frm, __frm_end, __frm_nxt,
+                                          __to, __to_end, __to_nxt);
+                __cvtcount_ += __frm_nxt - __frm;
+                if (__frm_nxt == __frm)
+                {
+                    __r = codecvt_base::error;
+                }
+                else if (__r == codecvt_base::noconv)
+                {
+                    __ws.resize(__to - &__ws[0]);
+                    // This only gets executed if _Elem is char
+                    __ws.append((const _Elem*)__frm, (const _Elem*)__frm_end);
+                    __frm = __frm_nxt;
+                    __r = codecvt_base::ok;
+                }
+                else if (__r == codecvt_base::ok)
+                {
+                    __ws.resize(__to_nxt - &__ws[0]);
+                    __frm = __frm_nxt;
+                }
+                else if (__r == codecvt_base::partial)
+                {
+                    ptrdiff_t __s = __to_nxt - &__ws[0];
+                    __ws.resize(2 * __s);
+                    __to = &__ws[0] + __s;
+                    __to_end = &__ws[0] + __ws.size();
+                    __frm = __frm_nxt;
+                }
+            } while (__r == codecvt_base::partial && __frm_nxt < __frm_end);
+        }
+        if (__r == codecvt_base::ok)
+            return __ws;
+    }
+#ifndef _LIBCPP_NO_EXCEPTIONS
+    if (__wide_err_string_.empty())
+        throw range_error("wstring_convert: from_bytes error");
+#endif  // _LIBCPP_NO_EXCEPTIONS
+    return __wide_err_string_;
+}
+
+template<class _Codecvt, class _Elem, class _Wide_alloc, class _Byte_alloc>
+typename wstring_convert<_Codecvt, _Elem, _Wide_alloc, _Byte_alloc>::byte_string
+wstring_convert<_Codecvt, _Elem, _Wide_alloc, _Byte_alloc>::
+    to_bytes(const _Elem* __frm, const _Elem* __frm_end)
+{
+    __cvtcount_ = 0;
+    if (__cvtptr_ != nullptr)
+    {
+        byte_string __bs(2*(__frm_end - __frm), char());
+        if (__frm != __frm_end)
+            __bs.resize(__bs.capacity());
+        codecvt_base::result __r = codecvt_base::ok;
+        state_type __st = __cvtstate_;
+        if (__frm != __frm_end)
+        {
+            char* __to = &__bs[0];
+            char* __to_end = __to + __bs.size();
+            const _Elem* __frm_nxt;
+            do
+            {
+                char* __to_nxt;
+                __r = __cvtptr_->out(__st, __frm, __frm_end, __frm_nxt,
+                                           __to, __to_end, __to_nxt);
+                __cvtcount_ += __frm_nxt - __frm;
+                if (__frm_nxt == __frm)
+                {
+                    __r = codecvt_base::error;
+                }
+                else if (__r == codecvt_base::noconv)
+                {
+                    __bs.resize(__to - &__bs[0]);
+                    // This only gets executed if _Elem is char
+                    __bs.append((const char*)__frm, (const char*)__frm_end);
+                    __frm = __frm_nxt;
+                    __r = codecvt_base::ok;
+                }
+                else if (__r == codecvt_base::ok)
+                {
+                    __bs.resize(__to_nxt - &__bs[0]);
+                    __frm = __frm_nxt;
+                }
+                else if (__r == codecvt_base::partial)
+                {
+                    ptrdiff_t __s = __to_nxt - &__bs[0];
+                    __bs.resize(2 * __s);
+                    __to = &__bs[0] + __s;
+                    __to_end = &__bs[0] + __bs.size();
+                    __frm = __frm_nxt;
+                }
+            } while (__r == codecvt_base::partial && __frm_nxt < __frm_end);
+        }
+        if (__r == codecvt_base::ok)
+        {
+            size_t __s = __bs.size();
+            __bs.resize(__bs.capacity());
+            char* __to = &__bs[0] + __s;
+            char* __to_end = __to + __bs.size();
+            do
+            {
+                char* __to_nxt;
+                __r = __cvtptr_->unshift(__st, __to, __to_end, __to_nxt);
+                if (__r == codecvt_base::noconv)
+                {
+                    __bs.resize(__to - &__bs[0]);
+                    __r = codecvt_base::ok;
+                }
+                else if (__r == codecvt_base::ok)
+                {
+                    __bs.resize(__to_nxt - &__bs[0]);
+                }
+                else if (__r == codecvt_base::partial)
+                {
+                    ptrdiff_t __sp = __to_nxt - &__bs[0];
+                    __bs.resize(2 * __sp);
+                    __to = &__bs[0] + __sp;
+                    __to_end = &__bs[0] + __bs.size();
+                }
+            } while (__r == codecvt_base::partial);
+            if (__r == codecvt_base::ok)
+                return __bs;
+        }
+    }
+#ifndef _LIBCPP_NO_EXCEPTIONS
+    if (__byte_err_string_.empty())
+        throw range_error("wstring_convert: to_bytes error");
+#endif  // _LIBCPP_NO_EXCEPTIONS
+    return __byte_err_string_;
+}
+
+template <class _Codecvt, class _Elem = wchar_t, class _Tr = char_traits<_Elem> >
+class _LIBCPP_TYPE_VIS_ONLY wbuffer_convert
+    : public basic_streambuf<_Elem, _Tr>
+{
+public:
+    // types:
+    typedef _Elem                          char_type;
+    typedef _Tr                            traits_type;
+    typedef typename traits_type::int_type int_type;
+    typedef typename traits_type::pos_type pos_type;
+    typedef typename traits_type::off_type off_type;
+    typedef typename _Codecvt::state_type  state_type;
+
+private:
+    char*       __extbuf_;
+    const char* __extbufnext_;
+    const char* __extbufend_;
+    char __extbuf_min_[8];
+    size_t __ebs_;
+    char_type* __intbuf_;
+    size_t __ibs_;
+    streambuf* __bufptr_;
+    _Codecvt* __cv_;
+    state_type __st_;
+    ios_base::openmode __cm_;
+    bool __owns_eb_;
+    bool __owns_ib_;
+    bool __always_noconv_;
+
+    wbuffer_convert(const wbuffer_convert&);
+    wbuffer_convert& operator=(const wbuffer_convert&);
+public:
+    _LIBCPP_EXPLICIT_AFTER_CXX11 wbuffer_convert(streambuf* __bytebuf = 0, 
+            _Codecvt* __pcvt = new _Codecvt, state_type __state = state_type());
+    ~wbuffer_convert();
+
+    _LIBCPP_INLINE_VISIBILITY
+    streambuf* rdbuf() const {return __bufptr_;}
+    _LIBCPP_INLINE_VISIBILITY
+    streambuf* rdbuf(streambuf* __bytebuf)
+    {
+        streambuf* __r = __bufptr_;
+        __bufptr_ = __bytebuf;
+        return __r;
+    }
+
+    _LIBCPP_INLINE_VISIBILITY
+    state_type state() const {return __st_;}
+
+protected:
+    virtual int_type underflow();
+    virtual int_type pbackfail(int_type __c = traits_type::eof());
+    virtual int_type overflow (int_type __c = traits_type::eof());
+    virtual basic_streambuf<char_type, traits_type>* setbuf(char_type* __s,
+                                                            streamsize __n);
+    virtual pos_type seekoff(off_type __off, ios_base::seekdir __way,
+                             ios_base::openmode __wch = ios_base::in | ios_base::out);
+    virtual pos_type seekpos(pos_type __sp,
+                             ios_base::openmode __wch = ios_base::in | ios_base::out);
+    virtual int sync();
+
+private:
+    bool __read_mode();
+    void __write_mode();
+    wbuffer_convert* __close();
+};
+
+template <class _Codecvt, class _Elem, class _Tr>
+wbuffer_convert<_Codecvt, _Elem, _Tr>::
+    wbuffer_convert(streambuf* __bytebuf, _Codecvt* __pcvt, state_type __state)
+    : __extbuf_(0),
+      __extbufnext_(0),
+      __extbufend_(0),
+      __ebs_(0),
+      __intbuf_(0),
+      __ibs_(0),
+      __bufptr_(__bytebuf),
+      __cv_(__pcvt),
+      __st_(__state),
+      __cm_(0),
+      __owns_eb_(false),
+      __owns_ib_(false),
+      __always_noconv_(__cv_ ? __cv_->always_noconv() : false)
+{
+    setbuf(0, 4096);
+}
+
+template <class _Codecvt, class _Elem, class _Tr>
+wbuffer_convert<_Codecvt, _Elem, _Tr>::~wbuffer_convert()
+{
+    __close();
+    delete __cv_;
+    if (__owns_eb_)
+        delete [] __extbuf_;
+    if (__owns_ib_)
+        delete [] __intbuf_;
+}
+
+template <class _Codecvt, class _Elem, class _Tr>
+typename wbuffer_convert<_Codecvt, _Elem, _Tr>::int_type
+wbuffer_convert<_Codecvt, _Elem, _Tr>::underflow()
+{
+    if (__cv_ == 0 || __bufptr_ == 0)
+        return traits_type::eof();
+    bool __initial = __read_mode();
+    char_type __1buf;
+    if (this->gptr() == 0)
+        this->setg(&__1buf, &__1buf+1, &__1buf+1);
+    const size_t __unget_sz = __initial ? 0 : min<size_t>((this->egptr() - this->eback()) / 2, 4);
+    int_type __c = traits_type::eof();
+    if (this->gptr() == this->egptr())
+    {
+        memmove(this->eback(), this->egptr() - __unget_sz, __unget_sz * sizeof(char_type));
+        if (__always_noconv_)
+        {
+            streamsize __nmemb = static_cast<streamsize>(this->egptr() - this->eback() - __unget_sz);
+            __nmemb = __bufptr_->sgetn((char*)this->eback() + __unget_sz, __nmemb);
+            if (__nmemb != 0)
+            {
+                this->setg(this->eback(),
+                           this->eback() + __unget_sz,
+                           this->eback() + __unget_sz + __nmemb);
+                __c = *this->gptr();
+            }
+        }
+        else
+        {
+            memmove(__extbuf_, __extbufnext_, __extbufend_ - __extbufnext_);
+            __extbufnext_ = __extbuf_ + (__extbufend_ - __extbufnext_);
+            __extbufend_ = __extbuf_ + (__extbuf_ == __extbuf_min_ ? sizeof(__extbuf_min_) : __ebs_);
+            streamsize __nmemb = _VSTD::min(static_cast<streamsize>(this->egptr() - this->eback() - __unget_sz),
+                                 static_cast<streamsize>(__extbufend_ - __extbufnext_));
+            codecvt_base::result __r;
+            state_type __svs = __st_;
+            streamsize __nr = __bufptr_->sgetn(const_cast<char*>(__extbufnext_), __nmemb);
+            if (__nr != 0)
+            {
+                __extbufend_ = __extbufnext_ + __nr;
+                char_type*  __inext;
+                __r = __cv_->in(__st_, __extbuf_, __extbufend_, __extbufnext_,
+                                       this->eback() + __unget_sz,
+                                       this->egptr(), __inext);
+                if (__r == codecvt_base::noconv)
+                {
+                    this->setg((char_type*)__extbuf_, (char_type*)__extbuf_, (char_type*)__extbufend_);
+                    __c = *this->gptr();
+                }
+                else if (__inext != this->eback() + __unget_sz)
+                {
+                    this->setg(this->eback(), this->eback() + __unget_sz, __inext);
+                    __c = *this->gptr();
+                }
+            }
+        }
+    }
+    else
+        __c = *this->gptr();
+    if (this->eback() == &__1buf)
+        this->setg(0, 0, 0);
+    return __c;
+}
+
+template <class _Codecvt, class _Elem, class _Tr>
+typename wbuffer_convert<_Codecvt, _Elem, _Tr>::int_type
+wbuffer_convert<_Codecvt, _Elem, _Tr>::pbackfail(int_type __c)
+{
+    if (__cv_ != 0 && __bufptr_ != 0 && this->eback() < this->gptr())
+    {
+        if (traits_type::eq_int_type(__c, traits_type::eof()))
+        {
+            this->gbump(-1);
+            return traits_type::not_eof(__c);
+        }
+        if (traits_type::eq(traits_type::to_char_type(__c), this->gptr()[-1]))
+        {
+            this->gbump(-1);
+            *this->gptr() = traits_type::to_char_type(__c);
+            return __c;
+        }
+    }
+    return traits_type::eof();
+}
+
+template <class _Codecvt, class _Elem, class _Tr>
+typename wbuffer_convert<_Codecvt, _Elem, _Tr>::int_type
+wbuffer_convert<_Codecvt, _Elem, _Tr>::overflow(int_type __c)
+{
+    if (__cv_ == 0 || __bufptr_ == 0)
+        return traits_type::eof();
+    __write_mode();
+    char_type __1buf;
+    char_type* __pb_save = this->pbase();
+    char_type* __epb_save = this->epptr();
+    if (!traits_type::eq_int_type(__c, traits_type::eof()))
+    {
+        if (this->pptr() == 0)
+            this->setp(&__1buf, &__1buf+1);
+        *this->pptr() = traits_type::to_char_type(__c);
+        this->pbump(1);
+    }
+    if (this->pptr() != this->pbase())
+    {
+        if (__always_noconv_)
+        {
+            streamsize __nmemb = static_cast<streamsize>(this->pptr() - this->pbase());
+            if (__bufptr_->sputn((const char*)this->pbase(), __nmemb) != __nmemb)
+                return traits_type::eof();
+        }
+        else
+        {
+            char* __extbe = __extbuf_;
+            codecvt_base::result __r;
+            do
+            {
+                const char_type* __e;
+                __r = __cv_->out(__st_, this->pbase(), this->pptr(), __e,
+                                        __extbuf_, __extbuf_ + __ebs_, __extbe);
+                if (__e == this->pbase())
+                    return traits_type::eof();
+                if (__r == codecvt_base::noconv)
+                {
+                    streamsize __nmemb = static_cast<size_t>(this->pptr() - this->pbase());
+                    if (__bufptr_->sputn((const char*)this->pbase(), __nmemb) != __nmemb)
+                        return traits_type::eof();
+                }
+                else if (__r == codecvt_base::ok || __r == codecvt_base::partial)
+                {
+                    streamsize __nmemb = static_cast<size_t>(__extbe - __extbuf_);
+                    if (__bufptr_->sputn(__extbuf_, __nmemb) != __nmemb)
+                        return traits_type::eof();
+                    if (__r == codecvt_base::partial)
+                    {
+                        this->setp((char_type*)__e, this->pptr());
+                        this->pbump(this->epptr() - this->pbase());
+                    }
+                }
+                else
+                    return traits_type::eof();
+            } while (__r == codecvt_base::partial);
+        }
+        this->setp(__pb_save, __epb_save);
+    }
+    return traits_type::not_eof(__c);
+}
+
+template <class _Codecvt, class _Elem, class _Tr>
+basic_streambuf<_Elem, _Tr>*
+wbuffer_convert<_Codecvt, _Elem, _Tr>::setbuf(char_type* __s, streamsize __n)
+{
+    this->setg(0, 0, 0);
+    this->setp(0, 0);
+    if (__owns_eb_)
+        delete [] __extbuf_;
+    if (__owns_ib_)
+        delete [] __intbuf_;
+    __ebs_ = __n;
+    if (__ebs_ > sizeof(__extbuf_min_))
+    {
+        if (__always_noconv_ && __s)
+        {
+            __extbuf_ = (char*)__s;
+            __owns_eb_ = false;
+        }
+        else
+        {
+            __extbuf_ = new char[__ebs_];
+            __owns_eb_ = true;
+        }
+    }
+    else
+    {
+        __extbuf_ = __extbuf_min_;
+        __ebs_ = sizeof(__extbuf_min_);
+        __owns_eb_ = false;
+    }
+    if (!__always_noconv_)
+    {
+        __ibs_ = max<streamsize>(__n, sizeof(__extbuf_min_));
+        if (__s && __ibs_ >= sizeof(__extbuf_min_))
+        {
+            __intbuf_ = __s;
+            __owns_ib_ = false;
+        }
+        else
+        {
+            __intbuf_ = new char_type[__ibs_];
+            __owns_ib_ = true;
+        }
+    }
+    else
+    {
+        __ibs_ = 0;
+        __intbuf_ = 0;
+        __owns_ib_ = false;
+    }
+    return this;
+}
+
+template <class _Codecvt, class _Elem, class _Tr>
+typename wbuffer_convert<_Codecvt, _Elem, _Tr>::pos_type
+wbuffer_convert<_Codecvt, _Elem, _Tr>::seekoff(off_type __off, ios_base::seekdir __way,
+                                        ios_base::openmode __om)
+{
+    int __width = __cv_->encoding();
+    if (__cv_ == 0 || __bufptr_ == 0 || (__width <= 0 && __off != 0) || sync())
+        return pos_type(off_type(-1));
+    // __width > 0 || __off == 0
+    switch (__way)
+    {
+    case ios_base::beg:
+        break;
+    case ios_base::cur:
+        break;
+    case ios_base::end:
+        break;
+    default:
+        return pos_type(off_type(-1));
+    }
+    pos_type __r = __bufptr_->pubseekoff(__width * __off, __way, __om);
+    __r.state(__st_);
+    return __r;
+}
+
+template <class _Codecvt, class _Elem, class _Tr>
+typename wbuffer_convert<_Codecvt, _Elem, _Tr>::pos_type
+wbuffer_convert<_Codecvt, _Elem, _Tr>::seekpos(pos_type __sp, ios_base::openmode __wch)
+{
+    if (__cv_ == 0 || __bufptr_ == 0 || sync())
+        return pos_type(off_type(-1));
+    if (__bufptr_->pubseekpos(__sp, __wch) == pos_type(off_type(-1)))
+        return pos_type(off_type(-1));
+    return __sp;
+}
+
+template <class _Codecvt, class _Elem, class _Tr>
+int
+wbuffer_convert<_Codecvt, _Elem, _Tr>::sync()
+{
+    if (__cv_ == 0 || __bufptr_ == 0)
+        return 0;
+    if (__cm_ & ios_base::out)
+    {
+        if (this->pptr() != this->pbase())
+            if (overflow() == traits_type::eof())
+                return -1;
+        codecvt_base::result __r;
+        do
+        {
+            char* __extbe;
+            __r = __cv_->unshift(__st_, __extbuf_, __extbuf_ + __ebs_, __extbe);
+            streamsize __nmemb = static_cast<streamsize>(__extbe - __extbuf_);
+            if (__bufptr_->sputn(__extbuf_, __nmemb) != __nmemb)
+                return -1;
+        } while (__r == codecvt_base::partial);
+        if (__r == codecvt_base::error)
+            return -1;
+        if (__bufptr_->pubsync())
+            return -1;
+    }
+    else if (__cm_ & ios_base::in)
+    {
+        off_type __c;
+        if (__always_noconv_)
+            __c = this->egptr() - this->gptr();
+        else
+        {
+            int __width = __cv_->encoding();
+            __c = __extbufend_ - __extbufnext_;
+            if (__width > 0)
+                __c += __width * (this->egptr() - this->gptr());
+            else
+            {
+                if (this->gptr() != this->egptr())
+                {
+                    reverse(this->gptr(), this->egptr());
+                    codecvt_base::result __r;
+                    const char_type* __e = this->gptr();
+                    char* __extbe;
+                    do
+                    {
+                        __r = __cv_->out(__st_, __e, this->egptr(), __e,
+                                         __extbuf_, __extbuf_ + __ebs_, __extbe);
+                        switch (__r)
+                        {
+                        case codecvt_base::noconv:
+                            __c += this->egptr() - this->gptr();
+                            break;
+                        case codecvt_base::ok:
+                        case codecvt_base::partial:
+                            __c += __extbe - __extbuf_;
+                            break;
+                        default:
+                            return -1;
+                        }
+                    } while (__r == codecvt_base::partial);
+                }
+            }
+        }
+        if (__bufptr_->pubseekoff(-__c, ios_base::cur, __cm_) == pos_type(off_type(-1)))
+            return -1;
+        this->setg(0, 0, 0);
+        __cm_ = 0;
+    }
+    return 0;
+}
+
+template <class _Codecvt, class _Elem, class _Tr>
+bool
+wbuffer_convert<_Codecvt, _Elem, _Tr>::__read_mode()
+{
+    if (!(__cm_ & ios_base::in))
+    {
+        this->setp(0, 0);
+        if (__always_noconv_)
+            this->setg((char_type*)__extbuf_,
+                       (char_type*)__extbuf_ + __ebs_,
+                       (char_type*)__extbuf_ + __ebs_);
+        else
+            this->setg(__intbuf_, __intbuf_ + __ibs_, __intbuf_ + __ibs_);
+        __cm_ = ios_base::in;
+        return true;
+    }
+    return false;
+}
+
+template <class _Codecvt, class _Elem, class _Tr>
+void
+wbuffer_convert<_Codecvt, _Elem, _Tr>::__write_mode()
+{
+    if (!(__cm_ & ios_base::out))
+    {
+        this->setg(0, 0, 0);
+        if (__ebs_ > sizeof(__extbuf_min_))
+        {
+            if (__always_noconv_)
+                this->setp((char_type*)__extbuf_,
+                           (char_type*)__extbuf_ + (__ebs_ - 1));
+            else
+                this->setp(__intbuf_, __intbuf_ + (__ibs_ - 1));
+        }
+        else
+            this->setp(0, 0);
+        __cm_ = ios_base::out;
+    }
+}
+
+template <class _Codecvt, class _Elem, class _Tr>
+wbuffer_convert<_Codecvt, _Elem, _Tr>*
+wbuffer_convert<_Codecvt, _Elem, _Tr>::__close()
+{
+    wbuffer_convert* __rt = 0;
+    if (__cv_ != 0 && __bufptr_ != 0)
+    {
+        __rt = this;
+        if ((__cm_ & ios_base::out) && sync())
+            __rt = 0;
+    }
+    return __rt;
+}
+
+_LIBCPP_END_NAMESPACE_STD
+
+#endif  // _LIBCPP_LOCALE
diff -uNr libcxx-3.7.0.src.orig/lib/CMakeLists.txt libcxx-3.7.0.src/lib/CMakeLists.txt
--- libcxx-3.7.0.src.orig/lib/CMakeLists.txt	2015-03-31 21:43:06.000000000 -0400
+++ libcxx-3.7.0.src/lib/CMakeLists.txt	2015-07-04 22:36:16.000000000 -0400
@@ -79,7 +79,22 @@
     set(LIBCXX_LIBCPPABI_VERSION "2")
   endif()
 
-  if ( CMAKE_OSX_DEPLOYMENT_TARGET STREQUAL "10.6" )
+  if ( CMAKE_OSX_DEPLOYMENT_TARGET VERSION_LESS "10.6" )
+    # libc++ must be built with clang++
+    execute_process(COMMAND ${CMAKE_CXX_COMPILER} -print-search-dirs
+      COMMAND grep "libraries:"
+      COMMAND cut -d= -f2
+      OUTPUT_VARIABLE CXX_LIBDIR
+      OUTPUT_STRIP_TRAILING_WHITESPACE
+    )
+    list(APPEND LIBCXX_LINK_FLAGS
+      "-compatibility_version 1"
+      "-Wl,-unexported_symbols_list,${CMAKE_CURRENT_SOURCE_DIR}/libc++unexp.exp"
+      "-lgcc_s.${CMAKE_OSX_DEPLOYMENT_TARGET}"
+      "${CXX_LIBDIR}/lib/darwin/libclang_rt.builtins-${CMAKE_OSX_ARCHITECTURES}.a"
+      "/usr/lib/libSystem.B.dylib"
+      "-lSystemStubs" )
+  elseif ( CMAKE_OSX_DEPLOYMENT_TARGET STREQUAL "10.6" )
     list(APPEND LIBCXX_COMPILE_FLAGS "-U__STRICT_ANSI__")
     list(APPEND LIBCXX_LINK_FLAGS
       "-compatibility_version 1"
@@ -87,6 +102,7 @@
       "-install_name /usr/lib/libc++.1.dylib"
       "-Wl,-reexport_library,/usr/lib/libc++abi.dylib"
       "-Wl,-unexported_symbols_list,${CMAKE_CURRENT_SOURCE_DIR}/libc++unexp.exp"
+      "-lgcc_s.1"
       "/usr/lib/libSystem.B.dylib")
   else()
     if ( ${CMAKE_OSX_SYSROOT} )
@@ -100,6 +116,7 @@
           "-Wl,-reexport_library,${CMAKE_OSX_SYSROOT}/usr/lib/libc++abi.dylib")
       endif()
     else()
+      # FIXME: hard-coded libc++abi.dylib location doesn't work for me
       set (OSX_RE_EXPORT_LINE "/usr/lib/libc++abi.dylib -Wl,-reexported_symbols_list,${CMAKE_CURRENT_SOURCE_DIR}/libc++abi${LIBCXX_LIBCPPABI_VERSION}.exp")
     endif()
 
diff -uNr libcxx-3.7.0.src.orig/src/exception.cpp libcxx-3.7.0.src/src/exception.cpp
--- libcxx-3.7.0.src.orig/src/exception.cpp	2015-06-02 18:36:42.000000000 -0400
+++ libcxx-3.7.0.src/src/exception.cpp	2015-07-04 22:37:44.000000000 -0400
@@ -16,7 +16,8 @@
 #define __has_include(inc) 0
 #endif
 
-#if defined(__APPLE__) && !defined(LIBCXXRT)
+// darwin8: there is no __cxxabiapple namespace anywhere
+#if defined(__APPLE__) && !defined(LIBCXXRT) && !defined(DARWIN_LIBSUPCXX)
   #include <cxxabi.h>
 
   using namespace __cxxabiv1;
@@ -31,6 +32,12 @@
   #endif  // _LIBCPPABI_VERSION
 #elif defined(LIBCXXRT) || defined(LIBCXX_BUILDING_LIBCXXABI) || __has_include(<cxxabi.h>)
   #include <cxxabi.h>
+  #if defined(DARWIN_LIBSUPCXX)
+  namespace __cxxabiv1 {
+    extern std::terminate_handler  __terminate_handler;
+    extern std::unexpected_handler __unexpected_handler;
+  }
+  #endif
   using namespace __cxxabiv1;
   #if defined(LIBCXXRT) || defined(_LIBCPPABI_VERSION)
     #define HAVE_DEPENDENT_EH_ABI 1
@@ -40,10 +47,18 @@
   static std::unexpected_handler __unexpected_handler;
 #endif // __has_include(<cxxabi.h>)
 
+#if defined(__APPLE__) && defined(DARWIN_LIBSUPCXX)
+// should clang provide -DPIC
+#define	PIC	1
+#include <bits/os_defines.h>
+// see https://www.opensource.apple.com/source/libstdcxx/libstdcxx-39/libstdcxx/libstdc++-v3/libsupc++/eh_terminate.cc
+#endif
+
 namespace std
 {
 
-#if !defined(LIBCXXRT) && !defined(_LIBCPPABI_VERSION) && !defined(__GLIBCXX__)
+#define	__PRED__	!defined(LIBCXXRT) && !defined(_LIBCPPABI_VERSION) && !defined(__GLIBCXX__)
+#if __PRED__
 
 // libcxxrt provides implementations of these functions itself.
 unexpected_handler
@@ -51,13 +66,22 @@
 {
     return __sync_lock_test_and_set(&__unexpected_handler, func);
 }
-
+#endif
+#if __PRED__ || defined(DARWIN_LIBSUPCXX)
 unexpected_handler
 get_unexpected() _NOEXCEPT
 {
+#if defined(__APPLE__) && defined(__ppc__) && defined(PIC)
+    const std::unexpected_handler
+	old(reinterpret_cast<std::unexpected_handler>(
+		_keymgr_get_per_thread_data(KEYMGR_UNEXPECTED_HANDLER_KEY)));
+    return old ? old : __unexpected_handler;
+#else
     return __sync_fetch_and_add(&__unexpected_handler, (unexpected_handler)0);
+#endif /* __APPLE__ etc. */
 }
-
+#endif
+#if __PRED__
 _LIBCPP_NORETURN
 void
 unexpected()
@@ -73,12 +97,23 @@
     return __sync_lock_test_and_set(&__terminate_handler, func);
 }
 
+#endif
+#if __PRED__ || defined(DARWIN_LIBSUPCXX)
 terminate_handler
 get_terminate() _NOEXCEPT
 {
+// FIXME: see https://www.opensource.apple.com/source/libstdcxx/libstdcxx-39/libstdcxx/libstdc++-v3/libsupc++/eh_terminate.cc
+#if defined(__APPLE__) && defined(__ppc__) && defined(PIC)
+    const std::terminate_handler
+	old(reinterpret_cast<std::terminate_handler>(
+		_keymgr_get_per_thread_data(KEYMGR_TERMINATE_HANDLER_KEY)));
+    return old ? old : __terminate_handler;
+#else
     return __sync_fetch_and_add(&__terminate_handler, (terminate_handler)0);
+#endif
 }
-
+#endif
+#if __PRED__
 #ifndef __EMSCRIPTEN__ // We provide this in JS
 _LIBCPP_NORETURN
 void
@@ -104,8 +139,10 @@
 }
 #endif // !__EMSCRIPTEN__
 #endif // !defined(LIBCXXRT) && !defined(_LIBCPPABI_VERSION)
+#undef        __PRED__
 
 #if !defined(LIBCXXRT) && !defined(__GLIBCXX__) && !defined(__EMSCRIPTEN__)
+#if !defined(DARWIN_LIBSUPCXX)
 bool uncaught_exception() _NOEXCEPT { return uncaught_exceptions() > 0; }
 
 int uncaught_exceptions() _NOEXCEPT
@@ -127,6 +164,7 @@
     ::abort();
 #endif  // __APPLE__
 }
+#endif
 
 
 #ifndef _LIBCPPABI_VERSION
@@ -147,7 +185,8 @@
 bad_exception::~bad_exception() _NOEXCEPT
 {
 }
-
+#endif
+#if !defined(_LIBCPPABI_VERSION) && !defined(__GLIBCXX__) || (defined(DARWIN_LIBSUPCXX) && DARWIN_LIBSUPCXX < 10)
 const char* bad_exception::what() const _NOEXCEPT
 {
   return "std::bad_exception";
@@ -155,7 +194,9 @@
 
 #endif
 
-#if defined(__GLIBCXX__)
+#define	GLIBCXX_HAS___EXCEPTION_PTR		!defined(DARWIN_LIBSUPCXX)
+
+#if defined(__GLIBCXX__) && GLIBCXX_HAS___EXCEPTION_PTR
 
 // libsupc++ does not implement the dependent EH ABI and the functionality
 // it uses to implement std::exception_ptr (which it declares as an alias of
@@ -188,7 +229,7 @@
 {
 #if HAVE_DEPENDENT_EH_ABI
     __cxa_decrement_exception_refcount(__ptr_);
-#elif defined(__GLIBCXX__)
+#elif defined(__GLIBCXX__) && GLIBCXX_HAS___EXCEPTION_PTR
     reinterpret_cast<__exception_ptr::exception_ptr*>(this)->~exception_ptr();
 #else
 #   if defined(_MSC_VER) && ! defined(__clang__)
@@ -206,7 +247,7 @@
 {
 #if HAVE_DEPENDENT_EH_ABI
     __cxa_increment_exception_refcount(__ptr_);
-#elif defined(__GLIBCXX__)
+#elif defined(__GLIBCXX__) && GLIBCXX_HAS___EXCEPTION_PTR
     new (reinterpret_cast<void*>(this)) __exception_ptr::exception_ptr(
         reinterpret_cast<const __exception_ptr::exception_ptr&>(other));
 #else
@@ -230,7 +271,7 @@
         __ptr_ = other.__ptr_;
     }
     return *this;
-#elif defined(__GLIBCXX__)
+#elif defined(__GLIBCXX__) && GLIBCXX_HAS___EXCEPTION_PTR
     *reinterpret_cast<__exception_ptr::exception_ptr*>(this) =
         reinterpret_cast<const __exception_ptr::exception_ptr&>(other);
     return *this;
@@ -250,7 +291,7 @@
 {
 }
 
-#if !defined(__GLIBCXX__)
+#if !defined(__GLIBCXX__) || defined(DARWIN_LIBSUPCXX)
 
 nested_exception::~nested_exception() _NOEXCEPT
 {
@@ -267,7 +308,7 @@
     rethrow_exception(__ptr_);
 }
 
-#if !defined(__GLIBCXX__)
+#if !defined(__GLIBCXX__) || defined(DARWIN_LIBSUPCXX)
 
 exception_ptr current_exception() _NOEXCEPT
 {
@@ -298,7 +339,7 @@
     __cxa_rethrow_primary_exception(p.__ptr_);
     // if p.__ptr_ is NULL, above returns so we terminate
     terminate();
-#elif defined(__GLIBCXX__)
+#elif defined(__GLIBCXX__) && GLIBCXX_HAS___EXCEPTION_PTR
     rethrow_exception(reinterpret_cast<__exception_ptr::exception_ptr&>(p));
 #else
 #   if defined(_MSC_VER) && ! defined(__clang__)
diff -uNr libcxx-3.7.0.src.orig/src/new.cpp libcxx-3.7.0.src/src/new.cpp
--- libcxx-3.7.0.src.orig/src/new.cpp	2015-05-18 17:21:07.000000000 -0400
+++ libcxx-3.7.0.src/src/new.cpp	2015-07-04 22:33:31.000000000 -0400
@@ -17,7 +17,7 @@
 #define __has_include(inc) 0
 #endif
 
-#if defined(__APPLE__) && !defined(LIBCXXRT)
+#if defined(__APPLE__) && !defined(LIBCXXRT) && !defined(DARWIN_LIBSUPCXX)
     #include <cxxabi.h>
 
     #ifndef _LIBCPPABI_VERSION
@@ -30,11 +30,21 @@
     #if defined(LIBCXXRT) || __has_include(<cxxabi.h>)
         #include <cxxabi.h>
     #endif  // __has_include(<cxxabi.h>)
+    #if defined(DARWIN_LIBSUPCXX)
+        extern std::new_handler	__new_handler;
+    #endif
     #if !defined(_LIBCPPABI_VERSION) && !defined(__GLIBCXX__)
         static std::new_handler __new_handler;
     #endif  // _LIBCPPABI_VERSION
 #endif
 
+#if defined(__APPLE__) && defined(DARWIN_LIBSUPCXX)
+// should clang provide -DPIC
+#define	PIC	1
+#include <bits/os_defines.h>
+// see https://www.opensource.apple.com/source/libstdcxx/libstdcxx-39/libstdcxx/libstdc++-v3/libsupc++/new_handler.cc
+#endif
+
 #ifndef __GLIBCXX__
 
 // Implement all new and delete operators as weak definitions
@@ -164,9 +174,11 @@
 namespace std
 {
 
+#if	!defined(DARWIN_LIBSUPCXX)
 #ifndef __GLIBCXX__
 const nothrow_t nothrow = {};
 #endif
+#endif
 
 #ifndef _LIBCPPABI_VERSION
 
@@ -177,11 +189,20 @@
 {
     return __sync_lock_test_and_set(&__new_handler, handler);
 }
-
+#endif
+#if !defined(__GLIBCXX__) || defined(DARWIN_LIBSUPCXX)
 new_handler
 get_new_handler() _NOEXCEPT
 {
+/* APPLE LOCAL begin keymgr */
+#if defined(__APPLE__) && defined(__ppc__) && defined(PIC)
+    const new_handler prev_handler(reinterpret_cast<new_handler>(
+	_keymgr_get_per_thread_data(KEYMGR_NEW_HANDLER_KEY)));
+    return prev_handler ? prev_handler : __new_handler;
+#else	/* __APPLE__ etc. */
     return __sync_fetch_and_add(&__new_handler, nullptr);
+#endif	/* __APPLE__ etc. */
+/* APPLE LOCAL end keymgr */
 }
 
 #endif // !__GLIBCXX__
@@ -197,7 +218,9 @@
 bad_alloc::~bad_alloc() _NOEXCEPT
 {
 }
+#endif // !__GLIBCXX__
 
+#if !defined(__GLIBCXX__) || (defined(DARWIN_LIBSUPCXX) && DARWIN_LIBSUPCXX < 10)
 const char*
 bad_alloc::what() const _NOEXCEPT
 {
diff -uNr libcxx-3.7.0.src.orig/src/new.cpp.orig libcxx-3.7.0.src/src/new.cpp.orig
--- libcxx-3.7.0.src.orig/src/new.cpp.orig	1969-12-31 19:00:00.000000000 -0500
+++ libcxx-3.7.0.src/src/new.cpp.orig	2015-05-18 17:21:07.000000000 -0400
@@ -0,0 +1,253 @@
+//===--------------------------- new.cpp ----------------------------------===//
+//
+//                     The LLVM Compiler Infrastructure
+//
+// This file is dual licensed under the MIT and the University of Illinois Open
+// Source Licenses. See LICENSE.TXT for details.
+//
+//===----------------------------------------------------------------------===//
+
+#define _LIBCPP_BUILDING_NEW
+
+#include <stdlib.h>
+
+#include "new"
+
+#ifndef __has_include
+#define __has_include(inc) 0
+#endif
+
+#if defined(__APPLE__) && !defined(LIBCXXRT)
+    #include <cxxabi.h>
+
+    #ifndef _LIBCPPABI_VERSION
+        // On Darwin, there are two STL shared libraries and a lower level ABI
+        // shared library.  The global holding the current new handler is
+        // in the ABI library and named __cxa_new_handler.
+        #define __new_handler __cxxabiapple::__cxa_new_handler
+    #endif
+#else  // __APPLE__
+    #if defined(LIBCXXRT) || __has_include(<cxxabi.h>)
+        #include <cxxabi.h>
+    #endif  // __has_include(<cxxabi.h>)
+    #if !defined(_LIBCPPABI_VERSION) && !defined(__GLIBCXX__)
+        static std::new_handler __new_handler;
+    #endif  // _LIBCPPABI_VERSION
+#endif
+
+#ifndef __GLIBCXX__
+
+// Implement all new and delete operators as weak definitions
+// in this shared library, so that they can be overriden by programs
+// that define non-weak copies of the functions.
+
+_LIBCPP_WEAK _LIBCPP_NEW_DELETE_VIS
+void *
+operator new(std::size_t size)
+#if !__has_feature(cxx_noexcept)
+    throw(std::bad_alloc)
+#endif
+{
+    if (size == 0)
+        size = 1;
+    void* p;
+    while ((p = ::malloc(size)) == 0)
+    {
+        // If malloc fails and there is a new_handler,
+        // call it to try free up memory.
+        std::new_handler nh = std::get_new_handler();
+        if (nh)
+            nh();
+        else
+#ifndef _LIBCPP_NO_EXCEPTIONS
+            throw std::bad_alloc();
+#else
+            break;
+#endif
+    }
+    return p;
+}
+
+_LIBCPP_WEAK _LIBCPP_NEW_DELETE_VIS
+void*
+operator new(size_t size, const std::nothrow_t&) _NOEXCEPT
+{
+    void* p = 0;
+#ifndef _LIBCPP_NO_EXCEPTIONS
+    try
+    {
+#endif  // _LIBCPP_NO_EXCEPTIONS
+        p = ::operator new(size);
+#ifndef _LIBCPP_NO_EXCEPTIONS
+    }
+    catch (...)
+    {
+    }
+#endif  // _LIBCPP_NO_EXCEPTIONS
+    return p;
+}
+
+_LIBCPP_WEAK _LIBCPP_NEW_DELETE_VIS
+void*
+operator new[](size_t size)
+#if !__has_feature(cxx_noexcept)
+    throw(std::bad_alloc)
+#endif
+{
+    return ::operator new(size);
+}
+
+_LIBCPP_WEAK _LIBCPP_NEW_DELETE_VIS
+void*
+operator new[](size_t size, const std::nothrow_t&) _NOEXCEPT
+{
+    void* p = 0;
+#ifndef _LIBCPP_NO_EXCEPTIONS
+    try
+    {
+#endif  // _LIBCPP_NO_EXCEPTIONS
+        p = ::operator new[](size);
+#ifndef _LIBCPP_NO_EXCEPTIONS
+    }
+    catch (...)
+    {
+    }
+#endif  // _LIBCPP_NO_EXCEPTIONS
+    return p;
+}
+
+_LIBCPP_WEAK _LIBCPP_NEW_DELETE_VIS
+void
+operator delete(void* ptr) _NOEXCEPT
+{
+    if (ptr)
+        ::free(ptr);
+}
+
+_LIBCPP_WEAK _LIBCPP_NEW_DELETE_VIS
+void
+operator delete(void* ptr, const std::nothrow_t&) _NOEXCEPT
+{
+    ::operator delete(ptr);
+}
+
+_LIBCPP_WEAK _LIBCPP_NEW_DELETE_VIS
+void
+operator delete(void* ptr, size_t) _NOEXCEPT
+{
+    ::operator delete(ptr);
+}
+
+_LIBCPP_WEAK _LIBCPP_NEW_DELETE_VIS
+void
+operator delete[] (void* ptr) _NOEXCEPT
+{
+    ::operator delete(ptr);
+}
+
+_LIBCPP_WEAK _LIBCPP_NEW_DELETE_VIS
+void
+operator delete[] (void* ptr, const std::nothrow_t&) _NOEXCEPT
+{
+    ::operator delete[](ptr);
+}
+
+_LIBCPP_WEAK _LIBCPP_NEW_DELETE_VIS
+void
+operator delete[] (void* ptr, size_t) _NOEXCEPT
+{
+    ::operator delete[](ptr);
+}
+
+#endif // !__GLIBCXX__
+
+namespace std
+{
+
+#ifndef __GLIBCXX__
+const nothrow_t nothrow = {};
+#endif
+
+#ifndef _LIBCPPABI_VERSION
+
+#ifndef __GLIBCXX__
+
+new_handler
+set_new_handler(new_handler handler) _NOEXCEPT
+{
+    return __sync_lock_test_and_set(&__new_handler, handler);
+}
+
+new_handler
+get_new_handler() _NOEXCEPT
+{
+    return __sync_fetch_and_add(&__new_handler, nullptr);
+}
+
+#endif // !__GLIBCXX__
+
+#ifndef LIBCXXRT
+
+bad_alloc::bad_alloc() _NOEXCEPT
+{
+}
+
+#ifndef __GLIBCXX__
+
+bad_alloc::~bad_alloc() _NOEXCEPT
+{
+}
+
+const char*
+bad_alloc::what() const _NOEXCEPT
+{
+    return "std::bad_alloc";
+}
+
+#endif // !__GLIBCXX__
+
+bad_array_new_length::bad_array_new_length() _NOEXCEPT
+{
+}
+
+bad_array_new_length::~bad_array_new_length() _NOEXCEPT
+{
+}
+
+const char*
+bad_array_new_length::what() const _NOEXCEPT
+{
+    return "bad_array_new_length";
+}
+
+#endif //LIBCXXRT
+
+const char*
+bad_array_length::what() const _NOEXCEPT
+{
+    return "bad_array_length";
+}
+
+bad_array_length::bad_array_length() _NOEXCEPT
+{
+}
+
+bad_array_length::~bad_array_length() _NOEXCEPT
+{
+}
+
+#endif // _LIBCPPABI_VERSION
+
+#ifndef LIBSTDCXX
+
+void
+__throw_bad_alloc()
+{
+#ifndef _LIBCPP_NO_EXCEPTIONS
+    throw bad_alloc();
+#endif
+}
+
+#endif // !LIBSTDCXX
+
+}  // std
diff -uNr libcxx-3.7.0.src.orig/src/typeinfo.cpp libcxx-3.7.0.src/src/typeinfo.cpp
--- libcxx-3.7.0.src.orig/src/typeinfo.cpp	2014-11-20 08:33:02.000000000 -0500
+++ libcxx-3.7.0.src/src/typeinfo.cpp	2015-07-04 22:33:31.000000000 -0400
@@ -35,23 +35,29 @@
 std::bad_cast::~bad_cast() _NOEXCEPT
 {
 }
+#endif
 
+#if !defined(__GLIBCXX__) || (defined(DARWIN_LIBSUPCXX) && DARWIN_LIBSUPCXX < 10)
 const char*
 std::bad_cast::what() const _NOEXCEPT
 {
   return "std::bad_cast";
 }
+#endif
 
+#ifndef __GLIBCXX__
 std::bad_typeid::~bad_typeid() _NOEXCEPT
 {
 }
-
+#endif
+#if !defined(__GLIBCXX__) || (defined(DARWIN_LIBSUPCXX) && DARWIN_LIBSUPCXX < 10)
 const char*
 std::bad_typeid::what() const _NOEXCEPT
 {
   return "std::bad_typeid";
 }
-
+#endif
+#ifndef __GLIBCXX__
 #ifdef __APPLE__
   // On Darwin, the cxa_bad_* functions cannot be in the lower level library
   // because bad_cast and bad_typeid are defined in his higher level library
diff -uNr libcxx-3.7.0.src.orig/test/libcxx/test/config.py libcxx-3.7.0.src/test/libcxx/test/config.py
--- libcxx-3.7.0.src.orig/test/libcxx/test/config.py	2015-06-26 19:47:13.000000000 -0400
+++ libcxx-3.7.0.src/test/libcxx/test/config.py	2015-07-04 22:41:36.000000000 -0400
@@ -445,8 +445,21 @@
     def configure_compile_flags_no_monotonic_clock(self):
         self.cxx.compile_flags += ['-D_LIBCPP_HAS_NO_MONOTONIC_CLOCK']
         self.config.available_features.add('libcpp-has-no-monotonic-clock')
+        # also grab library compile flags from libc++ build/configuration
+        cxx_flags = self.get_lit_conf('cxx_flags', '')
+        self.compile_flags += cxx_flags
+        self.lit_config.note(
+            "inferred cxx_flags as: %r" % cxx_flags)
+        self.lit_config.note(
+            "inferred compile_flags as: %r" % self.compile_flags)
 
     def configure_link_flags(self):
+        # build configuration linker flags for executables
+        exe_linker_flags = self.get_lit_conf('exe_linker_flags')
+        lit_config.note("inferred exe_linker_flags as: %r" % (exe_linker_flags,))
+        self.link_flags += exe_linker_flags
+
+        # Configure library search paths
         no_default_flags = self.get_lit_bool('no_default_flags', False)
         if not no_default_flags:
             self.cxx.link_flags += ['-nodefaultlibs']
@@ -520,7 +533,32 @@
         llvm_unwinder = self.get_lit_bool('llvm_unwinder', False)
         target_platform = self.target_info.platform()
         if target_platform == 'darwin':
+            # need libgcc_s for libunwind
+            darwin_vers = int(platform.release().split('.')[0])
+            osx_vers_maj = '.'.join(platform.mac_ver()[0].split('.')[0:2])
+            if darwin_vers < 10:
+                self.link_flags += ['.'.join(['-lgcc_s', osx_vers_maj])]
+            elif darwin_vers < 11:
+                self.link_flags += ['-lgcc_s.1']
+            # need libclang_rt for eprintf
+            arch = platform.processor()
+            if arch == 'powerpc':
+                arch = 'ppc'
+            libcrt = '.'.join(['libclang_rt', '-'.join(['builtins', arch]), 'a'])
+            cmd = [cxx_under_test, '-print-search-dirs']
+            p = subprocess.Popen(cmd, stdout=subprocess.PIPE)
+            out,err = p.communicate()
+            exitCode = p.wait()
+            # should probably check exitCode
+            for l in out.splitlines():
+                ll = l.split(' ')
+                if ll[0] == 'libraries:':
+                    crt_libdir = ll[1][1:]
+            self.link_flags += [os.path.join(crt_libdir, 'lib', sys.platform, libcrt)]
             self.cxx.link_flags += ['-lSystem']
+            # better yet, test existence of SystemStubs
+            if darwin_vers < 11:
+                self.link_flags += ['-lSystemStubs']
         elif target_platform == 'linux':
             if not llvm_unwinder:
                 self.cxx.link_flags += ['-lgcc_eh']
diff -uNr libcxx-3.7.0.src.orig/test/lit.cfg libcxx-3.7.0.src/test/lit.cfg
--- libcxx-3.7.0.src.orig/test/lit.cfg	2015-02-20 10:37:29.000000000 -0500
+++ libcxx-3.7.0.src/test/lit.cfg	2015-07-04 22:33:31.000000000 -0400
@@ -5,7 +5,6 @@
 
 site.addsitedir(os.path.dirname(__file__))
 
-
 # Tell pylint that we know config and lit_config exist somewhere.
 if 'PYLINT_IMPORT' in os.environ:
     config = object()
diff -uNr libcxx-3.7.0.src.orig/test/lit.site.cfg.in libcxx-3.7.0.src/test/lit.site.cfg.in
--- libcxx-3.7.0.src.orig/test/lit.site.cfg.in	2015-06-26 19:47:13.000000000 -0400
+++ libcxx-3.7.0.src/test/lit.site.cfg.in	2015-07-04 22:42:34.000000000 -0400
@@ -17,6 +17,9 @@
 config.cxx_abi                  = "@LIBCXX_CXX_ABI_LIBNAME@"
 config.use_sanitizer            = "@LLVM_USE_SANITIZER@"
 config.abi_library_path         = "@LIBCXX_CXX_ABI_LIBRARY_PATH@"
+# use same options used to build libc++
+config.exe_linker_flags         = "@CMAKE_EXE_LINKER_FLAGS@"
+config.cxx_flags                
 config.configuration_variant    = "@LIBCXX_LIT_VARIANT@"
 config.target_triple            = "@LIBCXX_TARGET_TRIPLE@"
 config.sysroot                  = "@LIBCXX_SYSROOT@"
diff -uNr libcxx-3.7.0.src.orig/test/std/atomics/atomics.types.generic/integral.pass.cpp libcxx-3.7.0.src/test/std/atomics/atomics.types.generic/integral.pass.cpp
--- libcxx-3.7.0.src.orig/test/std/atomics/atomics.types.generic/integral.pass.cpp	2015-02-20 10:39:16.000000000 -0500
+++ libcxx-3.7.0.src/test/std/atomics/atomics.types.generic/integral.pass.cpp	2015-07-04 22:33:31.000000000 -0400
@@ -92,6 +92,8 @@
 
 #include <cmpxchg_loop.h>
 
+#include "powerpc-darwin.h"
+
 template <class A, class T>
 void
 do_test()
@@ -164,7 +166,6 @@
     do_test<volatile A, T>();
 }
 
-
 int main()
 {
     test<std::atomic_char, char>();
@@ -176,8 +177,10 @@
     test<std::atomic_uint, unsigned int>();
     test<std::atomic_long, long>();
     test<std::atomic_ulong, unsigned long>();
+#ifndef	MISSING_64B_ATOMIC_OPS
     test<std::atomic_llong, long long>();
     test<std::atomic_ullong, unsigned long long>();
+#endif
 #ifndef _LIBCPP_HAS_NO_UNICODE_CHARS
     test<std::atomic_char16_t, char16_t>();
     test<std::atomic_char32_t, char32_t>();
@@ -193,8 +196,10 @@
     test<volatile std::atomic_uint, unsigned int>();
     test<volatile std::atomic_long, long>();
     test<volatile std::atomic_ulong, unsigned long>();
+#ifndef	MISSING_64B_ATOMIC_OPS
     test<volatile std::atomic_llong, long long>();
     test<volatile std::atomic_ullong, unsigned long long>();
+#endif
 #ifndef _LIBCPP_HAS_NO_UNICODE_CHARS
     test<volatile std::atomic_char16_t, char16_t>();
     test<volatile std::atomic_char32_t, char32_t>();
diff -uNr libcxx-3.7.0.src.orig/test/std/atomics/atomics.types.operations/atomics.types.operations.req/atomic_compare_exchange_strong.pass.cpp libcxx-3.7.0.src/test/std/atomics/atomics.types.operations/atomics.types.operations.req/atomic_compare_exchange_strong.pass.cpp
--- libcxx-3.7.0.src.orig/test/std/atomics/atomics.types.operations/atomics.types.operations.req/atomic_compare_exchange_strong.pass.cpp	2015-02-20 10:39:15.000000000 -0500
+++ libcxx-3.7.0.src/test/std/atomics/atomics.types.operations/atomics.types.operations.req/atomic_compare_exchange_strong.pass.cpp	2015-07-04 22:33:31.000000000 -0400
@@ -24,6 +24,8 @@
 #include <type_traits>
 #include <cassert>
 
+#include "powerpc-darwin.h"
+
 template <class T>
 void
 test()
@@ -76,8 +78,10 @@
     test<unsigned int>();
     test<long>();
     test<unsigned long>();
+#ifndef	MISSING_64B_ATOMIC_OPS
     test<long long>();
     test<unsigned long long>();
+#endif
     test<wchar_t>();
 #ifndef _LIBCPP_HAS_NO_UNICODE_CHARS
     test<char16_t>();
diff -uNr libcxx-3.7.0.src.orig/test/std/atomics/atomics.types.operations/atomics.types.operations.req/atomic_compare_exchange_strong_explicit.pass.cpp libcxx-3.7.0.src/test/std/atomics/atomics.types.operations/atomics.types.operations.req/atomic_compare_exchange_strong_explicit.pass.cpp
--- libcxx-3.7.0.src.orig/test/std/atomics/atomics.types.operations/atomics.types.operations.req/atomic_compare_exchange_strong_explicit.pass.cpp	2015-02-20 10:39:15.000000000 -0500
+++ libcxx-3.7.0.src/test/std/atomics/atomics.types.operations/atomics.types.operations.req/atomic_compare_exchange_strong_explicit.pass.cpp	2015-07-04 22:33:31.000000000 -0400
@@ -27,6 +27,8 @@
 #include <type_traits>
 #include <cassert>
 
+#include "powerpc-darwin.h"
+
 template <class T>
 void
 test()
@@ -83,8 +85,10 @@
     test<unsigned int>();
     test<long>();
     test<unsigned long>();
+#ifndef	MISSING_64B_ATOMIC_OPS
     test<long long>();
     test<unsigned long long>();
+#endif
     test<wchar_t>();
 #ifndef _LIBCPP_HAS_NO_UNICODE_CHARS
     test<char16_t>();
diff -uNr libcxx-3.7.0.src.orig/test/std/atomics/atomics.types.operations/atomics.types.operations.req/atomic_compare_exchange_weak.pass.cpp libcxx-3.7.0.src/test/std/atomics/atomics.types.operations/atomics.types.operations.req/atomic_compare_exchange_weak.pass.cpp
--- libcxx-3.7.0.src.orig/test/std/atomics/atomics.types.operations/atomics.types.operations.req/atomic_compare_exchange_weak.pass.cpp	2015-02-20 10:39:15.000000000 -0500
+++ libcxx-3.7.0.src/test/std/atomics/atomics.types.operations/atomics.types.operations.req/atomic_compare_exchange_weak.pass.cpp	2015-07-04 22:33:31.000000000 -0400
@@ -23,6 +23,7 @@
 #include <atomic>
 #include <type_traits>
 #include <cassert>
+#include "powerpc-darwin.h"
 
 #include <cmpxchg_loop.h>
 
@@ -78,8 +79,10 @@
     test<unsigned int>();
     test<long>();
     test<unsigned long>();
+#ifndef	MISSING_64B_ATOMIC_OPS
     test<long long>();
     test<unsigned long long>();
+#endif
     test<wchar_t>();
 #ifndef _LIBCPP_HAS_NO_UNICODE_CHARS
     test<char16_t>();
diff -uNr libcxx-3.7.0.src.orig/test/std/atomics/atomics.types.operations/atomics.types.operations.req/atomic_compare_exchange_weak_explicit.pass.cpp libcxx-3.7.0.src/test/std/atomics/atomics.types.operations/atomics.types.operations.req/atomic_compare_exchange_weak_explicit.pass.cpp
--- libcxx-3.7.0.src.orig/test/std/atomics/atomics.types.operations/atomics.types.operations.req/atomic_compare_exchange_weak_explicit.pass.cpp	2015-02-20 10:39:15.000000000 -0500
+++ libcxx-3.7.0.src/test/std/atomics/atomics.types.operations/atomics.types.operations.req/atomic_compare_exchange_weak_explicit.pass.cpp	2015-07-04 22:33:31.000000000 -0400
@@ -29,6 +29,8 @@
 
 #include <cmpxchg_loop.h>
 
+#include "powerpc-darwin.h"
+
 template <class T>
 void
 test()
@@ -85,8 +87,10 @@
     test<unsigned int>();
     test<long>();
     test<unsigned long>();
+#ifndef	MISSING_64B_ATOMIC_OPS
     test<long long>();
     test<unsigned long long>();
+#endif
     test<wchar_t>();
 #ifndef _LIBCPP_HAS_NO_UNICODE_CHARS
     test<char16_t>();
diff -uNr libcxx-3.7.0.src.orig/test/std/atomics/atomics.types.operations/atomics.types.operations.req/atomic_exchange.pass.cpp libcxx-3.7.0.src/test/std/atomics/atomics.types.operations/atomics.types.operations.req/atomic_exchange.pass.cpp
--- libcxx-3.7.0.src.orig/test/std/atomics/atomics.types.operations/atomics.types.operations.req/atomic_exchange.pass.cpp	2015-02-20 10:39:15.000000000 -0500
+++ libcxx-3.7.0.src/test/std/atomics/atomics.types.operations/atomics.types.operations.req/atomic_exchange.pass.cpp	2015-07-04 22:33:31.000000000 -0400
@@ -24,6 +24,8 @@
 #include <type_traits>
 #include <cassert>
 
+#include "powerpc-darwin.h"
+
 template <class T>
 void
 test()
@@ -61,8 +63,10 @@
     test<unsigned int>();
     test<long>();
     test<unsigned long>();
+#ifndef	MISSING_64B_ATOMIC_OPS
     test<long long>();
     test<unsigned long long>();
+#endif
     test<wchar_t>();
 #ifndef _LIBCPP_HAS_NO_UNICODE_CHARS
     test<char16_t>();
diff -uNr libcxx-3.7.0.src.orig/test/std/atomics/atomics.types.operations/atomics.types.operations.req/atomic_exchange_explicit.pass.cpp libcxx-3.7.0.src/test/std/atomics/atomics.types.operations/atomics.types.operations.req/atomic_exchange_explicit.pass.cpp
--- libcxx-3.7.0.src.orig/test/std/atomics/atomics.types.operations/atomics.types.operations.req/atomic_exchange_explicit.pass.cpp	2015-02-20 10:39:15.000000000 -0500
+++ libcxx-3.7.0.src/test/std/atomics/atomics.types.operations/atomics.types.operations.req/atomic_exchange_explicit.pass.cpp	2015-07-04 22:33:31.000000000 -0400
@@ -24,6 +24,8 @@
 #include <type_traits>
 #include <cassert>
 
+#include "powerpc-darwin.h"
+
 template <class T>
 void
 test()
@@ -63,8 +65,10 @@
     test<unsigned int>();
     test<long>();
     test<unsigned long>();
+#ifndef	MISSING_64B_ATOMIC_OPS
     test<long long>();
     test<unsigned long long>();
+#endif
     test<wchar_t>();
 #ifndef _LIBCPP_HAS_NO_UNICODE_CHARS
     test<char16_t>();
diff -uNr libcxx-3.7.0.src.orig/test/std/atomics/atomics.types.operations/atomics.types.operations.req/atomic_fetch_add.pass.cpp libcxx-3.7.0.src/test/std/atomics/atomics.types.operations/atomics.types.operations.req/atomic_fetch_add.pass.cpp
--- libcxx-3.7.0.src.orig/test/std/atomics/atomics.types.operations/atomics.types.operations.req/atomic_fetch_add.pass.cpp	2015-02-20 10:39:15.000000000 -0500
+++ libcxx-3.7.0.src/test/std/atomics/atomics.types.operations/atomics.types.operations.req/atomic_fetch_add.pass.cpp	2015-07-04 22:33:31.000000000 -0400
@@ -32,6 +32,8 @@
 #include <type_traits>
 #include <cassert>
 
+#include "powerpc-darwin.h"
+
 template <class T>
 void
 test()
@@ -99,8 +101,10 @@
     test<unsigned int>();
     test<long>();
     test<unsigned long>();
+#ifndef	MISSING_64B_ATOMIC_OPS
     test<long long>();
     test<unsigned long long>();
+#endif
     test<wchar_t>();
 #ifndef _LIBCPP_HAS_NO_UNICODE_CHARS
     test<char16_t>();
diff -uNr libcxx-3.7.0.src.orig/test/std/atomics/atomics.types.operations/atomics.types.operations.req/atomic_fetch_add_explicit.pass.cpp libcxx-3.7.0.src/test/std/atomics/atomics.types.operations/atomics.types.operations.req/atomic_fetch_add_explicit.pass.cpp
--- libcxx-3.7.0.src.orig/test/std/atomics/atomics.types.operations/atomics.types.operations.req/atomic_fetch_add_explicit.pass.cpp	2015-02-20 10:39:15.000000000 -0500
+++ libcxx-3.7.0.src/test/std/atomics/atomics.types.operations/atomics.types.operations.req/atomic_fetch_add_explicit.pass.cpp	2015-07-04 22:33:31.000000000 -0400
@@ -32,6 +32,8 @@
 #include <type_traits>
 #include <cassert>
 
+#include "powerpc-darwin.h"
+
 template <class T>
 void
 test()
@@ -103,8 +105,10 @@
     test<unsigned int>();
     test<long>();
     test<unsigned long>();
+#ifndef	MISSING_64B_ATOMIC_OPS
     test<long long>();
     test<unsigned long long>();
+#endif
     test<wchar_t>();
 #ifndef _LIBCPP_HAS_NO_UNICODE_CHARS
     test<char16_t>();
diff -uNr libcxx-3.7.0.src.orig/test/std/atomics/atomics.types.operations/atomics.types.operations.req/atomic_fetch_and.pass.cpp libcxx-3.7.0.src/test/std/atomics/atomics.types.operations/atomics.types.operations.req/atomic_fetch_and.pass.cpp
--- libcxx-3.7.0.src.orig/test/std/atomics/atomics.types.operations/atomics.types.operations.req/atomic_fetch_and.pass.cpp	2015-02-20 10:39:15.000000000 -0500
+++ libcxx-3.7.0.src/test/std/atomics/atomics.types.operations/atomics.types.operations.req/atomic_fetch_and.pass.cpp	2015-07-04 22:33:31.000000000 -0400
@@ -23,6 +23,8 @@
 #include <type_traits>
 #include <cassert>
 
+#include "powerpc-darwin.h"
+
 template <class T>
 void
 test()
@@ -54,8 +56,10 @@
     test<unsigned int>();
     test<long>();
     test<unsigned long>();
+#ifndef	MISSING_64B_ATOMIC_OPS
     test<long long>();
     test<unsigned long long>();
+#endif
     test<wchar_t>();
 #ifndef _LIBCPP_HAS_NO_UNICODE_CHARS
     test<char16_t>();
diff -uNr libcxx-3.7.0.src.orig/test/std/atomics/atomics.types.operations/atomics.types.operations.req/atomic_fetch_and_explicit.pass.cpp libcxx-3.7.0.src/test/std/atomics/atomics.types.operations/atomics.types.operations.req/atomic_fetch_and_explicit.pass.cpp
--- libcxx-3.7.0.src.orig/test/std/atomics/atomics.types.operations/atomics.types.operations.req/atomic_fetch_and_explicit.pass.cpp	2015-02-20 10:39:15.000000000 -0500
+++ libcxx-3.7.0.src/test/std/atomics/atomics.types.operations/atomics.types.operations.req/atomic_fetch_and_explicit.pass.cpp	2015-07-04 22:33:31.000000000 -0400
@@ -23,6 +23,8 @@
 #include <type_traits>
 #include <cassert>
 
+#include "powerpc-darwin.h"
+
 template <class T>
 void
 test()
@@ -56,8 +58,10 @@
     test<unsigned int>();
     test<long>();
     test<unsigned long>();
+#ifndef	MISSING_64B_ATOMIC_OPS
     test<long long>();
     test<unsigned long long>();
+#endif
     test<wchar_t>();
 #ifndef _LIBCPP_HAS_NO_UNICODE_CHARS
     test<char16_t>();
diff -uNr libcxx-3.7.0.src.orig/test/std/atomics/atomics.types.operations/atomics.types.operations.req/atomic_fetch_or.pass.cpp libcxx-3.7.0.src/test/std/atomics/atomics.types.operations/atomics.types.operations.req/atomic_fetch_or.pass.cpp
--- libcxx-3.7.0.src.orig/test/std/atomics/atomics.types.operations/atomics.types.operations.req/atomic_fetch_or.pass.cpp	2015-02-20 10:39:15.000000000 -0500
+++ libcxx-3.7.0.src/test/std/atomics/atomics.types.operations/atomics.types.operations.req/atomic_fetch_or.pass.cpp	2015-07-04 22:33:31.000000000 -0400
@@ -23,6 +23,8 @@
 #include <type_traits>
 #include <cassert>
 
+#include "powerpc-darwin.h"
+
 template <class T>
 void
 test()
@@ -54,8 +56,10 @@
     test<unsigned int>();
     test<long>();
     test<unsigned long>();
+#ifndef	MISSING_64B_ATOMIC_OPS
     test<long long>();
     test<unsigned long long>();
+#endif
     test<wchar_t>();
 #ifndef _LIBCPP_HAS_NO_UNICODE_CHARS
     test<char16_t>();
diff -uNr libcxx-3.7.0.src.orig/test/std/atomics/atomics.types.operations/atomics.types.operations.req/atomic_fetch_or_explicit.pass.cpp libcxx-3.7.0.src/test/std/atomics/atomics.types.operations/atomics.types.operations.req/atomic_fetch_or_explicit.pass.cpp
--- libcxx-3.7.0.src.orig/test/std/atomics/atomics.types.operations/atomics.types.operations.req/atomic_fetch_or_explicit.pass.cpp	2015-02-20 10:39:15.000000000 -0500
+++ libcxx-3.7.0.src/test/std/atomics/atomics.types.operations/atomics.types.operations.req/atomic_fetch_or_explicit.pass.cpp	2015-07-04 22:33:31.000000000 -0400
@@ -23,6 +23,8 @@
 #include <type_traits>
 #include <cassert>
 
+#include "powerpc-darwin.h"
+
 template <class T>
 void
 test()
@@ -56,8 +58,10 @@
     test<unsigned int>();
     test<long>();
     test<unsigned long>();
+#ifndef	MISSING_64B_ATOMIC_OPS
     test<long long>();
     test<unsigned long long>();
+#endif
     test<wchar_t>();
 #ifndef _LIBCPP_HAS_NO_UNICODE_CHARS
     test<char16_t>();
diff -uNr libcxx-3.7.0.src.orig/test/std/atomics/atomics.types.operations/atomics.types.operations.req/atomic_fetch_sub.pass.cpp libcxx-3.7.0.src/test/std/atomics/atomics.types.operations/atomics.types.operations.req/atomic_fetch_sub.pass.cpp
--- libcxx-3.7.0.src.orig/test/std/atomics/atomics.types.operations/atomics.types.operations.req/atomic_fetch_sub.pass.cpp	2015-02-20 10:39:15.000000000 -0500
+++ libcxx-3.7.0.src/test/std/atomics/atomics.types.operations/atomics.types.operations.req/atomic_fetch_sub.pass.cpp	2015-07-04 22:33:31.000000000 -0400
@@ -32,6 +32,8 @@
 #include <type_traits>
 #include <cassert>
 
+#include "powerpc-darwin.h"
+
 template <class T>
 void
 test()
@@ -99,8 +101,10 @@
     test<unsigned int>();
     test<long>();
     test<unsigned long>();
+#ifndef	MISSING_64B_ATOMIC_OPS
     test<long long>();
     test<unsigned long long>();
+#endif
     test<wchar_t>();
 #ifndef _LIBCPP_HAS_NO_UNICODE_CHARS
     test<char16_t>();
diff -uNr libcxx-3.7.0.src.orig/test/std/atomics/atomics.types.operations/atomics.types.operations.req/atomic_fetch_sub_explicit.pass.cpp libcxx-3.7.0.src/test/std/atomics/atomics.types.operations/atomics.types.operations.req/atomic_fetch_sub_explicit.pass.cpp
--- libcxx-3.7.0.src.orig/test/std/atomics/atomics.types.operations/atomics.types.operations.req/atomic_fetch_sub_explicit.pass.cpp	2015-02-20 10:39:15.000000000 -0500
+++ libcxx-3.7.0.src/test/std/atomics/atomics.types.operations/atomics.types.operations.req/atomic_fetch_sub_explicit.pass.cpp	2015-07-04 22:33:31.000000000 -0400
@@ -33,6 +33,8 @@
 #include <type_traits>
 #include <cassert>
 
+#include "powerpc-darwin.h"
+
 template <class T>
 void
 test()
@@ -104,8 +106,10 @@
     test<unsigned int>();
     test<long>();
     test<unsigned long>();
+#ifndef	MISSING_64B_ATOMIC_OPS
     test<long long>();
     test<unsigned long long>();
+#endif
     test<wchar_t>();
 #ifndef _LIBCPP_HAS_NO_UNICODE_CHARS
     test<char16_t>();
diff -uNr libcxx-3.7.0.src.orig/test/std/atomics/atomics.types.operations/atomics.types.operations.req/atomic_fetch_xor.pass.cpp libcxx-3.7.0.src/test/std/atomics/atomics.types.operations/atomics.types.operations.req/atomic_fetch_xor.pass.cpp
--- libcxx-3.7.0.src.orig/test/std/atomics/atomics.types.operations/atomics.types.operations.req/atomic_fetch_xor.pass.cpp	2015-02-20 10:39:15.000000000 -0500
+++ libcxx-3.7.0.src/test/std/atomics/atomics.types.operations/atomics.types.operations.req/atomic_fetch_xor.pass.cpp	2015-07-04 22:33:31.000000000 -0400
@@ -23,6 +23,8 @@
 #include <type_traits>
 #include <cassert>
 
+#include "powerpc-darwin.h"
+
 template <class T>
 void
 test()
@@ -54,8 +56,10 @@
     test<unsigned int>();
     test<long>();
     test<unsigned long>();
+#ifndef	MISSING_64B_ATOMIC_OPS
     test<long long>();
     test<unsigned long long>();
+#endif
     test<wchar_t>();
 #ifndef _LIBCPP_HAS_NO_UNICODE_CHARS
     test<char16_t>();
diff -uNr libcxx-3.7.0.src.orig/test/std/atomics/atomics.types.operations/atomics.types.operations.req/atomic_fetch_xor_explicit.pass.cpp libcxx-3.7.0.src/test/std/atomics/atomics.types.operations/atomics.types.operations.req/atomic_fetch_xor_explicit.pass.cpp
--- libcxx-3.7.0.src.orig/test/std/atomics/atomics.types.operations/atomics.types.operations.req/atomic_fetch_xor_explicit.pass.cpp	2015-02-20 10:39:15.000000000 -0500
+++ libcxx-3.7.0.src/test/std/atomics/atomics.types.operations/atomics.types.operations.req/atomic_fetch_xor_explicit.pass.cpp	2015-07-04 22:33:31.000000000 -0400
@@ -23,6 +23,8 @@
 #include <type_traits>
 #include <cassert>
 
+#include "powerpc-darwin.h"
+
 template <class T>
 void
 test()
@@ -56,8 +58,10 @@
     test<unsigned int>();
     test<long>();
     test<unsigned long>();
+#ifndef	MISSING_64B_ATOMIC_OPS
     test<long long>();
     test<unsigned long long>();
+#endif
     test<wchar_t>();
 #ifndef _LIBCPP_HAS_NO_UNICODE_CHARS
     test<char16_t>();
diff -uNr libcxx-3.7.0.src.orig/test/std/atomics/atomics.types.operations/atomics.types.operations.req/atomic_init.pass.cpp libcxx-3.7.0.src/test/std/atomics/atomics.types.operations/atomics.types.operations.req/atomic_init.pass.cpp
--- libcxx-3.7.0.src.orig/test/std/atomics/atomics.types.operations/atomics.types.operations.req/atomic_init.pass.cpp	2015-02-20 10:39:15.000000000 -0500
+++ libcxx-3.7.0.src/test/std/atomics/atomics.types.operations/atomics.types.operations.req/atomic_init.pass.cpp	2015-07-04 22:33:31.000000000 -0400
@@ -24,6 +24,8 @@
 #include <type_traits>
 #include <cassert>
 
+#include "powerpc-darwin.h"
+
 template <class T>
 void
 test()
@@ -59,8 +61,10 @@
     test<unsigned int>();
     test<long>();
     test<unsigned long>();
+#ifndef	MISSING_64B_ATOMIC_OPS
     test<long long>();
     test<unsigned long long>();
+#endif
     test<wchar_t>();
 #ifndef _LIBCPP_HAS_NO_UNICODE_CHARS
     test<char16_t>();
diff -uNr libcxx-3.7.0.src.orig/test/std/atomics/atomics.types.operations/atomics.types.operations.req/atomic_load.pass.cpp libcxx-3.7.0.src/test/std/atomics/atomics.types.operations/atomics.types.operations.req/atomic_load.pass.cpp
--- libcxx-3.7.0.src.orig/test/std/atomics/atomics.types.operations/atomics.types.operations.req/atomic_load.pass.cpp	2015-02-20 10:39:15.000000000 -0500
+++ libcxx-3.7.0.src/test/std/atomics/atomics.types.operations/atomics.types.operations.req/atomic_load.pass.cpp	2015-07-04 22:33:31.000000000 -0400
@@ -24,6 +24,8 @@
 #include <type_traits>
 #include <cassert>
 
+#include "powerpc-darwin.h"
+
 template <class T>
 void
 test()
@@ -59,8 +61,10 @@
     test<unsigned int>();
     test<long>();
     test<unsigned long>();
+#ifndef	MISSING_64B_ATOMIC_OPS
     test<long long>();
     test<unsigned long long>();
+#endif
     test<wchar_t>();
 #ifndef _LIBCPP_HAS_NO_UNICODE_CHARS
     test<char16_t>();
diff -uNr libcxx-3.7.0.src.orig/test/std/atomics/atomics.types.operations/atomics.types.operations.req/atomic_load_explicit.pass.cpp libcxx-3.7.0.src/test/std/atomics/atomics.types.operations/atomics.types.operations.req/atomic_load_explicit.pass.cpp
--- libcxx-3.7.0.src.orig/test/std/atomics/atomics.types.operations/atomics.types.operations.req/atomic_load_explicit.pass.cpp	2015-02-20 10:39:15.000000000 -0500
+++ libcxx-3.7.0.src/test/std/atomics/atomics.types.operations/atomics.types.operations.req/atomic_load_explicit.pass.cpp	2015-07-04 22:33:31.000000000 -0400
@@ -24,6 +24,8 @@
 #include <type_traits>
 #include <cassert>
 
+#include "powerpc-darwin.h"
+
 template <class T>
 void
 test()
@@ -59,8 +61,10 @@
     test<unsigned int>();
     test<long>();
     test<unsigned long>();
+#ifndef	MISSING_64B_ATOMIC_OPS
     test<long long>();
     test<unsigned long long>();
+#endif
     test<wchar_t>();
 #ifndef _LIBCPP_HAS_NO_UNICODE_CHARS
     test<char16_t>();
diff -uNr libcxx-3.7.0.src.orig/test/std/atomics/atomics.types.operations/atomics.types.operations.req/atomic_store.pass.cpp libcxx-3.7.0.src/test/std/atomics/atomics.types.operations/atomics.types.operations.req/atomic_store.pass.cpp
--- libcxx-3.7.0.src.orig/test/std/atomics/atomics.types.operations/atomics.types.operations.req/atomic_store.pass.cpp	2015-02-20 10:39:15.000000000 -0500
+++ libcxx-3.7.0.src/test/std/atomics/atomics.types.operations/atomics.types.operations.req/atomic_store.pass.cpp	2015-07-04 22:33:31.000000000 -0400
@@ -24,6 +24,8 @@
 #include <type_traits>
 #include <cassert>
 
+#include "powerpc-darwin.h"
+
 template <class T>
 void
 test()
@@ -59,8 +61,10 @@
     test<unsigned int>();
     test<long>();
     test<unsigned long>();
+#ifndef	MISSING_64B_ATOMIC_OPS
     test<long long>();
     test<unsigned long long>();
+#endif
     test<wchar_t>();
 #ifndef _LIBCPP_HAS_NO_UNICODE_CHARS
     test<char16_t>();
diff -uNr libcxx-3.7.0.src.orig/test/std/atomics/atomics.types.operations/atomics.types.operations.req/atomic_store_explicit.pass.cpp libcxx-3.7.0.src/test/std/atomics/atomics.types.operations/atomics.types.operations.req/atomic_store_explicit.pass.cpp
--- libcxx-3.7.0.src.orig/test/std/atomics/atomics.types.operations/atomics.types.operations.req/atomic_store_explicit.pass.cpp	2015-02-20 10:39:15.000000000 -0500
+++ libcxx-3.7.0.src/test/std/atomics/atomics.types.operations/atomics.types.operations.req/atomic_store_explicit.pass.cpp	2015-07-04 22:33:31.000000000 -0400
@@ -24,6 +24,8 @@
 #include <type_traits>
 #include <cassert>
 
+#include "powerpc-darwin.h"
+
 template <class T>
 void
 test()
@@ -59,8 +61,10 @@
     test<unsigned int>();
     test<long>();
     test<unsigned long>();
+#ifndef	MISSING_64B_ATOMIC_OPS
     test<long long>();
     test<unsigned long long>();
+#endif
     test<wchar_t>();
 #ifndef _LIBCPP_HAS_NO_UNICODE_CHARS
     test<char16_t>();
diff -uNr libcxx-3.7.0.src.orig/test/std/containers/associative/map/types.pass.cpp libcxx-3.7.0.src/test/std/containers/associative/map/types.pass.cpp
--- libcxx-3.7.0.src.orig/test/std/containers/associative/map/types.pass.cpp	2015-02-20 10:39:34.000000000 -0500
+++ libcxx-3.7.0.src/test/std/containers/associative/map/types.pass.cpp	2015-07-04 22:33:31.000000000 -0400
@@ -33,6 +33,7 @@
 #include <type_traits>
 
 #include "min_allocator.h"
+#include "powerpc-darwin.h"
 
 int main()
 {
@@ -47,7 +48,11 @@
     static_assert((std::is_same<C::const_reference, const std::pair<const int, double>&>::value), "");
     static_assert((std::is_same<C::pointer, std::pair<const int, double>*>::value), "");
     static_assert((std::is_same<C::const_pointer, const std::pair<const int, double>*>::value), "");
+#ifdef	PTRDIFF_T_VS_SIZE_T_DIFFER
+    static_assert(sizeof(C::size_type) == sizeof(std::size_t), "");
+#else
     static_assert((std::is_same<C::size_type, std::size_t>::value), "");
+#endif
     static_assert((std::is_same<C::difference_type, std::ptrdiff_t>::value), "");
     }
 #if __cplusplus >= 201103L
diff -uNr libcxx-3.7.0.src.orig/test/std/containers/associative/multimap/types.pass.cpp libcxx-3.7.0.src/test/std/containers/associative/multimap/types.pass.cpp
--- libcxx-3.7.0.src.orig/test/std/containers/associative/multimap/types.pass.cpp	2015-02-20 10:39:31.000000000 -0500
+++ libcxx-3.7.0.src/test/std/containers/associative/multimap/types.pass.cpp	2015-07-04 22:33:31.000000000 -0400
@@ -33,6 +33,7 @@
 #include <type_traits>
 
 #include "min_allocator.h"
+#include "powerpc-darwin.h"
 
 int main()
 {
@@ -47,7 +48,11 @@
     static_assert((std::is_same<C::const_reference, const std::pair<const int, double>&>::value), "");
     static_assert((std::is_same<C::pointer, std::pair<const int, double>*>::value), "");
     static_assert((std::is_same<C::const_pointer, const std::pair<const int, double>*>::value), "");
+#ifdef	PTRDIFF_T_VS_SIZE_T_DIFFER
+    static_assert(sizeof(C::size_type) == sizeof(std::size_t), "");
+#else
     static_assert((std::is_same<C::size_type, std::size_t>::value), "");
+#endif
     static_assert((std::is_same<C::difference_type, std::ptrdiff_t>::value), "");
     }
 #if __cplusplus >= 201103L
diff -uNr libcxx-3.7.0.src.orig/test/std/containers/associative/multiset/types.pass.cpp libcxx-3.7.0.src/test/std/containers/associative/multiset/types.pass.cpp
--- libcxx-3.7.0.src.orig/test/std/containers/associative/multiset/types.pass.cpp	2015-02-20 10:39:28.000000000 -0500
+++ libcxx-3.7.0.src/test/std/containers/associative/multiset/types.pass.cpp	2015-07-04 22:33:31.000000000 -0400
@@ -33,6 +33,7 @@
 #include <type_traits>
 
 #include "min_allocator.h"
+#include "powerpc-darwin.h"
 
 int main()
 {
@@ -47,7 +48,11 @@
     static_assert((std::is_same<C::const_reference, const int&>::value), "");
     static_assert((std::is_same<C::pointer, int*>::value), "");
     static_assert((std::is_same<C::const_pointer, const int*>::value), "");
+#ifdef	PTRDIFF_T_VS_SIZE_T_DIFFER
+    static_assert(sizeof(C::size_type) == sizeof(std::size_t), "");
+#else
     static_assert((std::is_same<C::size_type, std::size_t>::value), "");
+#endif
     static_assert((std::is_same<C::difference_type, std::ptrdiff_t>::value), "");
     }
 #if __cplusplus >= 201103L
diff -uNr libcxx-3.7.0.src.orig/test/std/containers/associative/set/types.pass.cpp libcxx-3.7.0.src/test/std/containers/associative/set/types.pass.cpp
--- libcxx-3.7.0.src.orig/test/std/containers/associative/set/types.pass.cpp	2015-02-20 10:39:32.000000000 -0500
+++ libcxx-3.7.0.src/test/std/containers/associative/set/types.pass.cpp	2015-07-04 22:33:31.000000000 -0400
@@ -33,6 +33,7 @@
 #include <type_traits>
 
 #include "min_allocator.h"
+#include "powerpc-darwin.h"
 
 int main()
 {
@@ -47,7 +48,11 @@
     static_assert((std::is_same<C::const_reference, const int&>::value), "");
     static_assert((std::is_same<C::pointer, int*>::value), "");
     static_assert((std::is_same<C::const_pointer, const int*>::value), "");
+#ifdef	PTRDIFF_T_VS_SIZE_T_DIFFER
+    static_assert(sizeof(C::size_type) == sizeof(std::size_t), "");
+#else
     static_assert((std::is_same<C::size_type, std::size_t>::value), "");
+#endif
     static_assert((std::is_same<C::difference_type, std::ptrdiff_t>::value), "");
     }
 #if __cplusplus >= 201103L
diff -uNr libcxx-3.7.0.src.orig/test/std/containers/sequences/array/types.pass.cpp libcxx-3.7.0.src/test/std/containers/sequences/array/types.pass.cpp
--- libcxx-3.7.0.src.orig/test/std/containers/sequences/array/types.pass.cpp	2015-02-20 10:39:39.000000000 -0500
+++ libcxx-3.7.0.src/test/std/containers/sequences/array/types.pass.cpp	2015-07-04 22:33:31.000000000 -0400
@@ -29,6 +29,8 @@
 #include <iterator>
 #include <type_traits>
 
+#include "powerpc-darwin.h"
+
 int main()
 {
     {
@@ -40,7 +42,11 @@
         static_assert((std::is_same<C::const_iterator, const T*>::value), "");
         static_assert((std::is_same<C::pointer, T*>::value), "");
         static_assert((std::is_same<C::const_pointer, const T*>::value), "");
+#ifdef	PTRDIFF_T_VS_SIZE_T_DIFFER
+        static_assert(sizeof(C::size_type) == sizeof(std::size_t), "");
+#else
         static_assert((std::is_same<C::size_type, std::size_t>::value), "");
+#endif
         static_assert((std::is_same<C::difference_type, std::ptrdiff_t>::value), "");
         static_assert((std::is_same<C::reverse_iterator, std::reverse_iterator<C::iterator> >::value), "");
         static_assert((std::is_same<C::const_reverse_iterator, std::reverse_iterator<C::const_iterator> >::value), "");
@@ -54,7 +60,11 @@
         static_assert((std::is_same<C::const_iterator, const T*>::value), "");
         static_assert((std::is_same<C::pointer, T*>::value), "");
         static_assert((std::is_same<C::const_pointer, const T*>::value), "");
+#ifdef	PTRDIFF_T_VS_SIZE_T_DIFFER
+        static_assert(sizeof(C::size_type) == sizeof(std::size_t), "");
+#else
         static_assert((std::is_same<C::size_type, std::size_t>::value), "");
+#endif
         static_assert((std::is_same<C::difference_type, std::ptrdiff_t>::value), "");
         static_assert((std::is_same<C::reverse_iterator, std::reverse_iterator<C::iterator> >::value), "");
         static_assert((std::is_same<C::const_reverse_iterator, std::reverse_iterator<C::const_iterator> >::value), "");
diff -uNr libcxx-3.7.0.src.orig/test/std/containers/sequences/forwardlist/types.pass.cpp libcxx-3.7.0.src/test/std/containers/sequences/forwardlist/types.pass.cpp
--- libcxx-3.7.0.src.orig/test/std/containers/sequences/forwardlist/types.pass.cpp	2015-02-20 10:39:42.000000000 -0500
+++ libcxx-3.7.0.src/test/std/containers/sequences/forwardlist/types.pass.cpp	2015-07-04 22:33:31.000000000 -0400
@@ -42,7 +42,11 @@
     static_assert((std::is_same<C::const_reference, const char&>::value), "");
     static_assert((std::is_same<C::pointer, char*>::value), "");
     static_assert((std::is_same<C::const_pointer, const char*>::value), "");
+#ifdef	PTRDIFF_T_VS_SIZE_T_DIFFER
+    static_assert(sizeof(C::size_type) == sizeof(std::size_t), "");
+#else
     static_assert((std::is_same<C::size_type, std::size_t>::value), "");
+#endif
     static_assert((std::is_same<C::difference_type, std::ptrdiff_t>::value), "");
     }
 #if __cplusplus >= 201103L
diff -uNr libcxx-3.7.0.src.orig/test/std/containers/unord/unord.map/types.pass.cpp libcxx-3.7.0.src/test/std/containers/unord/unord.map/types.pass.cpp
--- libcxx-3.7.0.src.orig/test/std/containers/unord/unord.map/types.pass.cpp	2015-02-20 10:39:23.000000000 -0500
+++ libcxx-3.7.0.src/test/std/containers/unord/unord.map/types.pass.cpp	2015-07-04 22:33:31.000000000 -0400
@@ -32,6 +32,7 @@
 #include <type_traits>
 
 #include "min_allocator.h"
+#include "powerpc-darwin.h"
 
 int main()
 {
@@ -47,7 +48,11 @@
         static_assert((std::is_same<C::const_reference, const C::value_type&>::value), "");
         static_assert((std::is_same<C::pointer, C::value_type*>::value), "");
         static_assert((std::is_same<C::const_pointer, const C::value_type*>::value), "");
+#ifdef	PTRDIFF_T_VS_SIZE_T_DIFFER
+        static_assert(sizeof(C::size_type) == sizeof(std::size_t), "");
+#else
         static_assert((std::is_same<C::size_type, std::size_t>::value), "");
+#endif
         static_assert((std::is_same<C::difference_type, std::ptrdiff_t>::value), "");
     }
 #if __cplusplus >= 201103L
diff -uNr libcxx-3.7.0.src.orig/test/std/containers/unord/unord.multimap/types.pass.cpp libcxx-3.7.0.src/test/std/containers/unord/unord.multimap/types.pass.cpp
--- libcxx-3.7.0.src.orig/test/std/containers/unord/unord.multimap/types.pass.cpp	2015-02-20 10:39:19.000000000 -0500
+++ libcxx-3.7.0.src/test/std/containers/unord/unord.multimap/types.pass.cpp	2015-07-04 22:33:31.000000000 -0400
@@ -32,6 +32,7 @@
 #include <type_traits>
 
 #include "min_allocator.h"
+#include "powerpc-darwin.h"
 
 int main()
 {
@@ -47,7 +48,11 @@
         static_assert((std::is_same<C::const_reference, const C::value_type&>::value), "");
         static_assert((std::is_same<C::pointer, C::value_type*>::value), "");
         static_assert((std::is_same<C::const_pointer, const C::value_type*>::value), "");
+#ifdef	PTRDIFF_T_VS_SIZE_T_DIFFER
+        static_assert(sizeof(C::size_type) == sizeof(std::size_t), "");
+#else
         static_assert((std::is_same<C::size_type, std::size_t>::value), "");
+#endif
         static_assert((std::is_same<C::difference_type, std::ptrdiff_t>::value), "");
     }
 #if __cplusplus >= 201103L
diff -uNr libcxx-3.7.0.src.orig/test/std/containers/unord/unord.multiset/types.pass.cpp libcxx-3.7.0.src/test/std/containers/unord/unord.multiset/types.pass.cpp
--- libcxx-3.7.0.src.orig/test/std/containers/unord/unord.multiset/types.pass.cpp	2015-02-20 10:39:27.000000000 -0500
+++ libcxx-3.7.0.src/test/std/containers/unord/unord.multiset/types.pass.cpp	2015-07-04 22:33:31.000000000 -0400
@@ -31,6 +31,7 @@
 #include <type_traits>
 
 #include "min_allocator.h"
+#include "powerpc-darwin.h"
 
 int main()
 {
@@ -45,7 +46,11 @@
         static_assert((std::is_same<C::const_reference, const C::value_type&>::value), "");
         static_assert((std::is_same<C::pointer, C::value_type*>::value), "");
         static_assert((std::is_same<C::const_pointer, const C::value_type*>::value), "");
+#ifdef	PTRDIFF_T_VS_SIZE_T_DIFFER
+        static_assert(sizeof(C::size_type) == sizeof(std::size_t), "");
+#else
         static_assert((std::is_same<C::size_type, std::size_t>::value), "");
+#endif
         static_assert((std::is_same<C::difference_type, std::ptrdiff_t>::value), "");
     }
 #if __cplusplus >= 201103L
diff -uNr libcxx-3.7.0.src.orig/test/std/containers/unord/unord.set/types.pass.cpp libcxx-3.7.0.src/test/std/containers/unord/unord.set/types.pass.cpp
--- libcxx-3.7.0.src.orig/test/std/containers/unord/unord.set/types.pass.cpp	2015-02-20 10:39:21.000000000 -0500
+++ libcxx-3.7.0.src/test/std/containers/unord/unord.set/types.pass.cpp	2015-07-04 22:33:31.000000000 -0400
@@ -31,6 +31,7 @@
 #include <type_traits>
 
 #include "min_allocator.h"
+#include "powerpc-darwin.h"
 
 int main()
 {
@@ -45,7 +46,11 @@
         static_assert((std::is_same<C::const_reference, const C::value_type&>::value), "");
         static_assert((std::is_same<C::pointer, C::value_type*>::value), "");
         static_assert((std::is_same<C::const_pointer, const C::value_type*>::value), "");
+#ifdef	PTRDIFF_T_VS_SIZE_T_DIFFER
+        static_assert(sizeof(C::size_type) == sizeof(std::size_t), "");
+#else
         static_assert((std::is_same<C::size_type, std::size_t>::value), "");
+#endif
         static_assert((std::is_same<C::difference_type, std::ptrdiff_t>::value), "");
     }
 #if __cplusplus >= 201103L
diff -uNr libcxx-3.7.0.src.orig/test/std/depr/depr.c.headers/ctype_h.pass.cpp libcxx-3.7.0.src/test/std/depr/depr.c.headers/ctype_h.pass.cpp
--- libcxx-3.7.0.src.orig/test/std/depr/depr.c.headers/ctype_h.pass.cpp	2015-02-20 10:38:46.000000000 -0500
+++ libcxx-3.7.0.src/test/std/depr/depr.c.headers/ctype_h.pass.cpp	2015-07-04 22:33:31.000000000 -0400
@@ -13,6 +13,9 @@
 #include <type_traits>
 #include <cassert>
 
+// on darwin8, <ctype.h> defines these functions as:
+// #define isalpha(c)      __istype((c), _CTYPE_A)
+#if !defined(DARWIN_LIBSUPCXX) || (DARWIN_LIBSUPCXX >= 9)
 #ifdef isalnum
 #error isalnum defined
 #endif
@@ -68,6 +71,7 @@
 #ifdef toupper
 #error toupper defined
 #endif
+#endif
 
 int main()
 {
diff -uNr libcxx-3.7.0.src.orig/test/std/depr/depr.c.headers/inttypes_h.pass.cpp libcxx-3.7.0.src/test/std/depr/depr.c.headers/inttypes_h.pass.cpp
--- libcxx-3.7.0.src.orig/test/std/depr/depr.c.headers/inttypes_h.pass.cpp	2015-02-20 10:38:46.000000000 -0500
+++ libcxx-3.7.0.src/test/std/depr/depr.c.headers/inttypes_h.pass.cpp	2015-07-04 22:33:31.000000000 -0400
@@ -9,6 +9,13 @@
 
 // test <inttypes.h>
 
+/* "C++ implementations should define these macros only when
+ *  __STDC_FORMAT_MACROS is defined before <inttypes.h> is included."
+ */
+#ifndef	__STDC_FORMAT_MACROS
+#define	__STDC_FORMAT_MACROS
+#endif
+
 #include <inttypes.h>
 #include <type_traits>
 
diff -uNr libcxx-3.7.0.src.orig/test/std/depr/depr.c.headers/wctype_h.pass.cpp libcxx-3.7.0.src/test/std/depr/depr.c.headers/wctype_h.pass.cpp
--- libcxx-3.7.0.src.orig/test/std/depr/depr.c.headers/wctype_h.pass.cpp	2015-02-20 10:38:46.000000000 -0500
+++ libcxx-3.7.0.src/test/std/depr/depr.c.headers/wctype_h.pass.cpp	2015-07-04 22:33:31.000000000 -0400
@@ -16,6 +16,9 @@
 #error WEOF not defined
 #endif
 
+// on darwin8, <_wctype.h> defines these functions as:
+// #define isalpha(c)      __istype((c), _CTYPE_A)
+#if !defined(DARWIN_LIBSUPCXX) || (DARWIN_LIBSUPCXX >= 9)
 #ifdef iswalnum
 #error iswalnum defined
 #endif
@@ -87,6 +90,7 @@
 #ifdef wctrans
 #error wctrans defined
 #endif
+#endif
 
 int main()
 {
diff -uNr libcxx-3.7.0.src.orig/test/std/input.output/file.streams/c.files/cinttypes.pass.cpp libcxx-3.7.0.src/test/std/input.output/file.streams/c.files/cinttypes.pass.cpp
--- libcxx-3.7.0.src.orig/test/std/input.output/file.streams/c.files/cinttypes.pass.cpp	2015-02-20 10:39:07.000000000 -0500
+++ libcxx-3.7.0.src/test/std/input.output/file.streams/c.files/cinttypes.pass.cpp	2015-07-04 22:33:31.000000000 -0400
@@ -9,6 +9,13 @@
 
 // test <cinttypes>
 
+/* "C++ implementations should define these macros only when
+ *  __STDC_FORMAT_MACROS is defined before <inttypes.h> is included."
+ */
+#ifndef	__STDC_FORMAT_MACROS
+#define	__STDC_FORMAT_MACROS
+#endif
+
 #include <cinttypes>
 #include <type_traits>
 
diff -uNr libcxx-3.7.0.src.orig/test/std/language.support/support.dynamic/new.delete/new.delete.array/new_array_nothrow_replace.pass.cpp libcxx-3.7.0.src/test/std/language.support/support.dynamic/new.delete/new.delete.array/new_array_nothrow_replace.pass.cpp
--- libcxx-3.7.0.src.orig/test/std/language.support/support.dynamic/new.delete/new.delete.array/new_array_nothrow_replace.pass.cpp	2015-03-11 10:51:17.000000000 -0400
+++ libcxx-3.7.0.src/test/std/language.support/support.dynamic/new.delete/new.delete.array/new_array_nothrow_replace.pass.cpp	2015-07-04 22:33:31.000000000 -0400
@@ -19,7 +19,10 @@
 
 int new_called = 0;
 
-void* operator new(std::size_t s) throw(std::bad_alloc)
+void* operator new(std::size_t s)
+#if !__has_feature(cxx_noexcept)
+	throw(std::bad_alloc)
+#endif
 {
     ++new_called;
     return std::malloc(s);
diff -uNr libcxx-3.7.0.src.orig/test/support/powerpc-darwin.h libcxx-3.7.0.src/test/support/powerpc-darwin.h
--- libcxx-3.7.0.src.orig/test/support/powerpc-darwin.h	1969-12-31 19:00:00.000000000 -0500
+++ libcxx-3.7.0.src/test/support/powerpc-darwin.h	2015-07-04 22:33:31.000000000 -0400
@@ -0,0 +1,28 @@
+#ifndef	__LIBCXX_TEST_SUPPORT_POWERPC_DARWIN_H__
+#define	__LIBCXX_TEST_SUPPORT_POWERPC_DARWIN_H__
+
+#if defined(__APPLE__) && defined(__ppc__)
+#define	__powerpc_darwin__		1
+#endif
+// control certain workarounds for the powerpc-darwin8 port
+
+/**
+	On PowerPC-darwin, ptrdiff_t is int, but size_t is unsigned long.
+	Tests that rely on is_same<make_unsigned<ptrdiff_t>, size_t>
+	will fail, but as long as the underlying integer types are
+	the same size (which is true on PPC32), then it is still safe.
+ */
+#if defined(__powerpc_darwin__)
+#define	PTRDIFF_T_VS_SIZE_T_DIFFER
+#endif
+
+/**
+	PPC32 doesn't have native 64b atomic operations.
+	Thus, they must be emulated using mutex or lock.
+	TODO: provide specializations of struct atomic using std::mutex.
+	TODO: implement in compiler front-end
+	Undefine the following to enable mutex-based emulated 64b atomics.
+ */
+// #define	MISSING_64B_ATOMIC_OPS
+
+#endif	// __LIBCXX_TEST_SUPPORT_POWERPC_DARWIN_H__
diff -uNr libcxx-3.7.0.src.orig/test/testit libcxx-3.7.0.src/test/testit
--- libcxx-3.7.0.src.orig/test/testit	2014-11-20 08:34:10.000000000 -0500
+++ libcxx-3.7.0.src/test/testit	2015-07-04 22:33:31.000000000 -0400
@@ -24,6 +24,7 @@
 
 cd ..
 LIBCXX_ROOT=`pwd`
+cpd=`echo "$LIBCXX_ROOT" | awk 'BEGIN{FS="/";}{print NF+1;}'`
 cd $origpath
 
 if [ -z "$CC" ]
@@ -36,6 +37,10 @@
 	fi
 fi
 
+if [ -z "$KEEP_EXE" ]
+then
+	KEEP_EXE=1
+fi
 if [ -z "$CXX_LANG" ]
 then
     CXX_LANG=c++11
@@ -56,6 +61,7 @@
        SOURCE_LIB="-L$LIBCXX_ROOT/lib"
 fi
 
+# use distinct test executables (parallelizable)
 case $TRIPLE in
   *-*-mingw* | *-*-cygwin* | *-*-win*)
 	TEST_EXE=test.exe
@@ -78,14 +84,16 @@
 IMPLEMENTED_PASS=0
 
 afunc() {
+	rwd=`pwd | cut -d/ -f$cpd-`
 	fail=0
 	pass=0
 	if (ls ${TEST_PREFIX}*fail.cpp > /dev/null 2>&1)
 	then
 		for FILE in $(ls ${TEST_PREFIX}*fail.cpp); do
-			if $CC $OPTIONS $HEADER_INCLUDE $SOURCE_LIB $FILE $LIBS -o ./$TEST_EXE > /dev/null 2>&1
+			t_exe=`basename $FILE .cpp`
+			if $CC $OPTIONS $HEADER_INCLUDE $SOURCE_LIB $FILE $LIBS -o ./$t_exe > /dev/null 2>&1
 			then
-				rm ./$TEST_EXE
+				test "$KEEP_EXE" = 1 || rm ./$t_exe
 				echo "$FILE should not compile"
 				fail=$(($fail+1))
 			else
@@ -97,24 +105,25 @@
 	if (ls ${TEST_PREFIX}*pass.cpp > /dev/null 2>&1)
 	then
 		for FILE in $(ls ${TEST_PREFIX}*pass.cpp); do
+		t_exe=`basename $FILE .cpp`
             if [ "$VERBOSE" ]
             then
              	echo "Running test: " $FILE
             fi
-			if $CC $OPTIONS $HEADER_INCLUDE $SOURCE_LIB $FILE $LIBS $(test $1 = no || echo $THREAD_FLAGS) -o ./$TEST_EXE
+			if $CC $OPTIONS $HEADER_INCLUDE $SOURCE_LIB $FILE $LIBS $(test $1 = no || echo $THREAD_FLAGS) -o ./$t_exe
 			then
-				if ./$TEST_EXE
+				if ./$t_exe
 				then
-					rm ./$TEST_EXE
+					test "$KEEP_EXE" = 1 || rm ./$t_exe
 					pass=$(($pass+1))
 				else
-					echo "`pwd`/$FILE failed at run time"
+					echo "$rwd/$FILE failed at run time"
 					echo "Compile line was:" $CC $OPTIONS $HEADER_INCLUDE $SOURCE_LIB $FILE $LIBS $(test $1 = no || echo $THREAD_FLAGS)
 					fail=$(($fail+1))
-					rm ./$TEST_EXE
+					test "$KEEP_EXE" = 1 || rm ./$t_exe
 				fi
 			else
-				echo "`pwd`/$FILE failed to compile"
+				echo "$rwd/$FILE failed to compile"
 				echo "Compile line was:" $CC $OPTIONS $HEADER_INCLUDE $SOURCE_LIB $FILE $LIBS $(test $1 = no || echo $THREAD_FLAGS)
 				fail=$(($fail+1))
 			fi
@@ -123,12 +132,12 @@
 
 	if [ $fail -gt 0 ]
 	then
-		echo "failed $fail tests in `pwd`"
+		echo "failed $fail tests in $rwd"
 		IMPLEMENTED_FAIL=$(($IMPLEMENTED_FAIL+1))
 	fi
 	if [ $pass -gt 0 ]
 	then
-		echo "passed $pass tests in `pwd`"
+		echo "passed $pass tests in $rwd"
 		if [ $fail -eq 0 ]
 		then
 			IMPLEMENTED_PASS=$((IMPLEMENTED_PASS+1))
@@ -136,7 +145,7 @@
 	fi
 	if [ $fail -eq 0 -a $pass -eq 0 ]
 	then
-		echo "not implemented:  `pwd`"
+		echo "not implemented:  $rwd"
 		UNIMPLEMENTED=$(($UNIMPLEMENTED+1))
 	fi
 
@@ -163,6 +172,7 @@
 echo "****************************************************"
 echo "Results for `pwd`:"
 echo "using `$CC --version`"
+echo "  (`which $CC`)"
 echo "with $OPTIONS $HEADER_INCLUDE $SOURCE_LIB"
 echo "----------------------------------------------------"
 echo "sections without tests   : $UNIMPLEMENTED"
