diff -ruN grass-6.4.2-old/Makefile.orig grass-6.4.2/Makefile.orig
--- grass-6.4.2-old/Makefile.orig	1970-01-01 09:00:00.000000000 +0900
+++ grass-6.4.2/Makefile.orig	2012-05-08 19:28:42.000000000 +0900
@@ -0,0 +1,391 @@
+#############################################################################
+#
+# MODULE:   	GRASS Compilation
+# AUTHOR(S):	Original author unknown - probably CERL
+#   	    	Justin Hickey - Thailand - jhickey AT hpcc.nectec.or.th
+#		Markus Neteler - Germany - neteler AT itc.it
+#		Andreas Lange - Germany - Andreas.Lange AT Rhein-Main.de
+#		Radim Blazek - Italy - blazek AT itc.it
+# PURPOSE:  	It provides the commands necessary to compile, install,
+#		clean, and uninstall GRASS
+#		See INSTALL file for explanations.
+# COPYRIGHT:    (C) 2002,2004 by the GRASS Development Team
+#
+#               This program is free software under the GNU General Public
+#   	    	License (>=v2). Read the file COPYING that comes with GRASS
+#   	    	for details.
+#
+#############################################################################
+
+MODULE_TOPDIR = .
+
+include $(MODULE_TOPDIR)/include/Make/Platform.make
+include $(MODULE_TOPDIR)/include/Make/Grass.make
+
+# Install directories
+exec_prefix=            ${prefix}
+BINDIR=			${UNIX_BIN}
+
+# Shell commands
+MAKE_DIR_CMD=		mkdir -p -m 755
+
+SUBDIRS = \
+	lib \
+	db \
+	display \
+	doc \
+	general \
+	gui \
+	imagery \
+	misc \
+	ps \
+	raster \
+	raster3d \
+	scripts \
+	sites \
+	tools \
+	vector \
+	visualization \
+	man \
+	macosx
+
+ifeq ($(strip $(MINGW)),)
+	SUBDIRS += gem
+endif
+
+ifneq ($(strip $(HAVE_NLS)),)
+	LOCALE=1
+else
+	LOCALE=0
+endif
+
+FILES = AUTHORS COPYING CHANGES REQUIREMENTS.html GPL.TXT contributors.csv  contributors_extra.csv  translators.csv
+
+BIN_DIST_FILES = $(FILES) \
+	grass${GRASS_VERSION_MAJOR}${GRASS_VERSION_MINOR}.tmp \
+	bin \
+	bwidget \
+	docs \
+	driver \
+	etc \
+	fonts \
+	include \
+	lib \
+	man \
+	scripts \
+	tools
+
+DOXNAME=grass
+
+include $(MODULE_TOPDIR)/include/Make/Docs.make
+include $(MODULE_TOPDIR)/include/Make/Doxygen.make
+
+default: builddemolocation
+	@echo "GRASS GIS compilation log"     > $(ERRORLOG)
+	@echo "-------------------------"    >> $(ERRORLOG)
+	@echo "Started compilation: `date`"  >> $(ERRORLOG)
+	@echo "--"                           >> $(ERRORLOG)
+	@echo "Errors in:"                   >> $(ERRORLOG)
+	chmod 755 install-sh
+	@list='$(SUBDIRS)'; \
+	for subdir in $$list; do \
+		$(MAKE) -C $$subdir; \
+	done
+	$(MAKE) manifests 
+	if [ ${LOCALE} -eq 1 ] ; then $(MAKE) -C locale; fi
+	-cp -f $(FILES) ${ARCH_DISTDIR}/
+	-cp -f ${ARCH_BINDIR}/grass${GRASS_VERSION_MAJOR}${GRASS_VERSION_MINOR} ${ARCH_DISTDIR}/grass${GRASS_VERSION_MAJOR}${GRASS_VERSION_MINOR}.tmp
+	@test -d ${ARCH_DISTDIR}/tools/ || mkdir -p ${ARCH_DISTDIR}/tools/
+	-${INSTALL} tools/mkhtml.sh ${ARCH_DISTDIR}/tools/ 2>/dev/null
+	@test -d ${ARCH_DISTDIR}/tools/g.html2man/ || mkdir -p ${ARCH_DISTDIR}/tools/g.html2man/
+	-${INSTALL} tools/g.html2man/g.html2man ${ARCH_DISTDIR}/tools/g.html2man/ 2>/dev/null
+	@(cd tools ; sh -c "./build_html_index.sh")
+	@if [ `cat "$(ERRORLOG)" | wc -l` -gt 5 ] ; then \
+		echo "--"     >> $(ERRORLOG) ; \
+		echo "In case of errors please change into the directory with error and run 'make'." >> $(ERRORLOG) ; \
+		echo "If you get multiple errors, you need to deal with them in the order they"      >> $(ERRORLOG) ; \
+		echo "appear in the error log. If you get an error building a library, you will"     >> $(ERRORLOG) ; \
+		echo "also get errors from anything which uses the library."  >> $(ERRORLOG) ; \
+	else \
+		echo "No errors detected." >> $(ERRORLOG) ; \
+	fi
+	@echo "--"  >> $(ERRORLOG)
+	@echo "Finished compilation: `date`" >> $(ERRORLOG)
+	@cat $(ERRORLOG)
+	@if [ `cat "$(ERRORLOG)" | wc -l` -gt 8 ] ; then false ; else true ; fi
+
+manifests:
+ifneq ($(strip $(MINGW)),)
+	find $(ARCH_DISTDIR) -type f -name '*.exe' | \
+	while read file ; do \
+	    cmd=`basename "$$file" .exe` ; \
+	    sed "s/@CMD@/$$cmd/" mswindows/generic.manifest > "$$file".manifest ; \
+	done
+endif
+
+LIBDIRS = \
+	lib/external/shapelib \
+	lib/datetime \
+	lib/gis \
+	lib/linkm \
+	lib/db \
+	lib/form \
+	lib/vector \
+	db/drivers
+
+# Compile libraries only
+libs:
+	make -C lib/ headers
+	@list='$(LIBDIRS)'; \
+	for subdir in $$list; do \
+		$(MAKE) -C $$subdir; \
+	done
+	-cp -f $(FILES) ${ARCH_DISTDIR}/
+	-cp -fr --parents include ${ARCH_DISTDIR}/
+
+#we leave this target for a while so that people can easily upgrade (11/2004):
+mix:
+	@echo "NOTE: 'make mix' is no longer needed (changed 9 Nov 2004)"
+
+mixclean:
+	list='$(SUBDIRS)'; \
+	find include -type l -exec rm {} \; 2>/dev/null; \
+	for subdir in $$list; do \
+		find $$subdir -type l -exec rm {} \; 2>/dev/null; \
+	done
+	-rm -f MIX 
+
+# Any target that has a dependency on this target will be forced to be made.
+# If we switch to GNU Make then this feature can be replaced with .PHONY
+FORCE:
+
+cleandistdirs: 
+	-rm -rf ${ARCH_DISTDIR}/bin/         2>/dev/null
+	-rm -rf ${ARCH_DISTDIR}/bwidget/     2>/dev/null
+	-rm -rf ${ARCH_DISTDIR}/docs/        2>/dev/null
+	-rm -rf ${ARCH_DISTDIR}/driver/      2>/dev/null
+	-rm -rf ${ARCH_DISTDIR}/etc/         2>/dev/null
+	-rm -rf ${ARCH_DISTDIR}/fonts/       2>/dev/null
+	-rm -rf ${ARCH_DISTDIR}/include/     2>/dev/null
+	-rm -rf ${ARCH_DISTDIR}/lib/         2>/dev/null
+	-rm -rf ${ARCH_DISTDIR}/locale/      2>/dev/null
+	-rm -rf ${ARCH_DISTDIR}/man/         2>/dev/null
+	-rm -rf ${ARCH_DISTDIR}/scripts/     2>/dev/null
+	-rm -rf ${ARCH_DISTDIR}/demolocation/ 2>/dev/null
+	-rm -rf ${ARCH_DISTDIR}/tcltkgrass/  2>/dev/null
+	-rm -rf ${ARCH_DISTDIR}/tools/       2>/dev/null
+	-rm -f ${ARCH_DISTDIR}/AUTHORS ${ARCH_DISTDIR}/CHANGES ${ARCH_DISTDIR}/REQUIREMENTS.html ${ARCH_DISTDIR}/COPYING ${ARCH_DISTDIR}/GPL.TXT \
+		${ARCH_DISTDIR}/contributors.csv ${ARCH_DISTDIR}/contributors_extra.csv  ${ARCH_DISTDIR}/translators.csv \
+		${ARCH_DISTDIR}/grass${GRASS_VERSION_MAJOR}${GRASS_VERSION_MINOR}.tmp 2>/dev/null
+	-rmdir ${ARCH_DISTDIR}
+	-rm -f ${ARCH_BINDIR}/grass${GRASS_VERSION_MAJOR}${GRASS_VERSION_MINOR} 2>/dev/null
+	-rm -f ${ARCH_BINDIR}/grass${GRASS_VERSION_MAJOR}${GRASS_VERSION_MINOR}.bat 2>/dev/null
+	-rmdir ${ARCH_BINDIR}
+
+# Clean out the strings extracted from scripts for translation
+cleanscriptstrings:
+	rm -f locale/scriptstrings/*.c 2>/dev/null
+
+clean: cleandistdirs cleanscriptstrings cleandocs
+	@list='$(SUBDIRS)'; \
+	for subdir in $$list; do \
+		$(MAKE) -C $$subdir clean; \
+	done
+
+libsclean: cleandistdirs
+	@list='$(LIBDIRS)'; \
+	for subdir in $$list; do \
+		$(MAKE) -C $$subdir clean; \
+	done
+
+distclean: clean
+	-rm -f config.cache config.log config.status config.status.${ARCH} 2>/dev/null
+	-rm -f ChangeLog ChangeLog.bak $(ERRORLOG) grass.pc
+	-rm -f include/config.h include/version.h include/winname.h include/Make/Grass.make 2>/dev/null
+	-rm -f include/Make/Platform.make include/Make/Doxyfile_arch_html include/Make/Doxyfile_arch_latex 2>/dev/null
+
+strip: FORCE
+	@ if [ ! -f ${ARCH_BINDIR}/grass${GRASS_VERSION_MAJOR}${GRASS_VERSION_MINOR} ] ; then \
+		echo "ERROR: GRASS has not been compiled. Try \"make\" first."; \
+		echo "  Strip aborted, exiting Make."; \
+		exit; \
+	fi; \
+	cd ${ARCH_DISTDIR} ; find . -type f -perm +111 -exec strip {} \;
+
+install: FORCE
+	@ # The following action MUST be a single action. That is, all lines
+	@ # except the last line must have a backslash (\) at the end to
+	@ # continue the statement. The reason for this is that Make does not
+	@ # have an exit command thus, exit terminates the shell. However, 
+	@ # Make creates a new shell for each action listed for a target.
+	@ # Therefore, the only way exit will quit Make is if there is only
+	@ # a single action for the target.
+	@ # Check if grass has been compiled, if INST_DIR is writable, and if
+	@ # grass is part of INST_DIR
+	echo ${ARCH_BINDIR}/grass${GRASS_VERSION_MAJOR}${GRASS_VERSION_MINOR}
+	@ if [ ! -f ${ARCH_BINDIR}/grass${GRASS_VERSION_MAJOR}${GRASS_VERSION_MINOR} ] ; then \
+		echo "ERROR: GRASS has not been compiled. Try \"make\" first."; \
+		echo "  Installation aborted, exiting Make."; \
+		exit; \
+	fi; \
+	if [ "${MACOSX_APP}" = "1" ] ; then \
+		${MAKE} install-macosx; \
+		exit; \
+	fi; \
+	INST_PATH=`dirname ${INST_DIR}`; \
+	while [ ! -d $$INST_PATH ]; do \
+		INST_PATH=`dirname $$INST_PATH`; \
+	done; \
+	if [ ! -d "${INST_DIR}" -a ! -w "$$INST_PATH" ] ; then \
+		echo "ERROR: Directory $$INST_PATH is a parent directory of your"; \
+		echo "  install directory ${INST_DIR} and is not writable."; \
+		echo "  Perhaps you need root access."; \
+		echo "  Installation aborted, exiting Make."; \
+		exit; \
+	fi; \
+	if [ -d ${INST_DIR} -a ! -w "${INST_DIR}" ] ; then \
+		echo "ERROR: Your install directory ${INST_DIR} is not writable."; \
+		echo "  Perhaps you need root access."; \
+		echo "  Installation aborted, exiting Make."; \
+		exit; \
+	fi; \
+	result=`echo "${INST_DIR}" | awk '{ if ($$1 ~ /grass/) print $$1 }'`; \
+	if [ "$$result" = "" ] ; then \
+		echo "WARNING: Your install directory ${INST_DIR}"; \
+		echo "  does not contain the word 'grass'."; \
+		echo "  It is highly recommended that the word 'grass' be part"; \
+		echo "  of your install directory to avoid conflicts."; \
+		echo "  Do you want to continue? [y/n]"; \
+		read ans; \
+		ans=`echo "$$ans" | tr A-Z a-z`; \
+		if [ "$$ans" != "y" ] ; then \
+			echo "Installation aborted, exiting Make."; \
+			exit; \
+		fi; \
+	fi; \
+	${MAKE} real-install
+
+real-install: FORCE
+	test -d ${INST_DIR} || ${MAKE_DIR_CMD} ${INST_DIR}
+	@##### test -d ${INST_DIR}/dev || ${MAKE_DIR_CMD} ${INST_DIR}/dev
+	test -d ${BINDIR} || ${MAKE_DIR_CMD} ${BINDIR}
+	-sed -e "s#GISBASE=.*#GISBASE=${INST_DIR}#" ${ARCH_BINDIR}/grass${GRASS_VERSION_MAJOR}${GRASS_VERSION_MINOR} > ${BINDIR}/grass${GRASS_VERSION_MAJOR}${GRASS_VERSION_MINOR}
+	-chmod a+x ${BINDIR}/grass${GRASS_VERSION_MAJOR}${GRASS_VERSION_MINOR}
+	-cd ${GISBASE} ; tar cBf - $(FILES) | (cd ${INST_DIR} ; tar xBf - ) 2>/dev/null
+	-cd ${GISBASE} ; tar cBf - bin | (cd ${INST_DIR} ; tar xBf - ) 2>/dev/null
+	-cd ${GISBASE} ; tar cBf - bwidget | (cd ${INST_DIR} ; tar xBf - ) 2>/dev/null
+	-cd ${GISBASE} ; tar cBf - docs | (cd ${INST_DIR} ; tar xBf - ) 2>/dev/null
+	-cd ${GISBASE} ; tar cBf - driver | (cd ${INST_DIR} ; tar xBf - ) 2>/dev/null
+	-cd ${GISBASE} ; tar cBf - etc | (cd ${INST_DIR} ; tar xBf - ) 2>/dev/null
+	-cd ${GISBASE} ; tar cBf - fonts | (cd ${INST_DIR} ; tar xBf - ) 2>/dev/null
+ifeq ($(strip $(MINGW)),)
+	-cd ${GISBASE} ; tar cBf - man | (cd ${INST_DIR} ; tar xBf - ) 2>/dev/null
+endif
+	-cd ${GISBASE} ; tar cBf - scripts | (cd ${INST_DIR} ; tar xBf - ) 2>/dev/null
+	-cd ${GISBASE} ; tar cBf - tools | (cd ${INST_DIR} ; tar xBf - ) 2>/dev/null
+	if [ ${LOCALE} -eq 1 ] ; then cd ${GISBASE} ; tar cBf - locale | (cd ${INST_DIR} ; tar xBf - ) 2>/dev/null ; fi
+	@ # The man, include, and lib could go to ${PREFIX}/ BUT if this is
+	@ # done, then the corresponding uninstall instructions must delete
+	@ # the grass files BY FILENAME NOT DIRECTORY!! Otherwise there is a
+	@ # high risk of deleteing system files since PREFIX is defined by
+	@ # default to be /usr/local
+	@##### -cd ${GISBASE} ; tar cBf - man | (cd ${INST_DIR} ; tar xBf - ) 2>/dev/null
+	-cd ${GISBASE} ; tar cBf - include | (cd ${INST_DIR} ; tar xBf - ) 2>/dev/null
+	-sed -e "s#^\(GRASS_HOME.[^=]*\).*#\1= ${INST_DIR}#" -e "s#^\(RUN_GISBASE.[^=]*\).*#\1= ${INST_DIR}#" ${GISBASE}/include/Make/Platform.make > ${INST_DIR}/include/Make/Platform.make
+	-sed -e "s#^\(ARCH_DISTDIR.[^=]*\).*#\1= ${INST_DIR}#" -e "s#^\(ARCH_BINDIR.[^=]*\).*#\1= ${UNIX_BIN}#" ${GISBASE}/include/Make/Grass.make > ${INST_DIR}/include/Make/Grass.make
+	-sed -e 's#/tools/g.html2man/g.html2man#/tools/g.html2man#' ${GISBASE}/include/Make/Man.make > ${INST_DIR}/include/Make/Man.make
+	-cd ${GISBASE} ; tar cBf - lib | (cd ${INST_DIR} ; tar xBf - ) 2>/dev/null
+	-sed 's#'${GISBASE}'#'${INST_DIR}'#g' ${GISBASE}/etc/monitorcap > ${INST_DIR}/etc/monitorcap
+	-sed 's#'${GISBASE}'#'${INST_DIR}'#g' ${GISBASE}/etc/fontcap > ${INST_DIR}/etc/fontcap
+	@##### -chmod -R 1777 ${INST_DIR}/locks 2>/dev/null
+	-chmod -R a+rX ${INST_DIR} 2>/dev/null
+ifeq ($(strip $(MINGW)),)
+	@#GEM installation
+	-tar cBf - gem/skeleton | (cd ${INST_DIR}/etc ; tar xBf - ) 2>/dev/null
+	-${INSTALL} gem/gem$(GRASS_VERSION_MAJOR)$(GRASS_VERSION_MINOR) ${BINDIR} 2>/dev/null
+endif
+	@# enable OSX Help Viewer
+	@if [ "`cat include/Make/Platform.make | grep -i '^ARCH.*darwin'`" ] ; then /bin/ln -sfh "${INST_DIR}/docs/html" /Library/Documentation/Help/GRASS-${GRASS_VERSION_MAJOR}.${GRASS_VERSION_MINOR} ; fi
+
+
+install-strip: FORCE
+	${MAKE} strip
+	${MAKE} install
+
+install-macosx: FORCE
+	${MAKE} -C macosx install-macosx
+
+bindist:  
+	if [ "${MACOSX_APP}" = "1" ] ; then \
+		${MAKE} bindist-macosx; \
+		exit; \
+	fi; \
+	${MAKE} real-bindist
+
+real-bindist:
+	mkdir -p ${ARCH_DISTDIR}/etc/nad/src ; \
+	    cp -f ${MODULE_TOPDIR}/lib/proj/*.lla ${ARCH_DISTDIR}/etc/nad/src ; true
+	( date=`date '+%d_%m_%Y'`; cd ${ARCH_DISTDIR}; tar cBf - ${BIN_DIST_FILES} | gzip -fc > ../grass-${GRASS_VERSION_MAJOR}.${GRASS_VERSION_MINOR}.${GRASS_VERSION_RELEASE}-${ARCH}-$$date.tar.gz)
+	-date=`date '+%d_%m_%Y'`; name=grass-${GRASS_VERSION_MAJOR}.${GRASS_VERSION_MINOR}.${GRASS_VERSION_RELEASE}-${ARCH}-$$date.tar.gz; \
+            size=`ls -l $$name | awk '{print $$5}'`; \
+	    sed -e "s/BIN_DIST_VERSION/${GRASS_VERSION_MAJOR}.${GRASS_VERSION_MINOR}.${GRASS_VERSION_RELEASE}-${ARCH}-$$date/" \
+	    -e "s/GRASSPRG_NAME/grass${GRASS_VERSION_MAJOR}${GRASS_VERSION_MINOR}/" \
+	    -e "s/SIZE_TAR_FILE/$$size/" -e "s#BIN_DIST_DIR#'${INST_DIR}'#" \
+	    -e "s/ARCHITECTURE/${ARCH}/" \
+	    -e "s/LD_LIBRARY_PATH_VAR/${LD_LIBRARY_PATH_VAR}/" \
+	    -e "s/TEST_STR=/TEST_STR=executable/" \
+	    -e "s#IMPORTANT.*#Generated from the binaryInstall.src file using the command make bindist#" \
+	    -e "s/# executable shell.*//" -e "s/# make bindist.*//" \
+	    binaryInstall.src > grass-${GRASS_VERSION_MAJOR}.${GRASS_VERSION_MINOR}.${GRASS_VERSION_RELEASE}-${ARCH}-$$date-install.sh ; \
+	    chmod a+x grass-${GRASS_VERSION_MAJOR}.${GRASS_VERSION_MINOR}.${GRASS_VERSION_RELEASE}-${ARCH}-$$date-install.sh 2>/dev/null
+
+bindist-macosx:
+	${MAKE} -C macosx bindist-macosx
+
+# make a source package for distribution:
+srcdist: FORCE distclean
+	-${MAKE_DIR_CMD} ./grass-${GRASS_VERSION_MAJOR}.${GRASS_VERSION_MINOR}.${GRASS_VERSION_RELEASE}
+
+	@ # needed to store code in package with grass-version path:
+	-mv * ./grass-${GRASS_VERSION_MAJOR}.${GRASS_VERSION_MINOR}.${GRASS_VERSION_RELEASE}
+	@ # do not include the debian control files:
+	-mv ./grass-${GRASS_VERSION_MAJOR}.${GRASS_VERSION_MINOR}.${GRASS_VERSION_RELEASE}/debian .
+	@ #we use -h to get the linked files into as real files:
+	tar cvfzh grass-${GRASS_VERSION_MAJOR}.${GRASS_VERSION_MINOR}.${GRASS_VERSION_RELEASE}.tar.gz ./grass-${GRASS_VERSION_MAJOR}.${GRASS_VERSION_MINOR}.${GRASS_VERSION_RELEASE}/* --exclude=CVS
+	@ # restore src code location:
+	-mv ./grass-${GRASS_VERSION_MAJOR}.${GRASS_VERSION_MINOR}.${GRASS_VERSION_RELEASE}/* .
+	-rmdir ./grass-${GRASS_VERSION_MAJOR}.${GRASS_VERSION_MINOR}.${GRASS_VERSION_RELEASE}
+	@ echo "Distribution source package: grass-${GRASS_VERSION_MAJOR}.${GRASS_VERSION_MINOR}.${GRASS_VERSION_RELEASE}.tar.gz ready. Calculating MD5 sum..."
+	md5sum grass-${GRASS_VERSION_MAJOR}.${GRASS_VERSION_MINOR}.${GRASS_VERSION_RELEASE}.tar.gz > grass-${GRASS_VERSION_MAJOR}.${GRASS_VERSION_MINOR}.${GRASS_VERSION_RELEASE}.md5sum
+
+# make a source package for library distribution:
+srclibsdist: FORCE distclean
+	-${MAKE_DIR_CMD} ./grass-lib-${GRASS_VERSION_MAJOR}.${GRASS_VERSION_MINOR}.${GRASS_VERSION_RELEASE}
+
+	@ # needed to store code in package with grass-version path:
+	-cp -L * ./grass-lib-${GRASS_VERSION_MAJOR}.${GRASS_VERSION_MINOR}.${GRASS_VERSION_RELEASE}
+	-cp -rL tools ./grass-lib-${GRASS_VERSION_MAJOR}.${GRASS_VERSION_MINOR}.${GRASS_VERSION_RELEASE}
+	-cp -rL include ./grass-lib-${GRASS_VERSION_MAJOR}.${GRASS_VERSION_MINOR}.${GRASS_VERSION_RELEASE}
+	-cp -rL --parents lib/external/shapelib ./grass-lib-${GRASS_VERSION_MAJOR}.${GRASS_VERSION_MINOR}.${GRASS_VERSION_RELEASE}
+	-cp -rL --parents lib/datetime ./grass-lib-${GRASS_VERSION_MAJOR}.${GRASS_VERSION_MINOR}.${GRASS_VERSION_RELEASE}
+	-cp -rL --parents lib/db ./grass-lib-${GRASS_VERSION_MAJOR}.${GRASS_VERSION_MINOR}.${GRASS_VERSION_RELEASE}
+	-cp -rL --parents lib/gis ./grass-lib-${GRASS_VERSION_MAJOR}.${GRASS_VERSION_MINOR}.${GRASS_VERSION_RELEASE}
+	-cp -rL --parents lib/linkm ./grass-lib-${GRASS_VERSION_MAJOR}.${GRASS_VERSION_MINOR}.${GRASS_VERSION_RELEASE}
+	-cp -rL --parents lib/form ./grass-lib-${GRASS_VERSION_MAJOR}.${GRASS_VERSION_MINOR}.${GRASS_VERSION_RELEASE}
+	-cp -rL --parents lib/vector ./grass-lib-${GRASS_VERSION_MAJOR}.${GRASS_VERSION_MINOR}.${GRASS_VERSION_RELEASE}
+
+	-cp -rL --parents db/drivers ./grass-lib-${GRASS_VERSION_MAJOR}.${GRASS_VERSION_MINOR}.${GRASS_VERSION_RELEASE}
+
+	tar chvfz grass-lib-${GRASS_VERSION_MAJOR}.${GRASS_VERSION_MINOR}.${GRASS_VERSION_RELEASE}.tar.gz ./grass-lib-${GRASS_VERSION_MAJOR}.${GRASS_VERSION_MINOR}.${GRASS_VERSION_RELEASE}/* --exclude=CVS
+	-rm -r ./grass-lib-${GRASS_VERSION_MAJOR}.${GRASS_VERSION_MINOR}.${GRASS_VERSION_RELEASE}
+	@ echo "Distribution source package: grass-lib-${GRASS_VERSION_MAJOR}.${GRASS_VERSION_MINOR}.${GRASS_VERSION_RELEASE}.tar.gz ready."
+
+builddemolocation:
+	test -d ${ARCH_DISTDIR} || ${MAKE_DIR_CMD} ${ARCH_DISTDIR}
+	-tar cBf - demolocation | (cd ${ARCH_DISTDIR}/ ; tar xBfo - ) 2>/dev/null
+	@ echo "GISDBASE: ${RUN_GISBASE}" > ${RUN_GISRC}
+	@ echo "LOCATION_NAME: demolocation" >> ${RUN_GISRC}
+	@ echo "MAPSET: PERMANENT" >> ${RUN_GISRC}
+	@ echo "GRASS_DB_ENCODING: utf-8" >> ${RUN_GISRC}
+	@ echo "DEBUG: 0" >> ${RUN_GISRC}
+	@ echo "GRASS_GUI: text" >> ${RUN_GISRC}
diff -ruN grass-6.4.2-old/Makefile.rej grass-6.4.2/Makefile.rej
--- grass-6.4.2-old/Makefile.rej	1970-01-01 09:00:00.000000000 +0900
+++ grass-6.4.2/Makefile.rej	2012-05-08 19:28:45.000000000 +0900
@@ -0,0 +1,51 @@
+***************
+*** 9,15 ****
+  	MACOSX_APP_NAME = GRASS-${GRASS_VERSION_MAJOR}.${GRASS_VERSION_MINOR}.app
+  endif
+  MACOSX_APPDIR = ${MACOSX_APP_NAME}/Contents/MacOS
+- INST_DIR_MACOSX = ${prefix}/${MACOSX_APPDIR}
+  
+  default: modbuild
+  
+--- 9,15 ----
+  	MACOSX_APP_NAME = GRASS-${GRASS_VERSION_MAJOR}.${GRASS_VERSION_MINOR}.app
+  endif
+  MACOSX_APPDIR = ${MACOSX_APP_NAME}/Contents/MacOS
++ INST_DIR_MACOSX = ${INST_DIR}/Applications/${MACOSX_APPDIR}
+  
+  default: modbuild
+  
+***************
+*** 19,25 ****
+  	-cp -f ReadMe.rtf $(ARCH_DISTDIR)/modbuild/
+  	mkdir -p $(ARCH_DISTDIR)/modbuild/dist.$(ARCH)
+  	-cp -rf $(ARCH_DISTDIR)/demolocation $(ARCH_DISTDIR)/modbuild/dist.$(ARCH)/
+- 	-sed -e 's,^GISDBASE.*,GISDBASE = /Library/GRASS/$(GRASS_VERSION_MAJOR).$(GRASS_VERSION_MINOR)/modbuild/dist.$(ARCH),g' $(ARCH_DISTDIR)/demolocation/.grassrc$(GRASS_VERSION_MAJOR)$(GRASS_VERSION_MINOR) > $(ARCH_DISTDIR)/modbuild/dist.$(ARCH)/demolocation/.grassrc$(GRASS_VERSION_MAJOR)$(GRASS_VERSION_MINOR)
+  	mkdir -p $(ARCH_DISTDIR)/modbuild/module
+  	mkdir -p $(ARCH_DISTDIR)/modbuild/include/Make
+  	-cp $(MODULE_TOPDIR)/include/Make/Dir.make $(ARCH_DISTDIR)/modbuild/include/Make/
+--- 19,25 ----
+  	-cp -f ReadMe.rtf $(ARCH_DISTDIR)/modbuild/
+  	mkdir -p $(ARCH_DISTDIR)/modbuild/dist.$(ARCH)
+  	-cp -rf $(ARCH_DISTDIR)/demolocation $(ARCH_DISTDIR)/modbuild/dist.$(ARCH)/
++ 	-sed -e 's,^GISDBASE.*,GISDBASE = @PREFIX@/lib/GRASS/$(GRASS_VERSION_MAJOR).$(GRASS_VERSION_MINOR)/modbuild/dist.$(ARCH),g' $(ARCH_DISTDIR)/demolocation/.grassrc$(GRASS_VERSION_MAJOR)$(GRASS_VERSION_MINOR) > $(ARCH_DISTDIR)/modbuild/dist.$(ARCH)/demolocation/.grassrc$(GRASS_VERSION_MAJOR)$(GRASS_VERSION_MINOR)
+  	mkdir -p $(ARCH_DISTDIR)/modbuild/module
+  	mkdir -p $(ARCH_DISTDIR)/modbuild/include/Make
+  	-cp $(MODULE_TOPDIR)/include/Make/Dir.make $(ARCH_DISTDIR)/modbuild/include/Make/
+***************
+*** 44,50 ****
+  	@#GISBASE = $(INST_DIR_MACOSX)\
+  	@#endif#g'
+  	@# html.make needs a little change
+- 	sed -e 's,GISRC=$$(RUN_GISBASE),GISRC=/Library/GRASS/$(GRASS_VERSION_MAJOR).$(GRASS_VERSION_MINOR)/modbuild/dist.$$(ARCH),g' $(MODULE_TOPDIR)/include/Make/Html.make > $(ARCH_DISTDIR)/modbuild/include/Make/Html.make
+  	-cp $(MODULE_TOPDIR)/include/Make/Lib.make $(ARCH_DISTDIR)/modbuild/include/Make/
+  	-cp $(MODULE_TOPDIR)/include/Make/Man.make $(ARCH_DISTDIR)/modbuild/include/Make/
+  	sed -e 's,$$(DEPENDENCIES),,g' $(MODULE_TOPDIR)/include/Make/Module.make > $(ARCH_DISTDIR)/modbuild/include/Make/Module.make
+--- 44,50 ----
+  	@#GISBASE = $(INST_DIR_MACOSX)\
+  	@#endif#g'
+  	@# html.make needs a little change
++ 	sed -e 's,GISRC=$$(RUN_GISBASE),GISRC=@PREFIX@/lib/GRASS/$(GRASS_VERSION_MAJOR).$(GRASS_VERSION_MINOR)/modbuild/dist.$$(ARCH),g' $(MODULE_TOPDIR)/include/Make/Html.make > $(ARCH_DISTDIR)/modbuild/include/Make/Html.make
+  	-cp $(MODULE_TOPDIR)/include/Make/Lib.make $(ARCH_DISTDIR)/modbuild/include/Make/
+  	-cp $(MODULE_TOPDIR)/include/Make/Man.make $(ARCH_DISTDIR)/modbuild/include/Make/
+  	sed -e 's,$$(DEPENDENCIES),,g' $(MODULE_TOPDIR)/include/Make/Module.make > $(ARCH_DISTDIR)/modbuild/include/Make/Module.make
diff -ruN grass-6.4.2-old/include/iostream/ami_stream.h grass-6.4.2/include/iostream/ami_stream.h
--- grass-6.4.2-old/include/iostream/ami_stream.h	2012-05-08 19:28:12.000000000 +0900
+++ grass-6.4.2/include/iostream/ami_stream.h	2012-05-08 19:28:50.000000000 +0900
@@ -140,7 +140,7 @@
   AMI_STREAM();
   
   // An AMI stream based on a specific path name.
-  AMI_STREAM(const char *path_name, AMI_stream_type st);
+  AMI_STREAM(const char *path_name, AMI_stream_type st = AMI_READ_WRITE_STREAM);
 
   // convenience function with split path_name
   //AMI_STREAM(const char *dir_name, const char *file_name, AMI_stream_type st);
@@ -156,7 +156,7 @@
   // Read and write elements.
   AMI_err read_item(T **elt);
   AMI_err write_item(const T &elt);
-  AMI_err read_array(T *data, off_t len, off_t *lenp);
+  AMI_err read_array(T *data, off_t len, off_t *lenp=NULL);
   AMI_err write_array(const T *data, off_t len);
   
   // Return the number of items in the stream.
@@ -172,7 +172,7 @@
   // Query memory usage
   static AMI_err main_memory_usage(size_t *usage,
 			    //MM_stream_usage usage_type= MM_STREAM_USAGE_OVERHEAD);
-			    MM_stream_usage usage_type);
+			    MM_stream_usage usage_type = MM_STREAM_USAGE_OVERHEAD);
   
   void persist(persistence p);
   
@@ -249,7 +249,7 @@
 // An AMI stream based on a specific path name.
 template<class T>
 AMI_STREAM<T>::AMI_STREAM(const char *path_name,
-			  AMI_stream_type st = AMI_READ_WRITE_STREAM) {
+			  AMI_stream_type st) {
 
   access_mode = st;
 
@@ -467,7 +467,7 @@
 template<class T>
 AMI_err
 AMI_STREAM<T>::main_memory_usage(size_t *usage,
-								 MM_stream_usage usage_type= MM_STREAM_USAGE_OVERHEAD) {
+								 MM_stream_usage usage_type) {
   
    switch (usage_type) {
    case MM_STREAM_USAGE_OVERHEAD:
@@ -546,7 +546,7 @@
 
 /**********************************************************************/
 template<class T>
-AMI_err AMI_STREAM<T>::read_array(T *data, off_t len, off_t *lenp=NULL) {
+AMI_err AMI_STREAM<T>::read_array(T *data, off_t len, off_t *lenp) {
   size_t nobj;
   assert(fp);
   
diff -ruN grass-6.4.2-old/include/iostream/ami_stream.h.orig grass-6.4.2/include/iostream/ami_stream.h.orig
--- grass-6.4.2-old/include/iostream/ami_stream.h.orig	1970-01-01 09:00:00.000000000 +0900
+++ grass-6.4.2/include/iostream/ami_stream.h.orig	2011-12-19 13:45:29.000000000 +0900
@@ -0,0 +1,660 @@
+/****************************************************************************
+ * 
+ *  MODULE:	iostream
+ *
+ *  COPYRIGHT (C) 2007 Laura Toma
+ *   
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *****************************************************************************/
+
+
+#ifndef _AMI_STREAM_H
+#define _AMI_STREAM_H
+
+
+#include <sys/types.h>
+#include <sys/stat.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include <assert.h>
+#include <fcntl.h>
+#include <errno.h>
+#include <unistd.h>
+
+#include <cstring>
+#include <iostream>
+using namespace std;
+
+#include <grass/config.h>
+
+#define MAX_STREAMS_OPEN 200
+
+#include "mm.h" // Get the memory manager.
+
+#define DEBUG_DELETE if(0)
+#define DEBUG_ASSERT if(0)
+
+// The name of the environment variable which keeps the name of the
+// directory where streams are stored
+#define STREAM_TMPDIR "STREAM_DIR"
+
+// All streams will be names STREAM_*****
+#define BASE_NAME "STREAM"
+
+#define STREAM_BUFFER_SIZE (1<<18)
+
+
+//
+// AMI error codes are returned using the AMI_err type.
+//
+enum AMI_err {
+  AMI_ERROR_NO_ERROR = 0,
+  AMI_ERROR_IO_ERROR,
+  AMI_ERROR_END_OF_STREAM,
+  AMI_ERROR_OUT_OF_RANGE,
+  AMI_ERROR_READ_ONLY,
+  AMI_ERROR_OS_ERROR,
+  AMI_ERROR_MM_ERROR,
+  AMI_ERROR_OBJECT_INITIALIZATION,
+  AMI_ERROR_PERMISSION_DENIED,
+  AMI_ERROR_INSUFFICIENT_MAIN_MEMORY,
+  AMI_ERROR_INSUFFICIENT_AVAILABLE_STREAMS,
+  AMI_ERROR_ENV_UNDEFINED,
+  AMI_ERROR_NO_MAIN_MEMORY_OPERATION,
+};
+
+extern char *ami_str_error[];
+
+//
+// AMI stream types passed to constructors
+//
+enum AMI_stream_type {
+    AMI_READ_STREAM = 1,	// Open existing stream for reading
+    AMI_WRITE_STREAM,		// Open for writing.  Create if non-existent
+    AMI_APPEND_STREAM,		// Open for writing at end.  Create if needed.
+    AMI_READ_WRITE_STREAM,	// Open to read and write.
+    AMI_APPEND_WRITE_STREAM     // Open for writing at end (write only mode).
+};
+
+
+
+
+enum persistence {
+    // Delete the stream from the disk when it is destructed.
+  PERSIST_DELETE = 0,
+  // Do not delete the stream from the disk when it is destructed.
+  PERSIST_PERSISTENT,
+  // Delete each block of data from the disk as it is read.
+  PERSIST_READ_ONCE
+};
+
+/* an un-templated version makes for easier debugging */
+class UntypedStream {
+protected:
+  FILE * fp;
+  int fildes;	//descriptor of file
+  AMI_stream_type  access_mode;
+  char path[BUFSIZ];
+  persistence per;
+
+  //0 for streams, positive for substreams
+  unsigned int substream_level;
+  
+  // If this stream is actually a substream, these will be set to
+  // indicate the portion of the file that is part of this stream.  If
+  // the stream is the whole file, they will be set to -1. Both are in
+  // T units.
+  off_t logical_bos;
+  off_t logical_eos;
+
+  //stream buffer passed in the call to setvbuf when file is opened
+  char* buf;
+  int eof_reached;
+
+ public:
+  static unsigned int get_block_length()  {
+    return STREAM_BUFFER_SIZE;
+    //return getpagesize();
+  };
+
+};
+
+template<class T> 
+class AMI_STREAM : public UntypedStream {
+
+protected:
+
+  T read_tmp;					/* this is ugly... RW */
+
+public:
+  // An AMI_stream with default name
+  AMI_STREAM();
+  
+  // An AMI stream based on a specific path name.
+  AMI_STREAM(const char *path_name, AMI_stream_type st);
+
+  // convenience function with split path_name
+  //AMI_STREAM(const char *dir_name, const char *file_name, AMI_stream_type st);
+  
+  
+  // A psuedo-constructor for substreams.
+  AMI_err new_substream(AMI_stream_type st, off_t sub_begin, off_t sub_end,
+			AMI_STREAM<T> **sub_stream);
+
+  // Destructor
+  ~AMI_STREAM(void);
+  
+  // Read and write elements.
+  AMI_err read_item(T **elt);
+  AMI_err write_item(const T &elt);
+  AMI_err read_array(T *data, off_t len, off_t *lenp);
+  AMI_err write_array(const T *data, off_t len);
+  
+  // Return the number of items in the stream.
+  off_t stream_len(void);
+  
+  // Return the path name of this stream.
+  AMI_err name(char **stream_name);
+  const char* name() const;
+  
+  // Move to a specific item in the stream.
+  AMI_err seek(off_t offset);
+
+  // Query memory usage
+  static AMI_err main_memory_usage(size_t *usage,
+			    //MM_stream_usage usage_type= MM_STREAM_USAGE_OVERHEAD);
+			    MM_stream_usage usage_type);
+  
+  void persist(persistence p);
+  
+  char *sprint();
+
+  // have we hit the end of the stream
+  int eof();
+};
+
+
+/**********************************************************************/
+
+
+/**********************************************************************/
+/* creates a random file name, opens the file for reading and writing
+   and and returns a file descriptor */
+/* int ami_single_temp_name(char *base, char* tmp_path); */
+/* fix from Andy Danner */
+int ami_single_temp_name(const std::string& base, char* tmp_path); 
+
+
+/**********************************************************************/
+/* given fd=fide descriptor, associates with it a stream aopened in
+   access_mode and returns it */
+FILE*  open_stream(int fd, AMI_stream_type st);
+
+
+/**********************************************************************/
+/* open the file whose name is pathname in access mode */
+FILE* open_stream(char* pathname, AMI_stream_type st);
+
+
+
+
+/********************************************************************/
+//  An  AMI stream with default name.
+template<class T>
+AMI_STREAM<T>::AMI_STREAM() {
+  
+  access_mode = AMI_READ_WRITE_STREAM;
+  int fd = ami_single_temp_name(BASE_NAME, path);
+  fildes = fd;
+  fp = open_stream(fd, access_mode);
+  
+  /* a stream is by default buffered with a buffer of size BUFSIZ=1K */
+  buf = new char[STREAM_BUFFER_SIZE];
+  if (setvbuf(fp, buf, _IOFBF, STREAM_BUFFER_SIZE) != 0) {
+    cerr << "ERROR: setvbuf failed (stream " << path << ") with: "
+         << strerror(errno) << endl;
+    exit(1);
+  }
+  
+  // By default, all streams are deleted at destruction time.
+  per = PERSIST_DELETE;
+
+   // Not a substream.
+  substream_level  = 0;
+  logical_bos = logical_eos = -1;
+
+  // why is this here in the first place?? -RW
+  seek(0);
+
+  eof_reached = 0;
+
+  // Register memory usage before returning.
+  //size_t usage; 
+  //main_memory_usage(&usage,  MM_STREAM_USAGE_CURRENT);
+  //MM_manager.register_allocation(usage);
+}
+
+
+
+/**********************************************************************/
+// An AMI stream based on a specific path name.
+template<class T>
+AMI_STREAM<T>::AMI_STREAM(const char *path_name,
+			  AMI_stream_type st = AMI_READ_WRITE_STREAM) {
+
+  access_mode = st;
+
+  if(path_name == NULL) {
+	int fd = ami_single_temp_name(BASE_NAME, path);
+	fildes = fd;
+	fp = open_stream(fd, access_mode);
+  } else {
+	strcpy(path, path_name);
+	fp = open_stream(path, st);  
+	fildes = -1;
+  }
+
+  /* a stream is by default buffered with a buffer of size BUFSIZ=1K */
+  buf = new char[STREAM_BUFFER_SIZE];
+  if (setvbuf(fp, buf, _IOFBF, STREAM_BUFFER_SIZE) != 0) {
+    cerr << "ERROR: setvbuf failed (stream " << path << ") with: "
+         << strerror(errno) << endl;
+    exit(1);
+  }
+
+  eof_reached = 0;
+
+  // By default, all streams are deleted at destruction time.
+  if(st == AMI_READ_STREAM) {
+	per = PERSIST_PERSISTENT;
+  } else {
+	per = PERSIST_DELETE;
+  }
+
+  // Not a substream.
+  substream_level  = 0;
+  logical_bos = logical_eos = -1;
+  
+  seek(0);
+
+  // Register memory usage before returning.
+  //size_t usage; 
+  //main_memory_usage(&usage,  MM_STREAM_USAGE_CURRENT);
+  //MM_manager.register_allocation(usage);
+};
+
+
+
+/**********************************************************************/
+ // A psuedo-constructor for substreams.
+template<class T>
+AMI_err AMI_STREAM<T>::new_substream(AMI_stream_type st,
+				     off_t sub_begin,
+				     off_t sub_end,
+				     AMI_STREAM<T> **sub_stream) {
+
+  //assume this for now
+  assert(st == AMI_READ_STREAM);
+
+#ifdef __MINGW32__
+  /* MINGW32: reopen file here for stream_len() below */
+  //reopen the file 
+  AMI_STREAM<T> *substr = new AMI_STREAM<T>(path, st);
+#endif
+
+  //check range
+  if (substream_level) {
+     if( (sub_begin >= (logical_eos - logical_bos)) ||
+	 (sub_end >= (logical_eos - logical_bos)) ) {
+       
+       return AMI_ERROR_OUT_OF_RANGE;
+     }
+  }  else {
+    off_t len = stream_len();
+    if (sub_begin > len || sub_end > len) {
+
+      return AMI_ERROR_OUT_OF_RANGE;
+    }
+  }
+
+#ifndef __MINGW32__
+  //reopen the file 
+  AMI_STREAM<T> *substr = new AMI_STREAM<T>(path, st);
+#endif
+
+  // Set up the beginning and end positions.
+  if (substream_level) {
+    substr->logical_bos = logical_bos + sub_begin;
+    substr->logical_eos = logical_bos + sub_end + 1;
+  } else {
+    substr->logical_bos = sub_begin;
+    substr->logical_eos = sub_end + 1;
+  }
+  
+  // Set the current position.
+  substr->seek(0);
+
+  substr->eof_reached = 0;
+
+  //set substream level
+  substr->substream_level = substream_level + 1;
+
+  substr->per = per;   //set persistence
+
+  //*sub_stream = (AMI_base_stream < T > *)substr;
+  *sub_stream = substr;
+  return  AMI_ERROR_NO_ERROR;
+};
+
+
+
+/**********************************************************************/
+// Return the number of items in the stream.
+template<class T>
+off_t AMI_STREAM<T>::stream_len(void) {
+
+  fflush(fp);
+
+#ifdef __MINGW32__
+  //stat() fails on MS Windows if the file is open, so try ftell() instead.
+  //FIXME: not 64bit safe, but WinGrass isn't either right now.
+  //try something with #ifdef HAVE_LARGEFILES ? (see fseeko() elsewhere in this file)
+  long posn_save, st_size;
+
+  posn_save = ftell(fp);
+  if(posn_save == -1) {
+     perror("ERROR: AMI_STREAM::stream_len(): ftell(fp) failed ");
+     perror(path);
+     exit(1);
+  }
+
+  fseek(fp, 0, SEEK_END);
+  st_size = ftell(fp);
+  if(st_size == -1) {
+     perror("ERROR: AMI_STREAM::stream_len(): ftell[SEEK_END] failed ");
+     perror(path);
+     exit(1);
+  }
+
+  fseek(fp, posn_save, SEEK_SET);
+  return (st_size / sizeof(T));
+
+#else
+  struct stat buf;
+  if (stat(path, &buf) == -1) {
+    perror("ERROR: AMI_STREAM::stream_len(): fstat failed ");
+    DEBUG_ASSERT assert(0);
+    exit(1);
+  }
+  return (buf.st_size / sizeof(T));
+#endif
+};
+
+
+
+/**********************************************************************/
+// Return the path name of this stream.
+template<class T>
+AMI_err AMI_STREAM<T>::name(char **stream_name)  {
+  
+  *stream_name = new char [strlen(path) + 1];
+  strcpy(*stream_name, path);
+  
+  return AMI_ERROR_NO_ERROR;
+};
+
+// Return the path name of this stream.
+template<class T>
+const char *
+AMI_STREAM<T>::name() const {
+  return path;
+};
+
+
+
+/**********************************************************************/
+// Move to a specific offset within the (sub)stream.
+template<class T>
+AMI_err AMI_STREAM<T>::seek(off_t offset) {
+
+  off_t seek_offset;
+  
+  if (substream_level) {    //substream
+    if (offset  > (unsigned) (logical_eos - logical_bos)) {
+      //offset out of range
+      cerr << "ERROR: AMI_STREAM::seek bos=" << logical_bos << ", eos="
+           << logical_eos << ", offset " << offset << " out of range.\n";
+      DEBUG_ASSERT assert(0);
+      exit(1);
+    } else {
+      //offset in range 
+      seek_offset = (logical_bos + offset) * sizeof(T);
+    }
+
+
+  } else {
+    //not a substream
+    seek_offset = offset * sizeof(T);
+  }
+
+#ifdef HAVE_LARGEFILES
+  if (fseeko(fp, seek_offset, SEEK_SET) == -1) {
+#else
+  if (fseek(fp, seek_offset, SEEK_SET) == -1) {
+#endif     
+    cerr << "ERROR: AMI_STREAM::seek offset=" << seek_offset << " failed.\n";
+    DEBUG_ASSERT assert(0);
+    exit(1);
+  }
+  
+  return AMI_ERROR_NO_ERROR;
+}
+
+
+
+
+/**********************************************************************/
+// Query memory usage
+template<class T>
+AMI_err
+AMI_STREAM<T>::main_memory_usage(size_t *usage,
+								 MM_stream_usage usage_type= MM_STREAM_USAGE_OVERHEAD) {
+  
+   switch (usage_type) {
+   case MM_STREAM_USAGE_OVERHEAD:
+     *usage = sizeof (AMI_STREAM<T>);
+     break;
+   case MM_STREAM_USAGE_BUFFER:
+     // *usage = get_block_length();
+     *usage = STREAM_BUFFER_SIZE*sizeof(char);
+     break;
+   case MM_STREAM_USAGE_CURRENT:
+   case MM_STREAM_USAGE_MAXIMUM:
+     // *usage = sizeof (*this) + get_block_length();
+     *usage = sizeof (AMI_STREAM<T>) + STREAM_BUFFER_SIZE*sizeof(char);
+     break;
+   }
+   return AMI_ERROR_NO_ERROR;
+};
+
+
+
+/**********************************************************************/
+template<class T>
+AMI_STREAM<T>::~AMI_STREAM(void)  {
+  
+  DEBUG_DELETE cerr << "~AMI_STREAM: " << path << "(" << this << ")\n";
+  assert(fp);
+  fclose(fp);
+  delete buf;
+  
+  // Get rid of the file if not persistent and if not substream.
+  if ((per != PERSIST_PERSISTENT) && (substream_level == 0)) {
+    if (unlink(path) == -1) {
+      cerr << "ERROR: AMI_STREAM: failed to unlink " << path << endl;
+      perror("cannot unlink: ");
+      DEBUG_ASSERT assert(0);
+      exit(1);
+    }
+  }
+  // Register memory deallocation before returning.
+  //size_t usage; 
+  //main_memory_usage(&usage,  MM_STREAM_USAGE_CURRENT);
+  //MM_manager.register_deallocation(usage);
+ };
+
+
+
+/**********************************************************************/
+template<class T>
+AMI_err AMI_STREAM<T>::read_item(T **elt)  {
+
+  assert(fp);
+
+  //if we go past substream range
+  if ((logical_eos >= 0) && ftell(fp) >= sizeof(T) * logical_eos) {
+    return AMI_ERROR_END_OF_STREAM;
+  
+  } else {
+    if (fread((char *) (&read_tmp), sizeof(T), 1, fp) < 1) {
+      if(feof(fp)) {
+	eof_reached = 1;
+	return AMI_ERROR_END_OF_STREAM;
+      } else {
+	cerr << "ERROR: file=" << path << ":";
+	perror("cannot read!");    
+	return AMI_ERROR_IO_ERROR;
+      }
+    }
+    
+    *elt = &read_tmp;
+    return AMI_ERROR_NO_ERROR; 
+  }
+};
+
+
+
+
+/**********************************************************************/
+template<class T>
+AMI_err AMI_STREAM<T>::read_array(T *data, off_t len, off_t *lenp=NULL) {
+  size_t nobj;
+  assert(fp);
+  
+  //if we go past substream range
+  if ((logical_eos >= 0) && ftell(fp) >= sizeof(T) * logical_eos) {
+	eof_reached = 1;
+    return AMI_ERROR_END_OF_STREAM;
+    
+  } else {
+    nobj = fread((void*)data, sizeof(T), len, fp);
+
+    if (nobj < len) {		/* some kind of error */
+      if(feof(fp)) {
+	if(lenp) *lenp = nobj;
+	eof_reached = 1;
+	return AMI_ERROR_END_OF_STREAM;
+      } else {
+	cerr << "ERROR: file=" << path << ":";
+	perror("cannot read!");    
+	return AMI_ERROR_IO_ERROR;
+      }
+    }
+    if(lenp) *lenp = nobj;
+    return AMI_ERROR_NO_ERROR; 
+  }
+};
+
+
+
+
+/**********************************************************************/
+template<class T>
+AMI_err AMI_STREAM<T>::write_item(const T &elt) {
+
+  assert(fp);
+  //if we go past substream range
+  if ((logical_eos >= 0) && ftell(fp) >= sizeof(T) * logical_eos) {
+    return AMI_ERROR_END_OF_STREAM;
+  
+  } else {
+    if (fwrite((char*)(&elt), sizeof(T), 1,fp) < 1) {
+      cerr << "ERROR: AMI_STREAM::write_item failed.\n";
+      if (path && *path)
+	perror(path);
+      else
+	perror("AMI_STREAM::write_item: ");
+      DEBUG_ASSERT assert(0);
+      exit(1);
+    }
+
+    return AMI_ERROR_NO_ERROR;
+  }
+};
+
+
+/**********************************************************************/
+template<class T>
+AMI_err AMI_STREAM<T>::write_array(const T *data, off_t len) {
+  size_t nobj;
+
+  assert(fp);
+  //if we go past substream range
+  if ((logical_eos >= 0) && ftell(fp) >= sizeof(T) * logical_eos) {
+    return AMI_ERROR_END_OF_STREAM;
+    
+  } else {
+    nobj = fwrite(data, sizeof(T), len, fp);
+    if (nobj  < len) {
+      cerr << "ERROR: AMI_STREAM::write_array failed.\n";
+      if (path && *path)
+	perror(path);
+      else
+	perror("AMI_STREAM::write_array: ");
+      DEBUG_ASSERT assert(0);
+      exit(1);
+    }
+   return AMI_ERROR_NO_ERROR;
+  }
+};
+        
+
+/**********************************************************************/
+template<class T>
+void AMI_STREAM<T>::persist(persistence p)  {
+  per = p;
+};
+
+
+
+/**********************************************************************/
+// sprint()
+// Return a string describing the stream
+//
+// This function gives easy access to the file name, length.
+// It is not reentrant, but this should not be too much of a problem 
+// if you are careful.
+template<class T>
+char *AMI_STREAM<T>::sprint()  {
+  static char buf[BUFSIZ];
+  sprintf(buf, "[AMI_STREAM %s %ld]", path, (long)stream_len());
+  return buf;
+};
+
+/**********************************************************************/
+template<class T>
+int AMI_STREAM<T>::eof()  {
+  return eof_reached;
+};
+
+
+#endif // _AMI_STREAM_H 
diff -ruN grass-6.4.2-old/include/iostream/embuffer.h grass-6.4.2/include/iostream/embuffer.h
--- grass-6.4.2-old/include/iostream/embuffer.h	2012-05-08 19:28:12.000000000 +0900
+++ grass-6.4.2/include/iostream/embuffer.h	2012-05-08 19:28:50.000000000 +0900
@@ -364,7 +364,7 @@
   // return the number of items actually inserted 
   long insert(AMI_STREAM<T>* str, 
 	      //long bos=0); 
-	      long bos); 
+	      long bos=0); 
   
   //print range of elements in buffer
   void print_range();
@@ -1120,7 +1120,7 @@
    
    return the number of items actually inserted */
 template<class T, class Key>
-long em_buffer<T,Key>::insert(AMI_STREAM<T>* str, long bos=0) {
+long em_buffer<T,Key>::insert(AMI_STREAM<T>* str, long bos) {
 
   assert(str);
   
diff -ruN grass-6.4.2-old/include/iostream/minmaxheap.h grass-6.4.2/include/iostream/minmaxheap.h
--- grass-6.4.2-old/include/iostream/minmaxheap.h	2012-05-08 19:28:12.000000000 +0900
+++ grass-6.4.2/include/iostream/minmaxheap.h	2012-05-08 19:28:50.000000000 +0900
@@ -491,7 +491,7 @@
   T a, b;
   min(a);
   max(b);
-  if (size) {
+  if (size()) {
     cout << a.getPriority() << ".."
 	 << b.getPriority();
   }
@@ -744,7 +744,7 @@
   //heap must be empty
   assert(this->size()==0);
   for (i = 0; !full() && i<n; i++) {
-    insert(arr[i]);
+    this->insert(arr[i]);
   }
   if (i < n) {
     assert(i == this->maxsize);
diff -ruN grass-6.4.2-old/lib/init/init.sh grass-6.4.2/lib/init/init.sh
--- grass-6.4.2-old/lib/init/init.sh	2012-05-08 19:28:12.000000000 +0900
+++ grass-6.4.2/lib/init/init.sh	2012-05-08 19:28:50.000000000 +0900
@@ -25,7 +25,8 @@
 trap "echo 'User break!' ; exit" 2 3 15
 
 # Set default GUI
-DEFAULT_GUI="wxpython"
+# Fink's GRASS does not support wxPython.
+DEFAULT_GUI="tcltk"
 
 # the following is only meant to be an internal variable for debugging this script.
 #  use 'g.gisenv set="DEBUG=[0-5]"' to turn GRASS debug mode on properly.
@@ -308,11 +309,12 @@
 fi
 
 if [ ! "$GRASS_PYTHON" ] ; then
-    if [ "$MACOSX" ] ; then
-        GRASS_PYTHON=pythonw
-    else
+#    if [ "$MACOSX" ] ; then
+#        GRASS_PYTHON=pythonw
+#    else
+# Fink's python does not include pythonw
         GRASS_PYTHON=python
-    fi
+#    fi
     export GRASS_PYTHON
 fi
 
@@ -824,16 +826,13 @@
     
     # Check for tcltk interface
     tcltk | gis.m)
-       if [ "$sh" != "bash" ] && [ "$sh" != "msh" ] && [ "$sh" != "cygwin" ]; then
-               # trap is not supported by csh/tcsh and rc
-               "$GISBASE/scripts/gis.m"
-       fi;
+	"$GISBASE/scripts/gis.m"
 	;;
     oldtcltk | d.m)
 	"$GISBASE/scripts/d.m"
 	;;
     wxpython)
-        "$GRASS_PYTHON" "$GISBASE/etc/wxpython/wxgui.py" &
+        "$GISBASE/etc/wxpython/scripts/wxgui"
 	;;
 
     # Ignore others
@@ -976,11 +975,6 @@
 
     echo "export PATH=\"$PATH\"" >> "$bashrc"
     echo "export HOME=\"$USERHOME\"" >> "$bashrc" # restore user home path
-    echo 'export GRASS_SHELL_PID=$$' >> "$bashrc" # can be used to terminate GRASS session from GUI
-    if [ "$GRASS_GUI" = tcltk ] || [ "$GRASS_GUI" = gis.m ]; then
-       echo '$GISBASE/scripts/gis.m' >> "$bashrc" # Start gis.m
-    fi;
-    echo 'trap "echo \"GUI issued an exit\"; exit" SIGQUIT' >> "$bashrc"
 
     "$ETC/run" "$SHELL"
     EXIT_VAL=$?
@@ -1030,15 +1024,6 @@
     d.mon stop="$MON"
 done
 
-# Attempt to close any open gis.m instances.
-if [ -n "$TCLTKGRASSBASE" ] && [ `ps -a | grep -c "$GRASS_WISH"` -ge 1 ] ; then
-       echo "Closing open gis.m sessions....."
-       echo 'foreach gwin [lsearch -all -inline [winfo interps] gm_tcl*] {
-               catch {send -async $gwin Gm::remoteExit $env(GIS_LOCK)}
-       }
-       exit' | "$GRASS_WISH" #>/dev/null 2>&1
-fi
-
 echo "Cleaning up temporary files ..."
 
 "$ETC/clean_temp" > /dev/null
diff -ruN grass-6.4.2-old/lib/init/init.sh.orig grass-6.4.2/lib/init/init.sh.orig
--- grass-6.4.2-old/lib/init/init.sh.orig	1970-01-01 09:00:00.000000000 +0900
+++ grass-6.4.2/lib/init/init.sh.orig	2012-01-04 18:55:50.000000000 +0900
@@ -0,0 +1,1066 @@
+#!/bin/sh
+#############################################################################
+#
+# MODULE:   	GRASS Initialization
+# AUTHOR(S):	Original author unknown - probably CERL
+#               Andreas Lange - Germany - andreas.lange@rhein-main.de
+#   	    	Huidae Cho - Korea - grass4u@gmail.com
+#   	    	Justin Hickey - Thailand - jhickey@hpcc.nectec.or.th
+#   	    	Markus Neteler - Germany/Italy - neteler@itc.it
+#		Hamish Bowman - New Zealand - hamish_b at yahoo,com
+# PURPOSE:  	The source file for this shell script is in
+#   	    	src/general/init/init.sh. It sets up some environment
+#   	    	variables and the lock file. It also parses any remaining
+#   	    	command line options for setting the GISDBASE, LOCATION, and/or
+#   	    	MAPSET. Finally it starts GRASS with the appropriate user
+#   	    	interface and cleans up after it is finished.
+# COPYRIGHT:    (C) 2000-2011 by the GRASS Development Team
+#
+#               This program is free software under the GNU General Public
+#   	    	License (>=v2). Read the file COPYING that comes with GRASS
+#   	    	for details.
+#
+#############################################################################
+
+trap "echo 'User break!' ; exit" 2 3 15
+
+# Set default GUI
+DEFAULT_GUI="wxpython"
+
+# the following is only meant to be an internal variable for debugging this script.
+#  use 'g.gisenv set="DEBUG=[0-5]"' to turn GRASS debug mode on properly.
+if [ -z "$GRASS_DEBUG" ] ; then
+   GRASS_DEBUG=0
+fi
+
+# Set the GRASS_PERL variable
+GRASS_PERL=PERL_COMMAND
+export GRASS_PERL
+
+# GRASS_SH is normally just for Windows when not started from a bourne 
+# shell. But when starting from Init.sh is still needed for Tcl/Tk.
+GRASS_SH=/bin/sh
+export GRASS_SH
+
+# Set GRASS version number for R interface etc (must be an env_var for MS-Windows)
+GRASS_VERSION="GRASS_VERSION_NUMBER"
+export GRASS_VERSION
+
+# Get the command name
+CMD_NAME=START_UP
+
+# Get the system name
+SYSTEM=`uname -s`
+case $SYSTEM in
+MINGW*)
+	MINGW=1
+	;;
+CYGWIN*)
+	CYGWIN=1
+	;;
+Darwin*)
+	MACOSX=1
+	;;
+esac
+
+
+# Go through the command line options
+for i in "$@" ; do
+    
+    # Use a case to check the command line options
+    case "$i" in
+    
+    	# Check if the user asked for the version
+	-v|--version)
+	    echo "GRASS GIS $GRASS_VERSION"
+	    echo
+	    cat "$GISBASE/etc/license"
+	    exit
+	    ;;
+
+    	# Check if the user asked for help
+	help|-h|-help|--help)
+	    echo "Usage:"
+	    echo "  $CMD_NAME [-h | -help | --help] [-v | --version] [-c]"
+	    echo "          [-text | -gui | -tcltk | -oldtcltk | -wxpython | -wx]"
+	    echo "          [[[<GISDBASE>/]<LOCATION_NAME>/]<MAPSET>]"
+	    echo
+            echo "Flags:"
+            echo "  -h or -help or --help          print this help message"
+	    echo "  -v or --version                show version information and exit"
+	    echo "  -c                             create given mapset if it doesn't exist"
+            echo "  -text                          use text based interface"
+            echo "                                   and set as default"
+            echo "  -gui                           use graphical user interface ($DEFAULT_GUI by default)"
+            echo "                                   and set as default"
+            echo "  -tcltk                         use Tcl/Tk based graphical user interface"
+            echo "                                   and set as default"
+	    echo "  -oldtcltk                      use old Tcl/Tk based graphical user interface"
+            echo "                                   and set as default"
+            echo "  -wxpython or -wx               use wxPython based graphical user interface"
+            echo "                                   and set as default"
+            echo
+            echo "Parameters:"
+            echo "  GISDBASE                       initial database (path to GIS data)"
+            echo "  LOCATION_NAME                  initial location"
+            echo "  MAPSET                         initial mapset"
+            echo
+            echo "  GISDBASE/LOCATION_NAME/MAPSET  fully qualified initial mapset directory"
+            echo
+            echo "Environment variables relevant for startup:"
+            echo "  GRASS_GUI                      select GUI (text, gui, tcltk, oldtcltk, wxpython)"
+            echo "  GRASS_TCLSH                    set tclsh shell name to override 'tclsh'"
+            echo "  GRASS_WISH                     set wish shell name to override 'wish'"
+            echo "  GRASS_HTML_BROWSER             set html web browser for help pages"
+            echo "  GRASS_ADDON_PATH               set additional path(s) to local GRASS modules"
+            echo "  GRASS_BATCH_JOB                shell script to be processed as batch job"
+            echo "  GRASS_PYTHON                   set python shell name to override 'python'"
+	    exit
+	    ;;
+
+	# Check if the -text flag was given
+	-text | --text)
+	    GRASS_GUI="text"
+	    shift
+	    ;;
+
+	# Check if the -gui flag was given
+	-gui | --gui)
+	    GRASS_GUI="$DEFAULT_GUI"
+	    shift
+	    ;;
+
+	# Check if the -tcltk flag was given
+	-tcltk | --tcltk)
+	    GRASS_GUI="tcltk"
+	    shift
+	    ;;
+
+	# Check if the -oldtcltk flag was given
+	-oldtcltk | --oldtcltk)
+	    GRASS_GUI="oldtcltk"
+	    shift
+	    ;;
+
+	# Check if the -wxpython flag was given
+	-wxpython | -wx | --wxpython | --wx)
+	    GRASS_GUI="wxpython"
+	    shift
+	    ;;
+
+    	# Check if the user wants to create a new mapset
+	-c | --create)
+	    CREATE_NEW=1
+	    shift
+	    ;;
+    esac
+done
+
+# Set the GIS_LOCK variable to current process id
+GIS_LOCK=$$
+export GIS_LOCK
+
+# Set the global grassrc file
+if [ -n "$GRASS_BATCH_JOB" ] ; then
+	GISRCRC="$HOME/.grassrc6.`uname -n`"
+	if [ ! -f "$GISRCRC" ] ; then
+		GISRCRC="$HOME/.grassrc6"
+	fi
+else
+	GISRCRC="$HOME/.grassrc6"
+fi
+
+# Set the session grassrc file
+if [ "$MINGW" ] ; then
+	PWD=`pwd -W`
+	USER="$USERNAME"
+	if [ ! "$USER" ] ; then
+		USER="user_name"
+	fi
+	if [ ! -f "$GISBASE/etc/monitorcap" ] ; then
+		# create an empty monitorcap
+		touch "$GISBASE/etc/monitorcap"
+	fi
+else
+	PWD=`pwd`
+	USER="`whoami`"
+fi
+
+
+# all exits after setting up $tmp should also tidy it up
+cleanup_tmp()
+{
+  # remove session files from tmpdir
+  rm -rf "$tmp"
+}
+
+## use TMPDIR if it exists, otherwise /tmp
+#tmp=${TMPDIR-/tmp}
+#tmp="$tmp/grass6-$USER-$GIS_LOCK"
+tmp=/tmp/grass6-$USER-$GIS_LOCK
+(umask 077 && mkdir "$tmp") || {
+    echo "Cannot create temporary directory! Exiting." 1>&2
+    exit 1
+}
+GISRC="$tmp/gisrc"
+export GISRC
+
+# remove invalid GISRC file to avoid disturbing error messages:
+cat "$GISRCRC" 2>/dev/null| grep UNKNOWN >/dev/null
+if [ $? -eq 0 ] ; then
+   rm -f "$GISRCRC"
+fi
+
+# Copy the global grassrc file to the session grassrc file
+if [ -f "$GISRCRC" ] ; then
+    cp "$GISRCRC" "$GISRC"
+    if [ $? -eq 1 ] ; then
+    	echo "Cannot copy '$GISRCRC' to '$GISRC'"
+	cleanup_tmp
+    	exit 1
+    fi
+fi
+
+# Copy global grassrc file to session grassrc
+
+# At this point the GRASS user interface variable has been set from the
+# command line, been set from an external environment variable, or is 
+# not set. So we check if it is not set
+if [ ! "$GRASS_GUI" ] ; then
+
+    # Check for a reference to the GRASS user interface in the grassrc file
+    if [ -f "$GISRC" ] ; then
+    	GRASS_GUI=`awk '/GRASS_GUI/ {print $2}' "$GISRC"`
+    fi
+    
+    # Set the GRASS user interface to the default if needed
+    if [ ! "$GRASS_GUI" ] ; then
+	GRASS_GUI="$DEFAULT_GUI"
+    fi
+else
+    if [ "$GRASS_GUI" = "gui" ] ; then
+	GRASS_GUI="$DEFAULT_GUI"
+    elif [ "$GRASS_GUI" = "wx" ] ; then
+	GRASS_GUI="wxpython"
+    fi
+fi
+
+# Set PATH to GRASS bin, ETC to GRASS etc
+ETC="$GISBASE/etc"
+
+if [ "$LC_ALL" ] ; then
+	LCL=`echo "$LC_ALL" | sed 's/\(..\)\(.*\)/\1/'`
+elif [ "$LC_MESSAGES" ] ; then
+	LCL=`echo "$LC_MESSAGES" | sed 's/\(..\)\(.*\)/\1/'`
+else
+	LCL=`echo "$LANG" | sed 's/\(..\)\(.*\)/\1/'`
+fi
+
+# if it doesn't exist set it to something so that g.extension's default is reasonable
+if [ -z "$GRASS_ADDON_PATH" ] ; then
+    if [ "$MINGW" ] ; then
+	GRASS_ADDON_PATH="$APPDATA/GRASS6/addons"
+    else
+	GRASS_ADDON_PATH="$HOME/.grass6/addons"
+    fi
+fi
+export GRASS_ADDON_PATH
+PATH="$GISBASE/bin:$GISBASE/scripts:$GRASS_ADDON_PATH:$PATH"
+export PATH
+
+# Set LD_LIBRARY_PATH to find GRASS shared libraries
+if [ ! "$LD_LIBRARY_PATH_VAR" ] ; then
+  LD_LIBRARY_PATH_VAR="$GISBASE/lib"
+else
+  LD_LIBRARY_PATH_VAR="$GISBASE/lib:$LD_LIBRARY_PATH_VAR"
+fi
+export LD_LIBRARY_PATH_VAR
+# Additional copy of variable to use with grass-run.sh
+GRASS_LD_LIBRARY_PATH="$LD_LIBRARY_PATH_VAR"
+export GRASS_LD_LIBRARY_PATH
+
+# Set some environment variables if they are not set
+if [ ! "$GRASS_PAGER" ] ; then
+    if [ -x /bin/more ] || [ -x /usr/bin/more ] ; then
+        GRASS_PAGER=more
+    elif [ -x /bin/less ] || [ -x /usr/bin/less ] ; then
+        GRASS_PAGER=less
+    elif [ "$MINGW" ] ; then
+        GRASS_PAGER=more
+    else
+        GRASS_PAGER=cat
+    fi
+    export GRASS_PAGER
+fi
+
+# Set up tcltk and wish environment 
+
+if [ ! "$GRASS_TCLSH" ] ; then
+   GRASS_TCLSH=tclsh
+   export GRASS_TCLSH
+fi   
+
+#WISH_OS=`echo 'puts $tcl_platform(platform) ; exit 0' | wish`
+
+if [ ! "$GRASS_WISH" ] ; then
+   GRASS_WISH=wish
+   export GRASS_WISH
+fi
+
+if [ ! "$GRASS_PYTHON" ] ; then
+    if [ "$MACOSX" ] ; then
+        GRASS_PYTHON=pythonw
+    else
+        GRASS_PYTHON=python
+    fi
+    export GRASS_PYTHON
+fi
+
+# Set PYTHONPATH to find GRASS Python modules
+if [ ! "$PYTHONPATH" ] ; then
+    PYTHONPATH="$GISBASE/etc/python"
+else
+    PYTHONPATH="$GISBASE/etc/python:$PYTHONPATH"
+fi
+export PYTHONPATH
+if [ "$MINGW" ] ; then
+    PATHEXT="${PATHEXT};.PY"
+    export PATHEXT
+fi
+
+# try and find a web browser if one isn't already specified
+if [ ! "$GRASS_HTML_BROWSER" ] ; then
+
+    if [ "$MACOSX" ] ; then
+        # OSX doesn't execute browsers from the shell PATH - route thru a script
+        GRASS_HTML_BROWSER="$ETC/html_browser_mac.sh"
+        GRASS_HTML_BROWSER_MACOSX="-b com.apple.helpviewer"
+        export GRASS_HTML_BROWSER_MACOSX
+
+    elif [ "$MINGW" -o "$CYGWIN" ] ; then
+	# MinGW startup moved to into init.bat
+	iexplore="$SYSTEMDRIVE/Program Files/Internet Explorer/iexplore.exe"
+	if [ -f "$iexplore" ] ; then
+	    GRASS_HTML_BROWSER=$iexplore
+	else
+	    GRASS_HTML_BROWSER="iexplore"
+	fi
+
+    else
+      # the usual suspects
+      BROWSERS="htmlview konqueror mozilla mozilla-firefox firefox opera netscape dillo"
+      for BROWSER in $BROWSERS ; do
+	for i in `echo "$PATH" | sed 's/^:/.:/
+                                s/::/:.:/g
+                                s/:$/:./
+                                s/:/ /g'`
+	do
+	  if [ -f "$i/$BROWSER" ] ; then  
+            GRASS_HTML_BROWSER="$BROWSER"
+            break
+	  fi
+	done
+	if [ -n "$GRASS_HTML_BROWSER" ] ; then
+	   break
+	fi
+      done
+    fi
+   
+elif [ "$MACOSX" ] ; then
+    # OSX doesn't execute browsers from the shell PATH - route thru a script
+    GRASS_HTML_BROWSER_MACOSX="-b $GRASS_HTML_BROWSER"
+    export GRASS_HTML_BROWSER_MACOSX
+    GRASS_HTML_BROWSER="$ETC/html_browser_mac.sh"
+fi
+
+if [ ! "$GRASS_HTML_BROWSER" ] ; then
+    echo "WARNING: Searched for a web browser, but none found." 1>&2
+    # even so we set konqueror to make lib/gis/parser.c happy:
+    GRASS_HTML_BROWSER=konqueror
+fi
+export GRASS_HTML_BROWSER
+
+
+#predefine monitor size for certain architectures
+if [ "$HOSTTYPE" = "arm" ] ; then
+   #small monitor on ARM (iPAQ, zaurus... etc)
+   GRASS_HEIGHT=320
+   GRASS_WIDTH=240
+   export GRASS_HEIGHT GRASS_WIDTH
+fi
+
+
+if [ ! "$GRASS_GNUPLOT" ] ; then
+    GRASS_GNUPLOT="gnuplot -persist"
+    export GRASS_GNUPLOT
+fi
+
+if [ ! "$GRASS_PROJSHARE" ] ; then
+    GRASS_PROJSHARE=CONFIG_PROJSHARE
+    export GRASS_PROJSHARE
+fi
+
+# First time user - GISRC is defined in the GRASS script
+if [ ! -f "$GISRC" ] ; then
+
+    if [ ! -f "$GISBASE/locale/$LCL/etc/grass_intro" ] ; then
+	cat "$ETC/grass_intro"
+    else
+	cat "$GISBASE/locale/$LCL/etc/grass_intro"
+    fi
+
+    echo
+    echo "Hit RETURN to continue"
+    read ans
+
+    #for convenience, define pwd as GISDBASE:
+    echo "GISDBASE: $HOME" > "$GISRC"
+    echo 'LOCATION_NAME: <UNKNOWN>' >> "$GISRC"
+    echo 'MAPSET: <UNKNOWN>' >> "$GISRC"
+
+    # This is a hack for not having a good initial gui - should be removed
+    # with next version of initialization gui
+    #GRASS_GUI="text"
+    
+else
+    echo "Cleaning up temporary files ..."
+    ("$ETC/clean_temp" > /dev/null &)
+fi
+
+
+echo "Starting GRASS ..."
+
+# Check if we are running X windows by checking the DISPLAY variable
+if [ "$DISPLAY" -o "$MINGW" ] ; then
+
+    # Check if python is working properly
+    if [ "$GRASS_GUI" = "wxpython" ]; then
+        echo 'variable=True' | "$GRASS_PYTHON" >/dev/null 2>&1
+    fi
+    # Check if we need to find wish
+    if [ "$GRASS_GUI" = "tcltk" ] || \
+        [ "$GRASS_GUI" = "gis.m" ] || \
+	[ "$GRASS_GUI" = "oldtcltk" ] || \
+        [ "$GRASS_GUI" = "d.m" ] ; then
+
+	# Check if wish is working properly
+	echo 'exit 0' | "$GRASS_WISH" >/dev/null 2>&1
+    fi
+
+    # ok
+    if [ "$?" = 0 ] ; then
+        # Set the tcltkgrass base directory
+        TCLTKGRASSBASE="$ETC"
+        # Set the wxpython base directory
+        WXPYTHONGRASSBASE="$ETC/wxpython"
+    else
+
+        # Wish was not found - switch to text interface mode
+        echo
+        echo "WARNING: The wish command does not work as expected!"
+        echo "Please check your GRASS_WISH environment variable."
+        echo "Use the -help option for details."
+        echo "Switching to text based interface mode."
+        echo
+        echo "Hit RETURN to continue."
+        read ans
+
+        GRASS_GUI="text"
+    fi
+else
+
+    # Display a message if a graphical interface was expected
+    if [ "$GRASS_GUI" != "text" ] ; then
+        # Set the interface mode to text
+    	echo
+	echo "WARNING: It appears that the X Windows system is not active."
+	echo "A graphical based user interface is not supported."
+	echo "Switching to text based interface mode."
+	echo
+	echo "Hit RETURN to continue"
+	read ans
+
+        GRASS_GUI="text"
+    fi
+fi
+
+# Save the user interface variable in the grassrc file - choose a temporary
+# file name that should not match another file
+if [ -f "$GISRC" ] ; then
+    awk '$1 !~ /GRASS_GUI/ {print}' "$GISRC" > "$GISRC.$$"
+    echo "GRASS_GUI: $GRASS_GUI" >> "$GISRC.$$"
+    mv -f "$GISRC.$$" "$GISRC"
+fi
+
+# Parsing argument to get LOCATION
+if [ ! "$1" ] ; then
+
+    # Try interactive startup
+    LOCATION=
+else
+
+    # Try non-interactive startup
+    L=
+    
+    if [ "$1" = "-" ] ; then
+    
+    	if [ "$LOCATION" ] ; then
+    	    L="$LOCATION"
+    	fi
+    else
+    	L="$1"
+    fi
+
+    if [ "$L" ] ; then
+	if [ "$L" = "." ] ; then
+	    L=$PWD
+	elif [ `echo "$L" | cut -c 1` != "/" ] ; then
+    	    L="$PWD/$L"
+    	fi
+
+    	MAPSET=`basename "$L"`
+    	L=`dirname "$L"`
+    
+    	if [ "$L" != "." ] ; then
+    	    LOCATION_NAME=`basename "$L"`
+    	    L=`dirname "$L"`
+    
+    	    if [ "$L" != "." ] ; then
+    	    	GISDBASE="$L"
+    	    fi
+    	fi
+    fi
+
+    #strip off white space from LOCATION_NAME and MAPSET: only supported for $GISDBASE
+    MAPSET=`echo $MAPSET | sed 's+ ++g'`
+    LOCATION_NAME=`echo $LOCATION_NAME | sed 's+ ++g'`
+
+    if [ "$GISDBASE" -a "$LOCATION_NAME" -a "$MAPSET" ] ; then
+    	LOCATION="$GISDBASE/$LOCATION_NAME/$MAPSET"
+
+    	if [ ! -r "$LOCATION/WIND" ] ; then
+		if [ "$LOCATION_NAME" = "PERMANENT" ] ; then
+		   echo "$LOCATION: Not a valid GRASS location"
+		   cleanup_tmp
+		   exit 1
+		else
+		   # the user wants to create mapset on the fly
+		   if [ -n "$CREATE_NEW" ] && [ "$CREATE_NEW" -eq 1 ] ; then
+		     if [ ! -f "$GISDBASE/$LOCATION_NAME/PERMANENT/DEFAULT_WIND" ] ; then
+			echo "The LOCATION \"$LOCATION_NAME\" does not exist. Please create it first"
+			cleanup_tmp
+			exit 1
+		     else
+			mkdir -p "$LOCATION"
+			cp "$GISDBASE/$LOCATION_NAME/PERMANENT/DEFAULT_WIND" "$LOCATION/WIND"
+			echo "Missing WIND file fixed"
+		     fi
+		   else
+			echo "$LOCATION: Not a valid GRASS location"
+			cleanup_tmp
+			exit 1
+		   fi
+		fi
+    	fi
+
+    	if [ -s "$GISRC" ] ; then
+    	    sed -e "s|^GISDBASE:.*$|GISDBASE: $GISDBASE|; \
+    	    	s|^LOCATION_NAME:.*$|LOCATION_NAME: $LOCATION_NAME|; \
+    	    	s|^MAPSET:.*$|MAPSET: $MAPSET|" "$GISRC" > "$GISRC.$$"
+    
+    	    if [ $? -eq 0 ] ; then
+    	    	mv -f "$GISRC.$$" "$GISRC"
+    	    else
+    	    	rm -f "$GISRC.$$"
+    	    	echo "Failed to create new $GISRC"
+    	    	LOCATION=
+    	    fi
+    	else
+    	    echo "GISDBASE: $GISDBASE" > "$GISRC"
+    	    echo "LOCATION_NAME: $LOCATION_NAME" >> "$GISRC"
+    	    echo "MAPSET: $MAPSET" >> "$GISRC"
+    	fi
+    else
+    	echo "GISDBASE, LOCATION_NAME and MAPSET variables not set properly."
+    	echo "Interactive startup needed."
+	cleanup_tmp
+    	exit 1
+    fi
+fi
+
+# User selects LOCATION and MAPSET if not set
+if [ ! "$LOCATION" ] ; then
+
+    case "$GRASS_GUI" in
+
+	# Check for text interface
+	text)
+	    "$ETC/set_data"
+
+	    case $? in
+     	    	0) ;;
+     	    	*) 
+		    # Check for an invalid GISRC file
+		    if [ -f "$GISRC" ] ; then
+			VALUE=`grep "GISDBASE" "$GISRC"`
+			if [ "$VALUE" = "" ] ; then
+    			    echo "Invalid resource file, removing $GISRC"
+			    rm -f "$GISRC"
+			fi
+		    fi
+		    
+		    cleanup_tmp
+		    exit
+		    ;;
+    	    esac
+	    ;;
+
+	# Check that GUI support software is functional
+	tcltk | gis.m | oldtcltk | d.m | wxpython)
+
+	    if [ "$GRASS_GUI" = "tcltk" ] || \
+		[ "$GRASS_GUI" = "gis.m" ] || \
+		[ "$GRASS_GUI" = "oldtcltk" ] || \
+		[ "$GRASS_GUI" = "d.m" ] ; then
+
+		    # eval `foo` will return subshell return code and not app foo return code!!!
+		    eval '"$GRASS_WISH" -file "$TCLTKGRASSBASE/gis_set.tcl"'
+		    thetest=$?
+	    else
+		    eval '"$GRASS_PYTHON" "$WXPYTHONGRASSBASE/gis_set.py"'
+		    thetest=$?
+	    fi
+
+
+	    case $thetest in
+     	    	1)
+
+         	    # The gis_set script printed an error message so wait
+		    # for user to read it
+		    echo "Error in GUI startup. If necessary, please"
+		    echo "report this error to the GRASS developers."
+		    echo "Switching to text mode now."
+		    echo "Hit RETURN to continue..."
+		    read ans
+		    
+		    GRASS_GUI="text"
+
+                    if [ -f "$GISRC" ] ; then
+                        awk '$1 !~ /GRASS_GUI/ {print}' "$GISRC" > "$GISRC.$$"
+                        echo "GRASS_GUI: $GRASS_GUI" >> "$GISRC.$$"
+                        mv -f "$GISRC.$$" "$GISRC"
+                    fi
+
+		    "$ETC/set_data"
+
+		    case $? in
+     	    		0) ;;
+     	    		*) 
+			    # Check for an invalid GISRC file
+			    if [ -f "$GISRC" ] ; then
+				VALUE=`grep "GISDBASE" "$GISRC"`
+				if [ "$VALUE" = "" ] ; then
+    				    echo "Invalid resource file, removing $GISRC" 
+				    rm -f "$GISRC"
+				fi
+			    fi
+
+			    cleanup_tmp
+			    exit
+			    ;;
+    		    esac
+		    ;;
+	    
+     	    	0)
+		    # These checks should not be necessary with real init stuff
+		    if [ "$LOCATION_NAME" = "##NONE##" ] ; then
+    	    		"$ETC/set_data"
+    	    		if [ $? != 0 ]; then
+    	    		    echo "GISDBASE: $OLD_DB" > "$GISRC"
+    	    		    echo "LOCATION_NAME: $OLD_LOC" >> "$GISRC"
+    	    		    echo "MAPSET: $OLD_MAP" >> "$GISRC"
+    	    		    cleanup_tmp
+			    exit
+    	    		fi
+    		    fi
+
+		    if [ "$LOCATION_NAME" = "##ERROR##" ] ; then
+    	    		echo "The selected location is not a valid GRASS location"
+    	    		cleanup_tmp
+			exit 1
+		    fi
+
+		    ;;
+		    
+		2)
+			# User wants to exit from GRASS
+			echo "Received EXIT message from GUI."
+			echo "GRASS is not started. Bye."
+			cleanup_tmp
+			exit 0
+			;;
+		*)
+		    echo "ERROR: Invalid return code from gis_set.tcl."
+		    echo "Please advise GRASS developers of this error."
+		    ;;
+    	    esac
+	    
+	    ;;
+	*)
+	    # Shouldn't need this but you never know
+	    echo "ERROR: Invalid user interface specified - <$GRASS_GUI>."
+	    echo "Use the --help option to see valid interface names."
+	    cleanup_tmp
+	    exit 1
+	    ;;
+    esac
+fi
+
+GISDBASE=`g.gisenv GISDBASE`
+LOCATION_NAME=`g.gisenv LOCATION_NAME`
+MAPSET=`g.gisenv MAPSET`
+
+if [ -z "$GISDBASE" ] || [ -z "$LOCATION_NAME" ] || [ -z "$MAPSET" ] ; then
+    echo "ERROR: Reading data path information from g.gisenv."
+    echo "GISDBASE=[$GISDBASE]"
+    echo "LOCATION_NAME=[$LOCATION_NAME]"
+    echo "MAPSET=[$MAPSET]"
+    echo
+    echo "Check the <$GISRCRC> file."
+    cleanup_tmp
+    exit 1
+fi
+
+LOCATION="${GISDBASE?}/${LOCATION_NAME?}/${MAPSET?}"
+
+# Check for concurrent use
+lockfile="$LOCATION/.gislock"
+"$ETC/lock" "$lockfile" $$
+case $? in
+    0) ;;
+    2)
+    	echo "$USER is currently running GRASS in selected mapset (file $lockfile found). Concurrent use not allowed."
+    	cleanup_tmp
+    	exit 1 ;;
+    *)
+    	echo Unable to properly access "$lockfile"
+    	echo Please notify system personel.
+	cleanup_tmp
+    	exit 1 ;;
+esac
+
+# build user fontcap if specified but not present
+if [ "$GRASS_FONT_CAP" ] && [ ! -f "$GRASS_FONT_CAP" ] ; then
+	echo "Building user fontcap ..."
+	g.mkfontcap
+fi
+
+# predefine default driver if DB connection not defined
+#  is this really needed?? Modules should call this when/if required.
+if [ ! -e "$LOCATION/VAR" ] ; then
+   db.connect -c --quiet
+fi
+
+trap "" 2 3 15
+
+# cygwin has many problems with the shell setup
+# below, so i hardcoded everything here.
+if [ "$CYGWIN" ] ; then
+    sh="cygwin"
+    shellname="GNU Bash (Cygwin)"
+    export SHELL=/usr/bin/bash.exe
+    export OSTYPE=cygwin
+else 
+    sh=`basename "$SHELL"`
+    case "$sh" in
+        ksh)  shellname="Korn Shell";;
+        csh)  shellname="C Shell" ;;
+        tcsh) shellname="TC Shell" ;;
+        bash) shellname="Bash Shell" ;;
+        sh)   shellname="Bourne Shell";;
+        *)    shellname=shell;;
+    esac
+fi
+
+# check for SHELL
+if [ ! -x "$SHELL" ] ; then
+    echo "ERROR: The SHELL variable is not set" 1>&2
+    rm -f "$lockfile"
+    cleanup_tmp
+    exit 1
+fi
+
+# hack to process batch jobs:
+if [ -n "$GRASS_BATCH_JOB" ] ; then
+   # defined, but ...
+   if [ ! -f "$GRASS_BATCH_JOB" ] ; then
+      # wrong file
+      echo "Job file '$GRASS_BATCH_JOB' has been defined in"
+      echo "the 'GRASS_BATCH_JOB' variable but not found. Exiting."
+      echo
+      echo "Use 'unset GRASS_BATCH_JOB' to disable batch job processing."
+      cleanup_tmp
+      exit 1
+   else
+      # right file, but ...
+      if [ ! -x "$GRASS_BATCH_JOB" ] ; then
+	 echo "ERROR: change file permission to 'executable' for '$GRASS_BATCH_JOB'"
+	 cleanup_tmp
+	 exit 1
+      else
+         echo "Executing '$GRASS_BATCH_JOB' ..."
+         GRASS_GUI="text"
+         SHELL="$GRASS_BATCH_JOB"
+      fi
+   fi
+fi
+
+# Start the chosen GUI but ignore text
+if [ "$GRASS_DEBUG" -ne 0 ] ; then
+   echo "GRASS GUI should be $GRASS_GUI"
+fi
+
+case "$GRASS_GUI" in
+    
+    # Check for tcltk interface
+    tcltk | gis.m)
+       if [ "$sh" != "bash" ] && [ "$sh" != "msh" ] && [ "$sh" != "cygwin" ]; then
+               # trap is not supported by csh/tcsh and rc
+               "$GISBASE/scripts/gis.m"
+       fi;
+	;;
+    oldtcltk | d.m)
+	"$GISBASE/scripts/d.m"
+	;;
+    wxpython)
+        "$GRASS_PYTHON" "$GISBASE/etc/wxpython/wxgui.py" &
+	;;
+
+    # Ignore others
+    *)
+    	;;
+esac
+
+# Display the version and license info
+if [ "$MINGW" ] ; then
+	:
+# TODO: uncomment when PDCurses works.
+#	cls
+else
+	if [ -z "$GRASS_BATCH_JOB" ] && [ "$GRASS_DEBUG" -eq 0 ] ; then
+	   tput clear
+	fi
+fi
+
+
+say_hello()
+{
+    if [ -f "$GISBASE/locale/$LCL/etc/welcome" ] ; then
+	cat "$GISBASE/locale/$LCL/etc/welcome"
+    else
+	cat "$ETC/welcome"
+    fi
+
+}
+
+if [ -n "$GRASS_BATCH_JOB" ] ; then
+  say_hello
+else
+  cat <<EOF
+          __________  ___   __________    _______________
+         / ____/ __ \/   | / ___/ ___/   / ____/  _/ ___/
+        / / __/ /_/ / /| | \__ \\\\_  \\   / / __ / / \\__ \\ 
+       / /_/ / _, _/ ___ |___/ /__/ /  / /_/ // / ___/ / 
+       \____/_/ |_/_/  |_/____/____/   \____/___//____/  
+
+EOF
+
+  say_hello
+  echo "GRASS homepage:                          http://grass.osgeo.org/"
+  echo "This version running thru:               $shellname ($SHELL)"
+  echo "Help is available with the command:      g.manual -i"
+  echo "See the licence terms with:              g.version -c"
+
+  case "$GRASS_GUI" in
+     tcltk | gis.m)
+        echo "If required, restart the GUI with:       g.gui tcltk"
+        ;;
+     oldtcltk | d.m)
+        echo "If required, restart the GUI with:       g.gui oldtcltk"
+        ;;
+     wxpython)
+        echo "If required, restart the GUI with:       g.gui wxpython"
+        ;;
+     *)
+        echo "Start the GUI with:                      g.gui $DEFAULT_GUI"
+        ;;
+  esac
+
+  echo "When ready to quit enter:                exit"
+  echo
+fi
+
+
+case "$sh" in
+
+csh|tcsh)
+    USERHOME="$HOME"      # save original home
+    HOME="$LOCATION"
+    export HOME
+    cshrc="$HOME/.cshrc"
+    tcshrc="$HOME/.tcshrc"
+    rm -f "$cshrc" "$tcshrc"
+    echo "set home = $USERHOME" > "$cshrc"
+    echo "set history = 3000 savehist = 3000  noclobber ignoreeof" >> "$cshrc"
+    echo "set histfile = $HOME/.history" >> "$cshrc"
+
+    echo "set prompt = '\\" >> "$cshrc"
+    echo "Mapset <${MAPSET}> in Location <${LOCATION_NAME}> \\" >> "$cshrc"
+    echo "GRASS GRASS_VERSION_NUMBER > '" >> "$cshrc"
+    echo 'set BOGUS=``;unset BOGUS' >> "$cshrc"
+
+    if [ -r "$USERHOME/.grass.cshrc" ]
+    then
+	cat "$USERHOME/.grass.cshrc" >> "$cshrc"
+    fi
+
+    if [ -r "$USERHOME/.cshrc" ]
+    then
+	grep '^ *set  *mail *= *' "$USERHOME/.cshrc" >> "$cshrc"
+    fi
+
+    if [ -r "$USERHOME/.tcshrc" ]
+    then
+	grep '^ *set  *mail *= *' "$USERHOME/.tcshrc" >> "$cshrc"
+    fi
+
+    if [ -r "$USERHOME/.login" ]
+    then
+	grep '^ *set  *mail *= *' "$USERHOME/.login" >> "$cshrc"
+    fi
+
+    echo "set path = ( $PATH ) " | sed 's/:/ /g' >> "$cshrc"
+
+    cp "$cshrc" "$tcshrc"
+    "$ETC/run" "$SHELL"
+    EXIT_VAL=$?
+
+    HOME="$USERHOME"
+    export HOME
+    ;;
+
+bash|msh|cygwin)
+    # save command history in mapset dir and remember more
+    export HISTFILE="$LOCATION/.bash_history"
+    if [ -z "$HISTSIZE" ] && [ -z "$HISTFILESIZE" ] ; then 
+	export HISTSIZE=3000
+    fi
+
+    # instead of changing $HOME, start bash with: --rcfile "$LOCATION/.bashrc" ?
+    #   if so, must care be taken to explicity call .grass.bashrc et al for
+    #   non-interactive bash batch jobs?
+    USERHOME="$HOME"      # save original home
+    HOME="$LOCATION"      # save .bashrc in $LOCATION
+    export HOME
+    bashrc="$HOME/.bashrc"
+    rm -f "$bashrc"
+    echo "test -r ~/.alias && . ~/.alias" >> "$bashrc"
+    echo "PS1='GRASS GRASS_VERSION_NUMBER ($LOCATION_NAME):\w > '" >> "$bashrc"
+    # Use \"' to allow spaces in $GISBASE
+    echo "PROMPT_COMMAND=\"'$GISBASE/etc/prompt.sh'\"" >> "$bashrc"
+
+    if [ -r "$USERHOME/.grass.bashrc" ]
+    then
+        cat "$USERHOME/.grass.bashrc" >> "$bashrc"
+    fi
+
+    echo "export PATH=\"$PATH\"" >> "$bashrc"
+    echo "export HOME=\"$USERHOME\"" >> "$bashrc" # restore user home path
+    echo 'export GRASS_SHELL_PID=$$' >> "$bashrc" # can be used to terminate GRASS session from GUI
+    if [ "$GRASS_GUI" = tcltk ] || [ "$GRASS_GUI" = gis.m ]; then
+       echo '$GISBASE/scripts/gis.m' >> "$bashrc" # Start gis.m
+    fi;
+    echo 'trap "echo \"GUI issued an exit\"; exit" SIGQUIT' >> "$bashrc"
+
+    "$ETC/run" "$SHELL"
+    EXIT_VAL=$?
+
+    HOME="$USERHOME"
+    export HOME
+    ;;
+
+*)
+    if [ "$MINGW" ] ; then
+	GRASS_BASE_VERSION=`echo "$GRASS_VERSION" | cut -f1,2 -d.`
+	PS1="GRASS $GRASS_BASE_VERSION> "
+	export PS1
+
+	# "$ETC/run" doesn't work at all???
+	"$SHELL"
+	rm -rf "$LOCATION/.tmp"/*  # remove gis.m session files from .tmp
+    else
+	PS1="GRASS $GRASS_VERSION ($LOCATION_NAME):\w > "
+	export PS1
+
+	"$ETC/run" "$SHELL"
+	EXIT_VAL=$?
+    fi
+    ;;
+esac
+
+trap 2 3 15
+
+# GRASS session finished
+if [ "$MINGW" ] ; then
+	:
+# TODO: uncomment when PDCurses works.
+#	cls
+else
+	if [ -z "$GRASS_BATCH_JOB" ] && [ "$GRASS_DEBUG" -eq 0 ] ; then
+	   tput clear
+	fi
+fi
+
+echo "Closing monitors ..."
+for MON  in `d.mon -L | grep running | grep -v "not running" | sed 's/ .*//'`
+do
+    if [ "$GRASS_DEBUG" -ne 0 ] ; then
+       echo "d.mon stop=$MON"
+    fi
+    d.mon stop="$MON"
+done
+
+# Attempt to close any open gis.m instances.
+if [ -n "$TCLTKGRASSBASE" ] && [ `ps -a | grep -c "$GRASS_WISH"` -ge 1 ] ; then
+       echo "Closing open gis.m sessions....."
+       echo 'foreach gwin [lsearch -all -inline [winfo interps] gm_tcl*] {
+               catch {send -async $gwin Gm::remoteExit $env(GIS_LOCK)}
+       }
+       exit' | "$GRASS_WISH" #>/dev/null 2>&1
+fi
+
+echo "Cleaning up temporary files ..."
+
+"$ETC/clean_temp" > /dev/null
+rm -f "$lockfile"
+
+# Save GISRC
+cp "$GISRC" "$GISRCRC"
+
+
+cleanup_tmp
+#### after this point no more grass modules may be called ####
+
+if [ -x "$GRASS_BATCH_JOB" ] ; then
+   echo "Batch job '$GRASS_BATCH_JOB' (defined in GRASS_BATCH_JOB variable) was executed."
+   echo "Goodbye from GRASS GIS"
+   exit $EXIT_VAL
+else
+   echo "Done."
+   echo
+   echo
+   echo
+   echo "Goodbye from GRASS GIS"
+   echo
+fi
+
diff -ruN grass-6.4.2-old/macosx/Makefile grass-6.4.2/macosx/Makefile
--- grass-6.4.2-old/macosx/Makefile	2012-05-08 19:28:13.000000000 +0900
+++ grass-6.4.2/macosx/Makefile	2012-05-08 19:28:50.000000000 +0900
@@ -4,8 +4,8 @@
 
 MACOSX_APP_NAME = GRASS-${GRASS_VERSION_MAJOR}.${GRASS_VERSION_MINOR}.app
 MACOSX_APPDIR = ${MACOSX_APP_NAME}/Contents/MacOS
-INST_DIR_MACOSX = ${prefix}/${MACOSX_APPDIR}
-MACOSX_SUPPDIR = /Library/GRASS/${GRASS_VERSION_MAJOR}.${GRASS_VERSION_MINOR}
+INST_DIR_MACOSX = ${INST_DIR}/Applications/${MACOSX_APPDIR}
+MACOSX_SUPPDIR = ${INST_DIR}/lib/GRASS/${GRASS_VERSION_MAJOR}.${GRASS_VERSION_MINOR}
 MACOSX_BUNDLE_PREFIX = ${GRASS_HOME}/macosx/dist/${MACOSX_APPDIR}
 VER_MINOR_REL = `printf "%d0%d" ${GRASS_VERSION_MINOR} ${GRASS_VERSION_RELEASE}`
 VER_DATE = `date +"%g%m%d"`
@@ -50,12 +50,12 @@
 
 # Duplicated, mostly, from the top-level makefile.
 
-real-install-macosx: INST_DIR_TARGET = ${INST_DIR}
-real-install-macosx: PREFIX_TARGET = ${prefix}
+real-install-macosx: INST_DIR_TARGET = ${INST_DIR_MACOSX}
+real-install-macosx: PREFIX_TARGET = ${INST_DIR}
 real-install-macosx: install-basic-macosx macosx-support-dir bundle-macosx
 	-cd ${GISBASE} ; tar cBf - modbuild | (cd ${MACOSX_SUPPDIR} ; tar xBf - ) 2>/dev/null
 	@# help file package
-	${LN_DIR} "${INST_DIR_TARGET}/docs/html" /Library/Documentation/Help/GRASS-${GRASS_VERSION_MAJOR}.${GRASS_VERSION_MINOR}
+	${LN_DIR} "${INST_DIR_TARGET}/docs/html" ${INST_DIR_MACOSX}/share/doc/GRASS-${GRASS_VERSION_MAJOR}.${GRASS_VERSION_MINOR}
 
 # create a packagemaker installer package.
 # pretty much the same as install, but needs intermediate install location
@@ -85,7 +85,7 @@
 
 install-basic-macosx:
 	${MAKE_DIR_CMD} ${INST_DIR_TARGET}
-	-cd ${GISBASE} ; tar cBf - ${MACOSX_APP_NAME} | (cd ${PREFIX_TARGET} ; tar xBf - ) 2>/dev/null
+	-cd ${GISBASE} ; tar cBf - ${MACOSX_APP_NAME} | (cd ${PREFIX_TARGET}/Applications ; tar xBf - ) 2>/dev/null
 	-cd ${GISBASE} ; tar cBf - $(FILES) | (cd ${INST_DIR_TARGET} ; tar xBf - ) 2>/dev/null
 	-cd ${GISBASE} ; tar cBf - bin | (cd ${INST_DIR_TARGET} ; tar xBf - ) 2>/dev/null
 	-cd ${GISBASE} ; tar cBf - bwidget | (cd ${INST_DIR_TARGET} ; tar xBf - ) 2>/dev/null
@@ -100,10 +100,10 @@
 	-cd ${GISBASE} ; tar cBf - include | (cd ${INST_DIR_TARGET} ; tar xBf - ) 2>/dev/null
 	-cd ${GISBASE} ; tar cBf - lib | (cd ${INST_DIR_TARGET} ; tar xBf - ) 2>/dev/null
 	-sed 's#'${GISBASE}'#'${INST_DIR_TARGET}'#g' ${GISBASE}/etc/monitorcap > ${INST_DIR_TARGET}/etc/monitorcap
-	-chmod -R a+rX ${PREFIX_TARGET}/${MACOSX_APP_NAME} 2>/dev/null
+	-chmod -R a+rX ${PREFIX_TARGET}/Applications/${MACOSX_APP_NAME} 2>/dev/null
 	-cd ${GRASS_HOME} ; tar cBf - gem/skeleton | (cd ${INST_DIR_TARGET}/etc ; tar xBf - ) 2>/dev/null
 	-${INSTALL} ${GRASS_HOME}/gem/gem6 ${INST_DIR_TARGET} 2>/dev/null
-	-touch ${PREFIX_TARGET}/${MACOSX_APP_NAME}
+	-touch ${PREFIX_TARGET}/Applications/${MACOSX_APP_NAME}
 
 macosx-support-dir:
 	${MAKE_DIR_CMD} ${MACOSX_SUPPDIR}
diff -ruN grass-6.4.2-old/macosx/Makefile.orig grass-6.4.2/macosx/Makefile.orig
--- grass-6.4.2-old/macosx/Makefile.orig	1970-01-01 09:00:00.000000000 +0900
+++ grass-6.4.2/macosx/Makefile.orig	2011-05-11 13:21:55.000000000 +0900
@@ -0,0 +1,117 @@
+MODULE_TOPDIR = ..
+
+include $(MODULE_TOPDIR)/include/Make/Platform.make
+
+MACOSX_APP_NAME = GRASS-${GRASS_VERSION_MAJOR}.${GRASS_VERSION_MINOR}.app
+MACOSX_APPDIR = ${MACOSX_APP_NAME}/Contents/MacOS
+INST_DIR_MACOSX = ${prefix}/${MACOSX_APPDIR}
+MACOSX_SUPPDIR = /Library/GRASS/${GRASS_VERSION_MAJOR}.${GRASS_VERSION_MINOR}
+MACOSX_BUNDLE_PREFIX = ${GRASS_HOME}/macosx/dist/${MACOSX_APPDIR}
+VER_MINOR_REL = `printf "%d0%d" ${GRASS_VERSION_MINOR} ${GRASS_VERSION_RELEASE}`
+VER_DATE = `date +"%g%m%d"`
+MAKE_DIR_CMD = mkdir -p -m 755
+LN = /bin/ln -sf
+LN_DIR = /bin/ln -sfh
+# get python version - use python in path, should be config'd python
+PYVER = `python -V 2>&1 | cut -d \  -f 2 | cut -d . -f 1,2`
+
+# packagemaker location, options and behaviour changed in xcode 3
+ifeq ($(findstring darwin8,$(ARCH)),darwin8)
+XCODE_VER = xcode2
+PACKAGEMAKER = /Developer/Tools/packagemaker
+PKG_INST_DIR = ${prefix}/${MACOSX_APP_NAME}
+else
+XCODE_VER = xcode3
+PACKAGEMAKER = /Developer/usr/bin/packagemaker
+PKG_INST_DIR = ${prefix}
+endif
+
+SUBDIRS = 
+ifeq ($(MACOSX_APP),1)
+SUBDIRS = app modbuild
+endif
+
+FILES = AUTHORS COPYING CHANGES REQUIREMENTS.html GPL.TXT
+
+include $(MODULE_TOPDIR)/include/Make/Dir.make
+
+default: subdirs
+
+include bundle.make
+
+install-macosx:
+	echo ${ARCH_DISTDIR}/${MACOSX_APP_NAME}
+	@ if [ ! -d ${ARCH_DISTDIR}/${MACOSX_APP_NAME} ] ; then \
+		echo "ERROR: GRASS.app has not been compiled. Try \"make\" in the top level source dir first."; \
+		echo "  Installation aborted, exiting Make."; \
+		exit; \
+	fi; \
+	${MAKE} real-install-macosx
+
+# Duplicated, mostly, from the top-level makefile.
+
+real-install-macosx: INST_DIR_TARGET = ${INST_DIR}
+real-install-macosx: PREFIX_TARGET = ${prefix}
+real-install-macosx: install-basic-macosx macosx-support-dir bundle-macosx
+	-cd ${GISBASE} ; tar cBf - modbuild | (cd ${MACOSX_SUPPDIR} ; tar xBf - ) 2>/dev/null
+	@# help file package
+	${LN_DIR} "${INST_DIR_TARGET}/docs/html" /Library/Documentation/Help/GRASS-${GRASS_VERSION_MAJOR}.${GRASS_VERSION_MINOR}
+
+# create a packagemaker installer package.
+# pretty much the same as install, but needs intermediate install location
+# to assemble package parts.
+
+bindist-macosx: INST_DIR_TARGET = ${MACOSX_BUNDLE_PREFIX}
+bindist-macosx: PREFIX_TARGET = ${GRASS_HOME}/macosx/dist
+bindist-macosx: install-basic-macosx bundle-macosx
+	@# installer pkg resources
+	${MAKE_DIR_CMD} dist/resources
+	-sed -e "s#@INST_DIR@#${INST_DIR}#g" -e "s#@MACOSX_SUPPDIR@#${MACOSX_SUPPDIR}#g" -e "s#@GRASS_VER@#${GRASS_VERSION_MAJOR}.${GRASS_VERSION_MINOR}#g" -e "s#@PYVER@#${PYVER}#g" pkg/resources/postflight.in > dist/resources/postflight
+	-chmod a+rx dist/resources/postflight
+	-sed -e "s#@GRASS_VER@#${GRASS_VERSION_MAJOR}.${GRASS_VERSION_MINOR}#g" pkg/resources/Description.plist.in > dist/Description.plist
+	-sed -e "s#@GRASS_VERSION_MAJOR@#${GRASS_VERSION_MAJOR}#g" -e "s#@GRASS_VERSION_MINOR@#${GRASS_VERSION_MINOR}#g" -e "s#@GRASS_VERSION_RELEASE@#${GRASS_VERSION_RELEASE}#g" -e "s#@VER_MINOR_REL@#${VER_MINOR_REL}#g" -e "s#@VER_DATE@#${VER_DATE}#g" -e "s#@PKG_INST_DIR@#${PKG_INST_DIR}#g" pkg/resources/Info.plist.in > dist/Info.plist
+	-${INSTALL_DATA} pkg/resources/License.rtf dist/resources
+	-${INSTALL_DATA} pkg/resources/ReadMe.rtf dist/resources
+	-cd ${GISBASE} ; tar cBf - modbuild | (cd ${GRASS_HOME}/macosx/dist/resources ; tar xBf - ) 2>/dev/null
+	@# build the package
+ifeq ($(XCODE_VER),xcode3)
+	${PACKAGEMAKER} --target 10.4 --root-volume-only --id org.osgeo.grass --root dist/${MACOSX_APP_NAME} --info dist/Info.plist --out "GRASS-${GRASS_VERSION_MAJOR}.${GRASS_VERSION_MINOR}.pkg" --resources dist/resources
+	rm -f "GRASS-${GRASS_VERSION_MAJOR}.${GRASS_VERSION_MINOR}.pkg/Contents/Resources/TokenDefinitions.plist"
+else
+	${PACKAGEMAKER} -build -ds -p "GRASS-${GRASS_VERSION_MAJOR}.${GRASS_VERSION_MINOR}.pkg" -f dist/${MACOSX_APP_NAME} -r dist/resources -i dist/Info.plist -d dist/Description.plist
+endif
+	@# remove intermediate files
+	@# -rm -rf dist 2>/dev/null
+
+install-basic-macosx:
+	${MAKE_DIR_CMD} ${INST_DIR_TARGET}
+	-cd ${GISBASE} ; tar cBf - ${MACOSX_APP_NAME} | (cd ${PREFIX_TARGET} ; tar xBf - ) 2>/dev/null
+	-cd ${GISBASE} ; tar cBf - $(FILES) | (cd ${INST_DIR_TARGET} ; tar xBf - ) 2>/dev/null
+	-cd ${GISBASE} ; tar cBf - bin | (cd ${INST_DIR_TARGET} ; tar xBf - ) 2>/dev/null
+	-cd ${GISBASE} ; tar cBf - bwidget | (cd ${INST_DIR_TARGET} ; tar xBf - ) 2>/dev/null
+	-cd ${GISBASE} ; tar cBf - docs | (cd ${INST_DIR_TARGET} ; tar xBf - ) 2>/dev/null
+	-cd ${GISBASE} ; tar cBf - driver | (cd ${INST_DIR_TARGET} ; tar xBf - ) 2>/dev/null
+	-cd ${GISBASE} ; tar cBf - etc | (cd ${INST_DIR_TARGET} ; tar xBf - ) 2>/dev/null
+	-cd ${GISBASE} ; tar cBf - fonts | (cd ${INST_DIR_TARGET} ; tar xBf - ) 2>/dev/null
+	-cd ${GISBASE} ; tar cBf - man | (cd ${INST_DIR_TARGET} ; tar xBf - ) 2>/dev/null
+	-cd ${GISBASE} ; tar cBf - scripts | (cd ${INST_DIR_TARGET} ; tar xBf - ) 2>/dev/null
+	-cd ${GISBASE} ; tar cBf - tools | (cd ${INST_DIR_TARGET} ; tar xBf - ) 2>/dev/null
+	if [ ${LOCALE} -eq 1 ] ; then cd ${GISBASE} ; tar cBf - locale | (cd ${INST_DIR_TARGET} ; tar xBf - ) 2>/dev/null ; fi
+	-cd ${GISBASE} ; tar cBf - include | (cd ${INST_DIR_TARGET} ; tar xBf - ) 2>/dev/null
+	-cd ${GISBASE} ; tar cBf - lib | (cd ${INST_DIR_TARGET} ; tar xBf - ) 2>/dev/null
+	-sed 's#'${GISBASE}'#'${INST_DIR_TARGET}'#g' ${GISBASE}/etc/monitorcap > ${INST_DIR_TARGET}/etc/monitorcap
+	-chmod -R a+rX ${PREFIX_TARGET}/${MACOSX_APP_NAME} 2>/dev/null
+	-cd ${GRASS_HOME} ; tar cBf - gem/skeleton | (cd ${INST_DIR_TARGET}/etc ; tar xBf - ) 2>/dev/null
+	-${INSTALL} ${GRASS_HOME}/gem/gem6 ${INST_DIR_TARGET} 2>/dev/null
+	-touch ${PREFIX_TARGET}/${MACOSX_APP_NAME}
+
+macosx-support-dir:
+	${MAKE_DIR_CMD} ${MACOSX_SUPPDIR}
+	${MAKE_DIR_CMD} ${MACOSX_SUPPDIR}/Modules/bin
+	${MAKE_DIR_CMD} ${MACOSX_SUPPDIR}/Modules/docs/html
+	${MAKE_DIR_CMD} ${MACOSX_SUPPDIR}/Modules/etc
+	${MAKE_DIR_CMD} ${MACOSX_SUPPDIR}/Modules/lib
+
+clean: cleansubdirs
+	-rm -rf ${ARCH_DISTDIR}/${MACOSX_APP_NAME}/ 2>/dev/null
+	-rm -rf ${ARCH_DISTDIR}/modbuild/ 2>/dev/null
diff -ruN grass-6.4.2-old/macosx/app/build_gui_user_menu.sh grass-6.4.2/macosx/app/build_gui_user_menu.sh
--- grass-6.4.2-old/macosx/app/build_gui_user_menu.sh	2012-05-08 19:28:13.000000000 +0900
+++ grass-6.4.2/macosx/app/build_gui_user_menu.sh	2012-05-08 19:28:50.000000000 +0900
@@ -13,7 +13,7 @@
 
 GRASS_MMVER=`cut -d . -f 1-2 "$GISBASE/etc/VERSIONNUMBER"`
 BINDIR="$HOME/Library/GRASS/$GRASS_MMVER/Modules/bin"
-BINDIRG="/Library/GRASS/$GRASS_MMVER/Modules/bin"
+BINDIRG="@PREFIX@/lib/GRASS/$GRASS_MMVER/Modules/bin"
 MENUDIR="$HOME/Library/GRASS/$GRASS_MMVER/Modules/etc"
 
 echo "Rebuilding Addon menu..."
diff -ruN grass-6.4.2-old/macosx/app/build_html_user_index.sh grass-6.4.2/macosx/app/build_html_user_index.sh
--- grass-6.4.2-old/macosx/app/build_html_user_index.sh	2012-05-08 19:28:13.000000000 +0900
+++ grass-6.4.2/macosx/app/build_html_user_index.sh	2012-05-08 19:28:50.000000000 +0900
@@ -19,13 +19,13 @@
 GRASS_MMVER=`cut -d . -f 1-2 "$GISBASE/etc/VERSIONNUMBER"`
 GRASSVERSION=`cat "$GISBASE/etc/VERSIONNUMBER"`
 HTMLDIR="$HOME/Library/GRASS/$GRASS_MMVER/Modules/docs/html"
-HTMLDIRG="/Library/GRASS/$GRASS_MMVER/Modules/docs/html"
+HTMLDIRG="@PREFIX@/lib/GRASS/$GRASS_MMVER/Modules/docs/html"
 
 # $1 is current path to GRASS.app/Contents/MacOS, defaults to /Applications
 if [ "$1" != "" ] ; then
 	GISBASE=$1
 else
-	GISBASE="/Applications/GRASS-$GRASS_MMVER.app/Contents/MacOS"
+	GISBASE="@PREFIX@/Applications/GRASS-$GRASS_MMVER.app/Contents/MacOS"
 fi
 
 write_html_header()
diff -ruN grass-6.4.2-old/macosx/app/grass.sh.in grass-6.4.2/macosx/app/grass.sh.in
--- grass-6.4.2-old/macosx/app/grass.sh.in	2012-05-08 19:28:13.000000000 +0900
+++ grass-6.4.2/macosx/app/grass.sh.in	2012-05-08 19:28:50.000000000 +0900
@@ -32,7 +32,7 @@
 grass_ver=`cut -d . -f 1-2 "$GISBASE/etc/VERSIONNUMBER"`
 
 GISBASE_USER="$HOME/Library/GRASS/$grass_ver"
-GISBASE_SYSTEM="/Library/GRASS/$grass_ver"
+GISBASE_SYSTEM="@PREFIX@/lib/GRASS/$grass_ver"
 
 # for extra utils
 # ideally user should have these in their PATH, but make sure here
@@ -96,47 +96,13 @@
 # assume user TclTk progs in default build location /usr/local/bin.
 # check even if /usr/local/bin not in PATH, this is where Aqua will be
 # also assume matching tclsh alongside wish
-if [ ! "$GRASS_WISH" ] ; then
-	gwish=""
-	gtclsh=""
-	if [ -e "/usr/local/bin/wish8.5" ] ; then
-		gwish="/usr/local/bin/wish8.5"
-		gtclsh="/usr/local/bin/tclsh8.5"
-	else
-		# check for any other wish8.5
-		wish85=`type -p wish8.5`
-		tclsh85=`type -p tclsh8.5`
-		if [ "$wish85" ] ; then
-			gwish="$wish85"
-			gtclsh="$tclsh85"
-		else
-			# check for any wish8.4
-			wish84=`type -p wish8.4`
-			tclsh84=`type -p tclsh8.4`
-			if [ ! "$wish84" ] ; then
-				# or maybe /usr/local/bin not in PATH
-				wish84="/usr/local/bin/wish8.4"
-				tclsh84="/usr/local/bin/tclsh8.4"
-			fi
-			if [ -e "$wish84" ] ; then
-				# make sure it's not aqua
-				# aqua wish is a shell script that starts framework wish
-				if [ "`file $wish84 | grep 'shell script'`" ] ; then
-					echo "Warning: TclTk Aqua 8.4 unsupported"
-				else
-					gwish="$wish84"
-					gtclsh="$tclsh84"
-				fi
-			fi
-		fi
-	fi
-	if [ "$gwish" ] ; then
-		GRASS_WISH="$gwish"
-		export GRASS_WISH
-		GRASS_TCLSH="$gtclsh"
-		export GRASS_TCLSH
-	fi
-fi
+
+gwish="MACORX11/bin/wish"
+gtclsh="MACORX11/bin/tclsh"
+GRASS_WISH="$gwish"
+export GRASS_WISH
+GRASS_TCLSH="$gtclsh"
+export GRASS_TCLSH
 
 ### X11 stuff
 
@@ -184,62 +150,15 @@
 # change GRASS_WXBUNDLED and pyver_want here from bundle.make, or manually
 GRASS_WXBUNDLED=
 export GRASS_WXBUNDLED
-pyexe="pythonw"
+pyexe="python"
 GRASS_PYTHONWX="$pyexe"
 pyver_want="@PYVER@"
 GRASS_WX64BIT="@WX64BIT@"
 export GRASS_WX64BIT
-# make sure python version used matches what wxpython wants
-py=""
-# did user set GRASS_PYTHON already? check it (must have pythonw)
-if [ "$GRASS_PYTHON" ] ; then
-	py=`echo "$GRASS_PYTHON" | grep pythonw`
-	if [ "$py" ] ; then
-		case $GRASS_PYTHON in
-			/*) py="$GRASS_PYTHON" ;;
-			*) py=`type -p $GRASS_PYTHON`
-		esac
-		pyver=`$py -V 2>&1 | grep " $pyver_want"`
-		if [ ! "$pyver" ] ; then
-			py=""
-		fi
-	else
-		py=""
-	fi
-fi # GRASS_PYTHON
-# try in shell path
-if [ ! "$py" ] ; then
-	py=`type -p pythonw$pyver_want`
-	if [ "$py" ] ; then
-		pyver=`$py -V 2>&1 | grep " $pyver_want"`
-		if [ ! "$pyver" ] ; then
-			py=""
-		fi
-	fi
-fi
-# try standard framework
-if [ ! "$py" ] ; then
-	py="/Library/Frameworks/Python.framework/Versions/$pyver_want/bin/python"
-	if [ ! -x "$py" ] ; then
-		py=""
-	fi
-fi
-# try system (may be the same as in shell path)
-if [ ! "$py" ] ; then
-	py="/usr/bin/pythonw$pyver_want"
-	pyver=`$py -V 2>&1 | grep " $pyver_want"`
-	if [ ! "$pyver" ] ; then
-		py=""
-	fi
-fi
 
-if [ "$py" ] ; then
-	echo "$pyver found."
-	GRASS_PYTHONWX="$py"
-else
-	echo "Warning: No Python $pyver_want found, needed by wxPython."
-	echo "         The wxPython GUI may not work properly."
-fi
+
+# Use Fink's python
+GRASS_PYTHONWX="@PREFIX@/bin/python"
 export GRASS_PYTHONWX
 # we will execute python scripts from the python wrapper script
 GRASS_PYTHON="python"
@@ -252,8 +171,8 @@
 	if [ -f "$GRASSRC" ] ; then
 		GRASS_GUI=`awk '/GRASS_GUI/ {print $2}' "$GRASSRC"`
 	fi
-	if [ -z "$GRASS_GUI" ] ; then
-		unset GRASS_GUI
+	if [ ! "$GRASS_GUI" ] ; then
+		GRASS_GUI="tcltk"
 	fi
 fi
 if [ "$GRASS_GUI" = "text" ] && [ "$x11" = "tig" ] ; then
diff -ruN grass-6.4.2-old/macosx/app/python_wrapper grass-6.4.2/macosx/app/python_wrapper
--- grass-6.4.2-old/macosx/app/python_wrapper	2012-05-08 19:28:13.000000000 +0900
+++ grass-6.4.2/macosx/app/python_wrapper	2012-05-08 19:28:50.000000000 +0900
@@ -29,9 +29,7 @@
 SYSARCH=`uname -p`
 SYSVER=`uname -r | cut -d . -f 1`
 
-if [ ! "$GRASS_PYTHONWX" ] ; then
-	GRASS_PYTHONWX="pythonw"
-fi
+GRASS_PYTHONWX="python"
 # can't run python 64bit if wx not 64bit, assume OSX 10.5+  possible 64bit
 if [ $(($SYSVER)) -gt 5 ] && [ "$GRASS_WX64BIT" = "0" ] ; then
 	case $SYSARCH in
diff -ruN grass-6.4.2-old/macosx/modbuild/Makefile grass-6.4.2/macosx/modbuild/Makefile
--- grass-6.4.2-old/macosx/modbuild/Makefile	2012-05-08 19:28:13.000000000 +0900
+++ grass-6.4.2/macosx/modbuild/Makefile	2012-05-08 19:28:50.000000000 +0900
@@ -9,7 +9,7 @@
 	MACOSX_APP_NAME = GRASS-${GRASS_VERSION_MAJOR}.${GRASS_VERSION_MINOR}.app
 endif
 MACOSX_APPDIR = ${MACOSX_APP_NAME}/Contents/MacOS
-INST_DIR_MACOSX = ${prefix}/${MACOSX_APPDIR}
+INST_DIR_MACOSX = ${INST_DIR}/Applications/${MACOSX_APPDIR}
 
 default: modbuild
 
@@ -19,7 +19,7 @@
 	-cp -f ReadMe.rtf $(ARCH_DISTDIR)/modbuild/
 	mkdir -p $(ARCH_DISTDIR)/modbuild/dist.$(ARCH)
 	-cp -rf $(ARCH_DISTDIR)/demolocation $(ARCH_DISTDIR)/modbuild/dist.$(ARCH)/
-	-sed -e 's,^GISDBASE.*,GISDBASE = /Library/GRASS/$(GRASS_VERSION_MAJOR).$(GRASS_VERSION_MINOR)/modbuild/dist.$(ARCH),g' $(ARCH_DISTDIR)/demolocation/.grassrc$(GRASS_VERSION_MAJOR)$(GRASS_VERSION_MINOR) > $(ARCH_DISTDIR)/modbuild/dist.$(ARCH)/demolocation/.grassrc$(GRASS_VERSION_MAJOR)$(GRASS_VERSION_MINOR)
+	-sed -e 's,^GISDBASE.*,GISDBASE = @PREFIX@/lib/GRASS/$(GRASS_VERSION_MAJOR).$(GRASS_VERSION_MINOR)/modbuild/dist.$(ARCH),g' $(ARCH_DISTDIR)/demolocation/.grassrc$(GRASS_VERSION_MAJOR)$(GRASS_VERSION_MINOR) > $(ARCH_DISTDIR)/modbuild/dist.$(ARCH)/demolocation/.grassrc$(GRASS_VERSION_MAJOR)$(GRASS_VERSION_MINOR)
 	mkdir -p $(ARCH_DISTDIR)/modbuild/module
 	mkdir -p $(ARCH_DISTDIR)/modbuild/include/Make
 	-cp $(MODULE_TOPDIR)/include/Make/Dir.make $(ARCH_DISTDIR)/modbuild/include/Make/
@@ -44,7 +44,7 @@
 	@#GISBASE = $(INST_DIR_MACOSX)\
 	@#endif#g'
 	@# html.make needs a little change
-	sed -e 's,GISRC=$$(RUN_GISBASE),GISRC=/Library/GRASS/$(GRASS_VERSION_MAJOR).$(GRASS_VERSION_MINOR)/modbuild/dist.$$(ARCH),g' $(MODULE_TOPDIR)/include/Make/Html.make > $(ARCH_DISTDIR)/modbuild/include/Make/Html.make
+	sed -e 's,GISRC=$$(RUN_GISBASE),GISRC=@PREFIX@/lib/GRASS/$(GRASS_VERSION_MAJOR).$(GRASS_VERSION_MINOR)/modbuild/dist.$$(ARCH),g' $(MODULE_TOPDIR)/include/Make/Html.make > $(ARCH_DISTDIR)/modbuild/include/Make/Html.make
 	-cp $(MODULE_TOPDIR)/include/Make/Lib.make $(ARCH_DISTDIR)/modbuild/include/Make/
 	-cp $(MODULE_TOPDIR)/include/Make/Man.make $(ARCH_DISTDIR)/modbuild/include/Make/
 	sed -e 's,$$(DEPENDENCIES),,g' $(MODULE_TOPDIR)/include/Make/Module.make > $(ARCH_DISTDIR)/modbuild/include/Make/Module.make
