diff -ruN dpkg-1.17.6.orig/fink/buildflags.conf dpkg-1.17.6/fink/buildflags.conf
--- dpkg-1.17.6.orig/fink/buildflags.conf	1969-12-31 17:00:00.000000000 -0700
+++ dpkg-1.17.6/fink/buildflags.conf	2013-06-22 20:26:06.000000000 -0600
@@ -0,0 +1,30 @@
+# defaults
+APPEND CFLAGS -g -O2
+APPEND CXXFLAGS -g -O2
+APPEND FFLAGS -g -O2
+
+# debian stackprotector
+APPEND CFLAGS -fstack-protector         
+APPEND CXXFLAGS -fstack-protector         
+
+# debian pie
+APPEND CFLAGS -fPIE
+APPEND CXXFLAGS -fPIE
+APPEND LDFLAGS -fPIE -Wl,-pie
+
+# debian relro
+APPEND LDFLAGS -Wl,-read_only_stubs
+
+# debian bindnow
+APPEND LDFLAGS -Wl,-bind_at_load
+
+# debian fortify
+APPEND CPPFLAGS -D_FORTIFY_SOURCE=2
+
+# debian format
+PREPEND CFLAGS -Wformat -Werror=format-security
+PREPEND CXXFLAGS -Wformat -Werror=format-security
+
+# fink defaults
+PREPEND CPPFLAGS -I@FINKPREFIX@/include
+PREPEND LDFLAGS -L@FINKPREFIX@/lib
diff -ruN dpkg-1.17.6.orig/fink/dpkg.cron.daily dpkg-1.17.6/fink/dpkg.cron.daily
--- dpkg-1.17.6.orig/fink/dpkg.cron.daily	1969-12-31 17:00:00.000000000 -0700
+++ dpkg-1.17.6/fink/dpkg.cron.daily	2013-09-10 09:13:20.000000000 -0600
@@ -0,0 +1,10 @@
+#!/bin/sh
+
+# Backup the 7 last versions of dpkg's status file
+if cd @FINKPREFIX@/var/backups ; then
+    if ! cmp -s dpkg.status.0 @FINKPREIFX@/var/lib/dpkg/status ; then
+            cp -p @FINKPREFIX@/var/lib/dpkg/status dpkg.status
+            savelog -c 7 dpkg.status >/dev/null
+    fi
+fi
+
diff -ruN dpkg-1.17.6.orig/fink/md5sum dpkg-1.17.6/fink/md5sum
--- dpkg-1.17.6.orig/fink/md5sum	1969-12-31 17:00:00.000000000 -0700
+++ dpkg-1.17.6/fink/md5sum	2013-05-28 08:30:00.000000000 -0600
@@ -0,0 +1,322 @@
+#!/usr/bin/perl
+use strict;
+use warnings;
+
+## md5sum wrapper for Mac md5 tool ##
+# This wrapper should be installed in bin/md5sum. Since dpkg 1.10, md5sum was
+# removed, this script is intended to replace it for fink systems.
+#
+# Written by Sjors Gielen, licensed under the same license as dpkg, the
+# GNU General Public License version 2.
+
+my $md5_bin = "/sbin/md5";
+my $binary_mode = "";
+my $check_mode = 0;
+my $quiet = 0;
+my $warn  = 0;
+my $return = 0;
+my @files;
+
+read_args(@ARGV);
+
+if( @files == 0 )
+{
+  push @files, "-";
+}
+
+if( $check_mode )
+{
+  # `md5` doesn't have a check mode, so we have to implement it ourselves
+  run_check_mode( @files );
+  exit $return;
+}
+
+if( $quiet || $warn )
+{
+  print STDERR <<"NOCHECKMODE";
+$0: the --status, --warn and -w options are meaningful only when verifying checksums
+Try `md5sum --help' for more information.
+NOCHECKMODE
+  exit $return;
+}
+
+my $stdin_done = 0;
+for my $file( @files )
+{
+  if( $file eq "-" and $stdin_done )
+  {
+    # second - is empty, so md5sum is of the empty string
+    print "d41d8cd98f00b204e9800998ecf8427e  $binary_mode-\n";
+    next;
+  }
+
+  my $checksum = checksum_for( $file );
+  if( !$checksum ) {
+    # error was already printed
+    next;
+  }
+
+  # the old md5sum, nor md5, understand binary mode, so...
+  print "$checksum  $binary_mode$file\n";
+
+  if( $file eq "-" )
+  {
+    $stdin_done = 1;
+  }
+}
+
+exit;
+
+sub help_and_exit()
+{
+  print <<"HELP";
+Usage: $0 [OPTION] [FILE]...
+Print or check MD5 (128-bit) checksums.
+With no FILE, or when FILE is -, read standard input.
+This md5sum is a wrapper around Mac's md5. If you can use md5 instead, please
+do, since this script is likely to be removed at some point.
+
+  -b, --binary            no difference on Mac platforms
+  -c, --check             read MD5 sums from the FILEs and check them
+  -t, --text              no difference on Mac platforms
+
+The following two options are useful only when verifying checksums:
+      --status            don't output anything, status code shows success
+  -w, --warn              warn about improperly formatted checksum lines
+
+      --help     display this help and exit
+      --version  output version information and exit
+
+The sums are computed as described in RFC 1321.  When checking, the input
+should be a former output of this program.  The default mode is to print
+a line with checksum, a character indicating type (`*' for binary, ` ' for
+text), and name for each FILE.
+
+Report bugs to <http://fink.sourceforge.net>.
+HELP
+  exit;
+}
+
+sub version_and_exit
+{
+  print <<"VERSION";
+md5sum (Fink md5sum) 1.0
+Copyright (C) 2010 Sjors Gielen
+This wrapper should be installed in bin/md5sum. Since dpkg 1.10, md5sum was
+removed, this script is intended to replace it for fink systems.
+License from dpkg: GNU GPL version 2.
+This is free software: you are free to change and redistribute it.
+There is NO WARRENTY, to the extent permitted by law.
+
+Written by Sjors Gielen.
+VERSION
+  exit;
+}
+
+sub read_args
+{
+  my $no_opts = 0;
+  for(@_)
+  {
+    if( !$no_opts and /^--(.*)$/ )
+    {
+      my $opt = $1;
+      if( $opt eq "help" )
+      {
+        help_and_exit();
+      }
+      elsif( $opt eq "version" )
+      {
+        version_and_exit();
+      }
+      elsif( $opt eq "text" )
+      {
+        # ignore
+      }
+      elsif( $opt eq "binary" )
+      {
+        $binary_mode = "*";
+      }
+      elsif( $opt eq "check" )
+      {
+        $check_mode = 1;
+      }
+      elsif( $opt eq "status" )
+      {
+        $quiet = 1;
+      }
+      elsif( $opt eq "warn" )
+      {
+        $warn = 1;
+      }
+      elsif( $opt eq "" )
+      {
+        $no_opts = 1;
+      }
+      else
+      {
+        print STDERR <<"HELPMSG";
+$0: unrecognised option `--$opt'
+Try `$0 --help' for more information.
+HELPMSG
+        exit;
+      }
+    }
+    elsif( !$no_opts and /^-(.+)$/ )
+    {
+      my @opts = split //, $1;
+      for(@opts) {
+        if( $_ eq "t" )
+        {
+          # ignore
+        }
+        elsif( $_ eq "b" )
+        {
+          $binary_mode = "*";
+        }
+        elsif( $_ eq "c" )
+        {
+          $check_mode = 1;
+        }
+        elsif( $_ eq "w" )
+        {
+          $warn = 1;
+        }
+        elsif( $_ eq "" )
+        {
+          # - here is just STDIN
+          push @files, '-';
+        }
+        else
+        {
+          print STDERR <<"ERRORMSG";
+$0: invalid option -- $_
+Try `md5sum --help' for more information.
+ERRORMSG
+          exit;
+        }
+      }
+    }
+    else
+    {
+      push @files, $_;
+    }
+  }
+}
+
+sub checksum_for
+{
+  my ($file) = @_;
+  my $sum;
+  if( $file eq "-" )
+  {
+    # read from stdin
+    $sum = `$md5_bin -p`;
+    1 while(chomp $sum);
+    # take only the last line, that's the checksum
+    $sum = (split /\n/, $sum)[-1];
+    return $sum;
+  }
+
+  # try to open the file to get the system error ourselves
+  eval {
+    open my $f, $file or die "$!\n";
+    close $f;
+  };
+  if( $@ ) {
+    print STDERR "$0: $file: $@";
+    $return = 1;
+    return "";
+  }
+
+  $sum = `$md5_bin -q "$file"`;
+  1 while(chomp $sum);
+  return $sum;
+}
+
+sub run_check_mode
+{
+  my @files = @_;
+  my $read_stdin = 0;
+  my $f;
+
+  for my $md5file( @files )
+  {
+    eval { open $f, $md5file or die $! };
+    if( $@ )
+    {
+      print STDERR "$0: $md5file: $@\n";
+      next;
+    }
+
+    my $lines = 0;
+    my $actual_lines = 0;
+    my $valid = 0;
+    my $errors = 0;
+    while(<$f>) {
+      my $line = $_;
+      $actual_lines++;
+
+      # check this line
+      my ($sum, $file) = $line =~ /^([0-9a-fA-F]{32}) (?: |\*)(.+)$/;
+      if( !defined($sum) || !defined($file)) {
+        if( $warn && $line !~ /^#/ )
+        {
+          warn "$0: $md5file: $actual_lines: improperly formatted MD5 checksum line\n";
+        }
+        next;
+      }
+
+      $lines++;
+      my $checksum = checksum_for($file);
+      if( !$checksum )
+      {
+        if( !$quiet )
+        {
+          print "$file: FAILED open or read\n";
+        }
+        $errors++;
+      }
+      elsif( lc($checksum) eq lc($sum) )
+      {
+        if( !$quiet )
+        {
+          print "$file: OK\n";
+        }
+        $valid++;
+      }
+      else
+      {
+        $return = 1;
+        if( !$quiet )
+        {
+          print "$file: FAILED\n";
+        }
+      }
+    }
+
+    close $f;
+    if( $lines == 0 )
+    {
+      warn "$0: $md5file: no properly formatted MD5 checksum lines found\n";
+      $return = 1;
+    }
+    if( $errors > 0 )
+    {
+      my $s = $lines == 1 ? "" : "s";
+      if( !$quiet )
+      {
+        warn "$0: WARNING: $errors of $lines listed file$s could not be read\n";
+      }
+    }
+    if( $valid < ($lines-$errors) )
+    {
+      my $checksums = $lines - $errors;
+      my $nomatch = $checksums - $valid;
+      if( !$quiet )
+      {
+        warn "$0: WARNING: $nomatch of $checksums computed checksums did NOT match\n";
+      }
+    }
+  }
+}
diff -ruN dpkg-1.17.6.orig/fink/origins dpkg-1.17.6/fink/origins
--- dpkg-1.17.6.orig/fink/origins	1969-12-31 17:00:00.000000000 -0700
+++ dpkg-1.17.6/fink/origins	2012-07-02 16:14:45.000000000 -0600
@@ -0,0 +1,3 @@
+Vendor: Fink
+Vendor-URL: http://fink.sourceforge.net/
+Bugs: http://fink.sourceforge.net/
diff -ruN dpkg-1.17.6.orig/fink/patches/add-BOD.patch dpkg-1.17.6/fink/patches/add-BOD.patch
--- dpkg-1.17.6.orig/fink/patches/add-BOD.patch	1969-12-31 17:00:00.000000000 -0700
+++ dpkg-1.17.6/fink/patches/add-BOD.patch	2014-02-08 09:41:22.000000000 -0700
@@ -0,0 +1,10 @@
+--- dpkg-1.17.6.orig/dpkg-deb/build.c
++++ dpkg-1.17.6/dpkg-deb/build.c
+@@ -341,6 +341,7 @@
+   "Installer-Menu-Item",
+   "Homepage",
+   "Tag",
++  "BuildDependsOnly",
+   NULL
+ };
+ 
diff -ruN dpkg-1.17.6.orig/fink/patches/add-install-info.patch dpkg-1.17.6/fink/patches/add-install-info.patch
--- dpkg-1.17.6.orig/fink/patches/add-install-info.patch	1969-12-31 17:00:00.000000000 -0700
+++ dpkg-1.17.6/fink/patches/add-install-info.patch	2014-02-07 08:45:05.000000000 -0700
@@ -0,0 +1,186 @@
+--- dpkg-1.17.6/utils.orig/Makefile.am
++++ dpkg-1.17.6/utils/Makefile.am
+@@ -41,6 +41,16 @@
+ 	$(SSD_LIBS)
+ endif
+ 
++sbin_PROGRAMS += dpkg-install-info
++
++# Automake has its own install-info rule, gah
++dpkg_install_info_SOURCES = install-info.c
++
++dpkg_install_info_LDADD = \
++	../lib/compat/libcompat.a
++
++transform = s/dpkg-install-info/install-info/; $(program_transform_name)
++
+ install-data-local:
+ if BUILD_UPDATE_ALTERNATIVES
+ 	$(MKDIR_P) $(DESTDIR)$(sysconfdir)/alternatives
+@@ -50,6 +60,7 @@
+ 
+ uninstall-local:
+ 	rm -f $(DESTDIR)$(sysconfdir)/alternatives/README
++	rm -f $(DESTDIR)$(sbindir)/install-info
+ 
+ TEST_ENV_VARS = DPKG_DATADIR=$(top_srcdir)
+ 
+--- dpkg-1.17.6/utils.orig/Makefile.in
++++ dpkg-1.17.6/utils/Makefile.in
+@@ -78,7 +78,6 @@
+ install_sh_PROGRAM = $(install_sh) -c
+ install_sh_SCRIPT = $(install_sh) -c
+ INSTALL_HEADER = $(INSTALL_DATA)
+-transform = $(program_transform_name)
+ NORMAL_INSTALL = :
+ PRE_INSTALL = :
+ POST_INSTALL = :
+@@ -89,7 +88,7 @@
+ host_triplet = @host@
+ bin_PROGRAMS = $(am__EXEEXT_1)
+ @BUILD_UPDATE_ALTERNATIVES_TRUE@am__append_1 = update-alternatives
+-sbin_PROGRAMS = $(am__EXEEXT_2)
++sbin_PROGRAMS = $(am__EXEEXT_2) dpkg-install-info$(EXEEXT)
+ @BUILD_START_STOP_DAEMON_TRUE@am__append_2 = start-stop-daemon
+ DIST_COMMON = $(top_srcdir)/Makecheck.am $(srcdir)/Makefile.in \
+ 	$(srcdir)/Makefile.am $(top_srcdir)/build-aux/depcomp
+@@ -120,6 +119,9 @@
+ @BUILD_START_STOP_DAEMON_TRUE@am__EXEEXT_2 =  \
+ @BUILD_START_STOP_DAEMON_TRUE@	start-stop-daemon$(EXEEXT)
+ PROGRAMS = $(bin_PROGRAMS) $(sbin_PROGRAMS)
++am_dpkg_install_info_OBJECTS = install-info.$(OBJEXT)
++dpkg_install_info_OBJECTS = $(am_dpkg_install_info_OBJECTS)
++dpkg_install_info_DEPENDENCIES = ../lib/compat/libcompat.a
+ am__start_stop_daemon_SOURCES_DIST = start-stop-daemon.c
+ @BUILD_START_STOP_DAEMON_TRUE@am_start_stop_daemon_OBJECTS =  \
+ @BUILD_START_STOP_DAEMON_TRUE@	start-stop-daemon.$(OBJEXT)
+@@ -160,8 +162,10 @@
+ am__v_CCLD_ = $(am__v_CCLD_@AM_DEFAULT_V@)
+ am__v_CCLD_0 = @echo "  CCLD    " $@;
+ am__v_CCLD_1 = 
+-SOURCES = $(start_stop_daemon_SOURCES) $(update_alternatives_SOURCES)
+-DIST_SOURCES = $(am__start_stop_daemon_SOURCES_DIST) \
++SOURCES = $(dpkg_install_info_SOURCES) $(start_stop_daemon_SOURCES) \
++	$(update_alternatives_SOURCES)
++DIST_SOURCES = $(dpkg_install_info_SOURCES) \
++	$(am__start_stop_daemon_SOURCES_DIST) \
+ 	$(update_alternatives_SOURCES)
+ am__can_run_installinfo = \
+   case $$AM_UPDATE_INFO_DIR in \
+@@ -188,6 +192,7 @@
+ ETAGS = etags
+ CTAGS = ctags
+ DISTFILES = $(DIST_COMMON) $(DIST_SOURCES) $(TEXINFOS) $(EXTRA_DIST)
++transform = s/dpkg-install-info/install-info/; $(program_transform_name)
+ ACLOCAL = @ACLOCAL@
+ AMTAR = @AMTAR@
+ AM_DEFAULT_VERBOSITY = @AM_DEFAULT_VERBOSITY@
+@@ -361,6 +366,12 @@
+ @BUILD_START_STOP_DAEMON_TRUE@	../lib/compat/libcompat.a \
+ @BUILD_START_STOP_DAEMON_TRUE@	$(SSD_LIBS)
+ 
++
++# Automake has its own install-info rule, gah
++dpkg_install_info_SOURCES = install-info.c
++dpkg_install_info_LDADD = \
++	../lib/compat/libcompat.a
++
+ TEST_ENV_VARS = DPKG_DATADIR=$(top_srcdir)
+ test_tmpdir = t.tmp
+ test_cases = \
+@@ -486,6 +497,10 @@
+ clean-sbinPROGRAMS:
+ 	-test -z "$(sbin_PROGRAMS)" || rm -f $(sbin_PROGRAMS)
+ 
++dpkg-install-info$(EXEEXT): $(dpkg_install_info_OBJECTS) $(dpkg_install_info_DEPENDENCIES) $(EXTRA_dpkg_install_info_DEPENDENCIES) 
++	@rm -f dpkg-install-info$(EXEEXT)
++	$(AM_V_CCLD)$(LINK) $(dpkg_install_info_OBJECTS) $(dpkg_install_info_LDADD) $(LIBS)
++
+ start-stop-daemon$(EXEEXT): $(start_stop_daemon_OBJECTS) $(start_stop_daemon_DEPENDENCIES) $(EXTRA_start_stop_daemon_DEPENDENCIES) 
+ 	@rm -f start-stop-daemon$(EXEEXT)
+ 	$(AM_V_CCLD)$(LINK) $(start_stop_daemon_OBJECTS) $(start_stop_daemon_LDADD) $(LIBS)
+@@ -500,6 +515,7 @@
+ distclean-compile:
+ 	-rm -f *.tab.c
+ 
++@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/install-info.Po@am__quote@
+ @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/start-stop-daemon.Po@am__quote@
+ @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/update-alternatives.Po@am__quote@
+ 
+@@ -734,6 +750,7 @@
+ 
+ uninstall-local:
+ 	rm -f $(DESTDIR)$(sysconfdir)/alternatives/README
++	rm -f $(DESTDIR)$(sbindir)/install-info
+ 
+ TEST_VERBOSE ?= 0
+ 
+--- dpkg-1.17.6/utils.orig/install-info.c
++++ dpkg-1.17.6/utils/install-info.c
+@@ -0,0 +1,66 @@
++/*
++ * install-info.c - transitional ginstall-info wrapper
++ *
++ * Copyright © 2009 Raphaël Hertzog <hertzog@debian.org>
++ *
++ * This is free software; you can redistribute it and/or modify
++ * it under the terms of the GNU General Public License as published by
++ * the Free Software Foundation; either version 2 of the License, or
++ * (at your option) any later version.
++ *
++ * This is distributed in the hope that it will be useful,
++ * but WITHOUT ANY WARRANTY; without even the implied warranty of
++ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
++ * GNU General Public License for more details.
++ *
++ * You should have received a copy of the GNU General Public License
++ * along with this program.  If not, see <http://www.gnu.org/licenses/>.
++ */
++
++#include <config.h>
++#include <compat.h>
++
++#include <errno.h>
++#include <string.h>
++#include <unistd.h>
++#include <stdlib.h>
++#include <stdio.h>
++
++#define SELF "@FINKPREFIX@/sbin/install-info"
++#define WRAPPED "@FINKPREFIX@/bin/install-info"
++
++#define warn(...) fprintf(stderr, "install-info: warning: " __VA_ARGS__)
++#define error(...) fprintf(stderr, "install-info: error: " __VA_ARGS__)
++
++int
++main(int argc, char **argv)
++{
++    if (strcmp(argv[0], SELF) == 0) {
++	warn("don't call programs like install-info with an absolute path,\n");
++	warn("%s provided by dpkg is deprecated and will go away soon;\n",
++	     SELF);
++	warn("its replacement lives in @FINKPREFIX@/bin/.\n");
++    }
++
++	execv(WRAPPED, argv);
++	if (errno == ENOENT) {
++	    if (getenv("DPKG_RUNNING_VERSION") != NULL) {
++		const char *pkg;
++
++		pkg = getenv("DPKG_MAINTSCRIPT_PACKAGE");
++
++		warn("maintainer scripts should not call install-info anymore,\n");
++		warn("this is handled now by a dpkg trigger provided by the\n");
++		warn("install-info package; package %s should be updated.\n",
++		     pkg);
++	    } else {
++		warn("nothing done since %s doesn't exist,\n", WRAPPED);
++		warn("you might want to install an info-browser package.\n");
++	    }
++	} else {
++	    error("can't execute %s: %s\n", WRAPPED, strerror(errno));
++	    return 1;
++	}
++
++    return 0;
++}
diff -ruN dpkg-1.17.6.orig/fink/patches/bsdutils.patch dpkg-1.17.6/fink/patches/bsdutils.patch
--- dpkg-1.17.6.orig/fink/patches/bsdutils.patch	1969-12-31 17:00:00.000000000 -0700
+++ dpkg-1.17.6/fink/patches/bsdutils.patch	2014-03-05 14:49:09.000000000 -0700
@@ -0,0 +1,24 @@
+--- dpkg-1.16.4.3.orig/scripts/dpkg-genchanges.pl	2014-01-14 11:39:12.000000000 -0700
++++ dpkg-1.16.4.3/scripts/dpkg-genchanges.pl	2014-03-05 14:46:01.000000000 -0700
+@@ -466,8 +466,8 @@
+ $fields->{'Format'} = $substvars->get('Format');
+ 
+ if (!defined($fields->{'Date'})) {
+-    chomp(my $date822 = `date -R`);
+-    subprocerr('date -R') if $?;
++    chomp(my $date822 = `date +"%%a, %%d %%b %%Y %%H:%%M:%%S %%z"`);
++    subprocerr('date +"%%a, %%d %%b %%Y %%H:%%M:%%S %%z"') if $?;
+     $fields->{'Date'}= $date822;
+ }
+ 
+--- dpkg-1.16.4.3.orig/scripts/dpkg-gencontrol.pl	2014-01-15 07:02:16.000000000 -0700
++++ dpkg-1.16.4.3/scripts/dpkg-gencontrol.pl	2014-03-05 14:48:17.000000000 -0700
+@@ -340,7 +340,7 @@
+     if (!$c) {
+         chdir("$packagebuilddir")
+             or syserr(_g("chdir for du to \`%s'"), $packagebuilddir);
+-        exec('du', '-k', '-s', '--apparent-size', '.')
++        exec('du', '-k', '-s', '.')
+             or syserr(_g('unable to execute %s'), 'du');
+     }
+     my $duo = '';
diff -ruN dpkg-1.17.6.orig/fink/patches/build-fix.patch dpkg-1.17.6/fink/patches/build-fix.patch
--- dpkg-1.17.6.orig/fink/patches/build-fix.patch	1969-12-31 17:00:00.000000000 -0700
+++ dpkg-1.17.6/fink/patches/build-fix.patch	2014-02-10 14:15:40.000000000 -0700
@@ -0,0 +1,107 @@
+diff -ruN dpkg-1.16.4.3.orig/dselect/Makefile.am dpkg-1.16.4.3/dselect/Makefile.am
+--- dpkg-1.16.4.3.orig/dselect/Makefile.am	2012-06-13 23:12:30.000000000 -0600
++++ dpkg-1.16.4.3/dselect/Makefile.am	2012-07-02 16:14:45.000000000 -0600
+@@ -8,7 +8,7 @@
+ AM_CPPFLAGS = \
+ 	-DLOCALEDIR=\"$(localedir)\" \
+ 	-DADMINDIR=\"$(admindir)\" -DLIBDIR=\"$(pkglibdir)\" \
+-	-DLOCALLIBDIR=\"/usr/local/lib/dpkg\" \
++	-DLOCALLIBDIR=\"@FINKPREFIX@/lib/dpkg\" \
+ 	-idirafter $(top_srcdir)/lib/compat \
+ 	-iquote $(builddir) \
+ 	-I$(top_builddir) \
+diff -ruN dpkg-1.16.4.3.orig/dselect/Makefile.in dpkg-1.16.4.3/dselect/Makefile.in
+--- dpkg-1.16.4.3.orig/dselect/Makefile.in	2012-06-17 02:57:19.000000000 -0600
++++ dpkg-1.16.4.3/dselect/Makefile.in	2012-07-02 16:14:45.000000000 -0600
+@@ -374,7 +374,7 @@
+ AM_CPPFLAGS = \
+ 	-DLOCALEDIR=\"$(localedir)\" \
+ 	-DADMINDIR=\"$(admindir)\" -DLIBDIR=\"$(pkglibdir)\" \
+-	-DLOCALLIBDIR=\"/usr/local/lib/dpkg\" \
++	-DLOCALLIBDIR=\"@FINKPREFIX@/local/lib/dpkg\" \
+ 	-idirafter $(top_srcdir)/lib/compat \
+ 	-iquote $(builddir) \
+ 	-I$(top_builddir) \
+diff -ruN dpkg-1.16.4.3.orig/lib/dpkg/subproc.c dpkg-1.16.4.3/lib/dpkg/subproc.c
+--- dpkg-1.16.4.3.orig/lib/dpkg/subproc.c	2012-06-13 23:12:31.000000000 -0600
++++ dpkg-1.16.4.3/lib/dpkg/subproc.c	2012-07-02 16:14:45.000000000 -0600
+@@ -104,7 +104,9 @@
+ 	void (*out)(const char *fmt, ...) DPKG_ATTR_PRINTF(1);
+ 	int n;
+ 
+-	if (flags & PROCWARN)
++    /* FINK LOCAL: Tar status 1 is a warning. */
++	if ((flags & PROCWARN) || (n == 1 && strncmp(desc, "tar", 3) == 0))
++    /* FINK LOCAL */
+ 		out = warning;
+ 	else
+ 		out = ohshit;
+diff -ruN dpkg-1.16.4.3.orig/src/filesdb.c dpkg-1.16.4.3/src/filesdb.c
+--- dpkg-1.16.4.3.orig/src/filesdb.c	2012-06-13 23:12:34.000000000 -0600
++++ dpkg-1.16.4.3/src/filesdb.c	2012-07-02 16:14:45.000000000 -0600
+@@ -34,6 +34,9 @@
+ #include <assert.h>
+ #include <errno.h>
+ #include <string.h>
++#if defined(__APPLE__) && defined(__MACH__)
++	#include <ctype.h>
++#endif
+ #include <pwd.h>
+ #include <grp.h>
+ #include <fcntl.h>
+@@ -577,7 +580,7 @@
+ 
+ static int hash(const char *name) {
+   int v= 0;
+-  while (*name) { v *= 1787; v += *name; name++; }
++  while (*name) { v *= 1787; v += tolower(*name); name++; }
+   return v;
+ }
+ 
+@@ -593,7 +596,7 @@
+   while (*pointerp) {
+     /* XXX: Why is the assert needed? It's checking already added entries. */
+     assert((*pointerp)->name[0] == '/');
+-    if (strcmp((*pointerp)->name + 1, name) == 0)
++    if (strcasecmp((*pointerp)->name + 1, name) == 0)
+       break;
+     pointerp= &(*pointerp)->next;
+   }
+diff -ruN dpkg-1.16.4.3.orig/src/help.c dpkg-1.16.4.3/src/help.c
+--- dpkg-1.16.4.3.orig/src/help.c	2012-06-13 23:12:34.000000000 -0600
++++ dpkg-1.16.4.3/src/help.c	2012-07-02 16:14:45.000000000 -0600
+@@ -40,6 +40,19 @@
+ #include "filesdb.h"
+ #include "main.h"
+ 
++/* FINK LOCAL start */
++// SystemB setenv() crashes when value == 0, but this occasionally happens
++// in dpkg.
++int _setenv(const char *name, const char *value, int overwrite) {
++  if(name == 0 || value == 0) {
++    return 0;
++  }
++  return setenv(name, value, overwrite);
++}
++#undef setenv
++#define setenv _setenv
++/* FINK LOCAL end */
++
+ const char *const statusstrings[]= {
+   [stat_notinstalled]    = N_("not installed"),
+   [stat_configfiles]     = N_("not installed but configs remain"),
+@@ -116,6 +129,14 @@
+     const char *path, *path_end;
+     size_t path_len;
+ 
++    /* FINK LOCAL start */
++    if (strncmp(prog[0],"/",1)==0 && stat(*prog, &stab) == 0)
++    {
++      // prog is an absolute path which exists, accept it
++      break;
++    }
++    /* FINK LOCAL end */
++
+     for (path = path_list; path; path = path_end ? path_end + 1 : NULL) {
+       path_end = strchr(path, ':');
+       path_len = path_end ? (size_t)(path_end - path) : strlen(path);
diff -ruN dpkg-1.17.6.orig/fink/patches/c++filt-defaults.patch dpkg-1.17.6/fink/patches/c++filt-defaults.patch
--- dpkg-1.17.6.orig/fink/patches/c++filt-defaults.patch	1969-12-31 17:00:00.000000000 -0700
+++ dpkg-1.17.6/fink/patches/c++filt-defaults.patch	2013-12-23 09:32:49.000000000 -0700
@@ -0,0 +1,12 @@
+diff -ruN dpkg-1.16.4.3.orig/scripts/Dpkg/Shlibs/Cppfilt.pm dpkg-1.16.4.3/scripts/Dpkg/Shlibs/Cppfilt.pm
+--- dpkg-1.16.4.3.orig/scripts/Dpkg/Shlibs/Cppfilt.pm	2012-06-09 08:32:08.000000000 -0600
++++ dpkg-1.16.4.3/scripts/Dpkg/Shlibs/Cppfilt.pm	2012-07-02 16:14:45.000000000 -0600
+@@ -44,7 +44,7 @@
+     } else {
+ 	$filt = { from => undef, to => undef,
+ 	            last_symbol => '', last_result => '' };
+-	$filt->{pid} = spawn(exec => [ 'c++filt', "--format=$type" ],
++	$filt->{pid} = spawn(exec => [ 'c++filt', "--no-strip-underscore", "--format=$type" ],
+ 	                     from_pipe => \$filt->{from},
+ 	                     to_pipe => \$filt->{to});
+ 	syserr(_g('unable to execute %s'), 'c++filt')
diff -ruN dpkg-1.17.6.orig/fink/patches/coreutils.patch dpkg-1.17.6/fink/patches/coreutils.patch
--- dpkg-1.17.6.orig/fink/patches/coreutils.patch	1969-12-31 17:00:00.000000000 -0700
+++ dpkg-1.17.6/fink/patches/coreutils.patch	2014-03-05 14:45:28.000000000 -0700
@@ -0,0 +1,21 @@
+--- dpkg-1.16.4.3.orig/scripts/Dpkg/Checksums.pm	2014-03-05 14:41:33.000000000 -0700
++++ dpkg-1.16.4.3.orig/scripts/Dpkg/Checksums.pm	2014-03-05 14:41:50.000000000 -0700
+@@ -51,15 +51,15 @@
+ 
+ my $CHECKSUMS = {
+     md5 => {
+-	program => [ 'md5sum' ],
++	program => [ 'gmd5sum' ],
+ 	regex => qr/[0-9a-f]{32}/,
+     },
+     sha1 => {
+-	program => [ 'sha1sum' ],
++	program => [ 'gsha1sum' ],
+ 	regex => qr/[0-9a-f]{40}/,
+     },
+     sha256 => {
+-	program => [ 'sha256sum' ],
++	program => [ 'gsha256sum' ],
+ 	regex => qr/[0-9a-f]{64}/,
+     },
+ };
diff -ruN dpkg-1.17.6.orig/fink/patches/dselect-methods.patch dpkg-1.17.6/fink/patches/dselect-methods.patch
--- dpkg-1.17.6.orig/fink/patches/dselect-methods.patch	1969-12-31 17:00:00.000000000 -0700
+++ dpkg-1.17.6/fink/patches/dselect-methods.patch	2013-12-23 09:40:31.000000000 -0700
@@ -0,0 +1,57 @@
+diff -ruN dpkg-1.16.4.3.orig/dselect/methods/Dselect/Ftp.pm dpkg-1.16.4.3/dselect/methods/Debian/Dselect/Ftp.pm
+--- dpkg-1.16.4.3.orig/dselect/methods/Dselect/Ftp.pm	2012-06-13 23:12:30.000000000 -0600
++++ dpkg-1.16.4.3/dselect/methods/Dselect/Ftp.pm	2012-07-02 16:14:45.000000000 -0600
+@@ -79,12 +79,12 @@
+ }
+ 
+ sub view_mirrors {
+-  if (-f '/usr/lib/dpkg/methods/ftp/README.mirrors.txt') {
+-    system('pager', '/usr/lib/dpkg/methods/ftp/README.mirrors.txt');
+-  } elsif (-f '/usr/lib/dpkg/methods/ftp/README.mirrors.txt.gz') {
+-    system('gzip -dc /usr/lib/dpkg/methods/ftp/README.mirrors.txt.gz | pager');
++  if (-f '@FINKPREFIX@/lib/dpkg/methods/ftp/README.mirrors.txt') {
++    system('less', '@FINKPREFIX@/lib/dpkg/methods/ftp/README.mirrors.txt');
++  } elsif (-f '@FINKPREFIX@/lib/dpkg/methods/ftp/README.mirrors.txt.gz') {
++    system('gzip -dc @FINKPREFIX@/lib/dpkg/methods/ftp/README.mirrors.txt.gz | pager');
+   } else {
+-    print "/usr/lib/dpkg/methods/ftp/README.mirrors.txt(.gz): file not found.\n";
++    print "@FINKPREFIX@/lib/dpkg/methods/ftp/README.mirrors.txt(.gz): file not found.\n";
+   }
+ }
+ 
+diff -ruN dpkg-1.16.4.3.orig/dselect/methods/disk/setup dpkg-1.16.4.3/dselect/methods/disk/setup
+--- dpkg-1.16.4.3.orig/dselect/methods/disk/setup	2012-06-13 23:12:30.000000000 -0600
++++ dpkg-1.16.4.3/dselect/methods/disk/setup	2012-07-02 16:14:45.000000000 -0600
+@@ -19,7 +19,7 @@
+ option=$3
+ 
+ cd "$vardir/methods/disk"
+-tp=/var/run/ddm$$
++tp=@FINKPREFIX@/var/run/ddm$$
+ 
+ iarch=`dpkg --admindir $vardir --print-architecture`
+ 
+diff -ruN dpkg-1.16.4.3.orig/dselect/methods/ftp/setup dpkg-1.16.4.3/dselect/methods/ftp/setup
+--- dpkg-1.16.4.3.orig/dselect/methods/ftp/setup	2012-06-09 08:32:06.000000000 -0600
++++ dpkg-1.16.4.3/dselect/methods/ftp/setup	2012-07-02 16:14:45.000000000 -0600
+@@ -75,7 +75,7 @@
+ You must supply an ftp site, use of passive mode, username, password,
+ path to the debian directory,list of distributions you are interested
+ in and place to download the binary package files to (relative to
+-/var/lib/dpkg/methods/ftp). You can add as much sites as you like. Later
++@FINKPREFIX@/var/lib/dpkg/methods/ftp). You can add as much sites as you like. Later
+ entries will always override older ones.
+ 
+ Supply "?" as a password to be asked each time you connect.
+diff -ruN dpkg-1.16.4.3.orig/dselect/methods/multicd/install dpkg-1.16.4.3/dselect/methods/multicd/install
+--- dpkg-1.16.4.3.orig/dselect/methods/multicd/install	2012-06-13 23:12:30.000000000 -0600
++++ dpkg-1.16.4.3/dselect/methods/multicd/install	2012-07-02 16:14:45.000000000 -0600
+@@ -175,7 +175,7 @@
+ Perhaps you downloaded it with an unexpected name, or something.
+ In any case, you must find the file(s) and then either place it with
+ the correct filename(s) (as listed in the Packages.cd file or in
+-/var/lib/dpkg/available) and rerun the installation, or upgrade the
++@FINKPREFIX@/var/lib/dpkg/available) and rerun the installation, or upgrade the
+ package by using `dpkg --install --auto-deconfigure'\'' by hand.
+ 
+ ";
diff -ruN dpkg-1.17.6.orig/fink/patches/extra-env.patch dpkg-1.17.6/fink/patches/extra-env.patch
--- dpkg-1.17.6.orig/fink/patches/extra-env.patch	1969-12-31 17:00:00.000000000 -0700
+++ dpkg-1.17.6/fink/patches/extra-env.patch	2014-03-13 10:04:46.000000000 -0600
@@ -0,0 +1,184 @@
+--- dpkg-1.17.6.orig/configure
++++ dpkg-1.17.6/configure
+@@ -819,6 +819,7 @@
+ enable_dselect
+ enable_start_stop_daemon
+ enable_update_alternatives
++with_dpkg_env_script
+ with_pkgconfdir
+ with_admindir
+ with_logdir
+@@ -1508,6 +1509,8 @@
+   --without-libiconv-prefix     don't search for libiconv in includedir and libdir
+   --with-libintl-prefix[=DIR]  search for libintl in DIR/include and DIR/lib
+   --without-libintl-prefix     don't search for libintl in includedir and libdir
++  --with-dpkg-env-script=PATH/TO/SCRIPT
++                          script to include in the maintainer environment
+   --with-pkgconfdir=DIR   dpkg configuration directory [SYSCONFDIR/dpkg]
+   --with-admindir=DIR     dpkg database directory [LOCALSTATEDIR/lib/dpkg]
+   --with-logdir=DIR       system logging directory [LOCALSTATEDIR/log]
+@@ -7047,6 +7050,36 @@
+ $as_echo "$build_update_alternatives" >&6; }
+ 
+ 
++# Check if we want to run a script to set extra env vars
++
++  { $as_echo "$as_me:${as_lineno-$LINENO}: checking for maintainer environment script" >&5
++$as_echo_n "checking for maintainer environment script... " >&6; }
++
++# Check whether --with-dpkg-env-script was given.
++if test "${with_dpkg_env_script+set}" = set; then :
++  withval=$with_dpkg_env_script; with_dpkg_deb_script=$withval
++else
++  with_dpkg_deb_script=no
++fi
++
++  if test "x$with_dpkg_env_script" != "xno"; then :
++
++
++cat >>confdefs.h <<_ACEOF
++#define DPKG_MAINT_ENV_SCRIPT "$with_dpkg_env_script"
++_ACEOF
++
++
++else
++
++    $as_echo "#define DPKG_MAINT_ENV_SCRIPT 0" >>confdefs.h
++
++
++fi
++  { $as_echo "$as_me:${as_lineno-$LINENO}: result: $with_dpkg_env_script" >&5
++$as_echo "$with_dpkg_env_script" >&6; }
++
++
+ # Allow alternate directories
+ 
+   pkgconfdir="${sysconfdir}/${PACKAGE_NAME}"
+--- dpkg-1.17.6.orig/configure.ac
++++ dpkg-1.17.6/configure.ac 
+@@ -23,6 +23,9 @@
+ DPKG_BUILD_PROG([start-stop-daemon])
+ DPKG_BUILD_PROG([update-alternatives])
+ 
++# Check if we want to run a script to set extra env vars
++DPKG_ENV_SCRIPT([no])
++
+ # Allow alternate directories
+ DPKG_WITH_DIR([pkgconfdir], [${sysconfdir}/${PACKAGE_NAME}],
+               [dpkg configuration directory [SYSCONFDIR/dpkg]])
+--- dpkg-1.17.6.orig/m4/dpkg-build.m4
++++ dpkg-1.17.6/m4/dpkg-build.m4
+@@ -52,6 +52,23 @@
+   AC_MSG_NOTICE([using default dpkg-deb compressor = $with_dpkg_deb_compressor])
+ ]) # DPKG_DEB_COMPRESSOR
+ 
++# DPKG_ENV_SCRIPT(SCRIPT)
++# -------------------
++# Add script to the maintainer script env.
++AC_DEFUN([DPKG_ENV_SCRIPT], [
++  AC_MSG_CHECKING([for maintainer environment script])
++  AC_ARG_WITH([dpkg-env-script],
++    [AS_HELP_STRING([--with-dpkg-env-script=PATH/TO/SCRIPT],
++                   [script to include in the maintainer environment])],
++    [with_dpkg_deb_script=$withval], [with_dpkg_deb_script=$1])
++  AS_IF([test "x$with_dpkg_env_script" != "xno"], [
++    AC_DEFINE_UNQUOTED([DPKG_MAINT_ENV_SCRIPT], ["$with_dpkg_env_script"], [Define to value if not no.])
++  ], [
++    AC_DEFINE([DPKG_MAINT_ENV_SCRIPT], [0])
++  ])
++  AC_MSG_RESULT([$with_dpkg_env_script])
++]) # DPKG_ENV_SCRIPT
++
+ # DPKG_DIST_CHECK(COND, ERROR)
+ # ---------------
+ # Check if the condition is fulfilled when preparing a distribution tarball.
+--- dpkg-1.17.6.orig/src/main.h
++++ dpkg-1.17.6/src/main.h
+@@ -242,6 +242,9 @@
+                          const char *scriptname, const char *desc,
+                          const char *cidir, char *cidirrest,
+                          const char *ifok, const char *iffallback);
++#ifdef DPKG_MAINT_ENV_SCRIPT
++int execute_env_script();
++#endif
+ 
+ /* Callers wanting to run the postinst use these two as they want to postpone
+  * trigger incorporation until after updating the package status. The effect
+--- dpkg-1.17.6.orig/src/script.c
++++ dpkg-1.17.6/src/script.c
+@@ -217,6 +217,11 @@
+ 		    setenv("DPKG_RUNNING_VERSION", PACKAGE_VERSION, 1))
+ 			ohshite(_("unable to setenv for maintainer script"));
+ 
++#ifdef DPKG_MAINT_ENV_SCRIPT
++		if (execute_env_script())
++			ohshite(_("unable to set extra env for maintainer script"));
++#endif
++
+ 		cmd->filename = cmd->argv[0] = maintscript_pre_exec(cmd);
+ 
+ 		if (maintscript_set_exec_context(cmd, "dpkg_script_t") < 0)
+@@ -403,3 +408,63 @@
+ 
+ 	return 1;
+ }
++
++#ifdef DPKG_MAINT_ENV_SCRIPT
++// Need limits.h for POSIX_ARG_MAX
++#include <limits.h>
++
++int execute_env_script(void);
++
++int
++execute_env_script() {
++	debug(dbg_scripts, "Injecting env script (%s)", DPKG_MAINT_ENV_SCRIPT);
++
++	struct stat sb;
++	// is this the right max len?
++	char buf[_POSIX_ARG_MAX];
++
++	if (!stat(DPKG_MAINT_ENV_SCRIPT, &sb)) {
++		char cmd_full[sizeof(DPKG_MAINT_ENV_SCRIPT) + 16];
++		sprintf(cmd_full, ". %s; /usr/bin/env", DPKG_MAINT_ENV_SCRIPT);
++
++		FILE *cmd_stream;
++
++		cmd_stream = popen(cmd_full, "r");
++		if (cmd_stream) {
++			debug(dbg_veryverbose, " -> reading %s env results...", DPKG_MAINT_ENV_SCRIPT);
++			while (fgets(buf, _POSIX_ARG_MAX, cmd_stream)) {
++				if (!strcmp(buf+strlen(buf)-1, "\n")) {
++					// chomp trailing newline
++					buf[strlen(buf)-1]=0;
++				}
++				// putenv owns actual passed char*
++				debug(dbg_veryverbose, " -> adding to ENV '%s'", strdup(buf));
++				putenv(strdup(buf));
++			}
++			pclose(cmd_stream);
++
++			return 0;
++		} else {
++			debug(dbg_scripts, "popen(%s) failed.", DPKG_MAINT_ENV_SCRIPT);
++		}
++	} else {
++		debug(dbg_scripts, "%s not found.", DPKG_MAINT_ENV_SCRIPT);
++	}
++
++	debug(dbg_scripts, "fallback: just prepend fink to PATH");
++	{
++		char *path;
++
++		path = getenv("PATH");
++		if (path) {
++			sprintf(buf, "PATH=%s:%s:%s", "@FINKPREFIX@/bin", "@FINKPREFIX@/sbin", path);
++			putenv(strdup(buf));
++
++			return 0;
++		}
++		debug(dbg_scripts, "could not read PATH from ENV!");
++	}
++
++	return 1;
++}
++#endif
diff -ruN dpkg-1.17.6.orig/fink/patches/fink-as-vendor.patch dpkg-1.17.6/fink/patches/fink-as-vendor.patch
--- dpkg-1.17.6.orig/fink/patches/fink-as-vendor.patch	1969-12-31 17:00:00.000000000 -0700
+++ dpkg-1.17.6/fink/patches/fink-as-vendor.patch	2012-07-31 15:46:48.000000000 -0600
@@ -0,0 +1,101 @@
+--- a/scripts/Dpkg/Vendor/Fink.pm	2012-07-31 15:29:11.000000000 -0600
++++ b/scripts/Dpkg/Vendor/Fink.pm	2012-07-31 14:57:25.000000000 -0600
+@@ -0,0 +1,98 @@
++# Copyright © 2009-2011 Raphaël Hertzog <hertzog@debian.org>
++#
++# Hardening build flags handling derived from work of:
++# Copyright © 2009-2011 Kees Cook <kees@debian.org>
++# Copyright © 2007-2008 Canonical, Ltd.
++#
++# This program is free software; you can redistribute it and/or modify
++# it under the terms of the GNU General Public License as published by
++# the Free Software Foundation; either version 2 of the License, or
++# (at your option) any later version.
++#
++# This program is distributed in the hope that it will be useful,
++# but WITHOUT ANY WARRANTY; without even the implied warranty of
++# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
++# GNU General Public License for more details.
++#
++# You should have received a copy of the GNU General Public License
++# along with this program.  If not, see <http://www.gnu.org/licenses/>.
++
++package Dpkg::Vendor::Fink;
++
++use strict;
++use warnings;
++
++our $VERSION = "0.01";
++
++use base qw(Dpkg::Vendor::Default);
++
++use Dpkg::Gettext;
++use Dpkg::ErrorHandling;
++use Dpkg::Control::Types;
++use Dpkg::Vendor::Ubuntu;
++use Dpkg::BuildOptions;
++use Dpkg::Arch qw(get_host_arch debarch_to_debtriplet);
++
++=encoding utf8
++
++=head1 NAME
++
++Dpkg::Vendor::Fink - Fink vendor object
++
++=head1 DESCRIPTION
++
++This vendor object customize the behaviour of dpkg scripts
++for Fink specific actions.
++
++=cut
++
++sub run_hook {
++    my ($self, $hook, @params) = @_;
++
++    if ($hook eq "before-source-build") {
++        my $srcpkg = shift @params;
++    } elsif ($hook eq "keyrings") {
++        return ();
++    } elsif ($hook eq "register-custom-fields") {
++        return ();
++    } elsif ($hook eq "post-process-changelog-entry") {
++        my $fields = shift @params;
++    } elsif ($hook eq "extend-patch-header") {
++	my ($textref, $ch_info) = @params;
++    } elsif ($hook eq "update-buildflags") {
++	$self->add_hardening_flags(@params);
++    } else {
++        return $self->SUPER::run_hook($hook, @params);
++    }
++}
++
++sub add_hardening_flags {
++    my ($self, $flags) = @_;
++    my $arch = get_host_arch();
++    my ($abi, $os, $cpu) = debarch_to_debtriplet($arch);
++
++    unless (defined $abi and defined $os and defined $cpu) {
++        warning(_g("unknown host architecture '%s'"), $arch);
++        ($abi, $os, $cpu) = ("", "", "");
++    }
++
++    # start by removing the Dpkg defaults "-g -O2"
++    $flags->strip("CFLAGS", "-g");
++    $flags->strip("CXXFLAGS", "-g");
++    $flags->strip("FFLAGS", "-g");
++    $flags->strip("CFLAGS", "-O2");
++    $flags->strip("CXXFLAGS", "-O2");
++    $flags->strip("FFLAGS", "-O2");
++
++    $flags->append("CPPFLAGS", "-I@FINKPREFIX@/include");
++    $flags->append("LDFLAGS", "-L@FINKPREFIX@/lib");
++
++    # for building 64bit libraries, we change LDFLAGS:
++    #if (exists $self->{_type_hash}->{"-64bit"}) {
++    #    if ($self->{_type_hash}->{"-64bit"} eq "-64bit") {
++    #        $defaults{"LDFLAGS"} = "-L\%p/\%lib -L\%p/lib";
++    #    }
++    #}
++}
++
++1;
diff -ruN dpkg-1.17.6.orig/fink/patches/fink-bld_no_fakeroot.patch dpkg-1.17.6/fink/patches/fink-bld_no_fakeroot.patch
--- dpkg-1.17.6.orig/fink/patches/fink-bld_no_fakeroot.patch	1969-12-31 17:00:00.000000000 -0700
+++ dpkg-1.17.6/fink/patches/fink-bld_no_fakeroot.patch	2014-03-05 14:58:48.000000000 -0700
@@ -0,0 +1,19 @@
+--- dpkg-1.16.4.3.orig/scripts/dpkg-buildpackage.pl	2014-01-15 07:02:15.000000000 -0700
++++ dpkg-1.16.4.3/scripts/dpkg-buildpackage.pl	2014-03-05 14:53:44.000000000 -0700
+@@ -319,12 +319,15 @@
+ 
+ if ($< == 0) {
+     warning(_g('using a gain-root-command while being root')) if (@rootcommand);
++} elsif (getpwuid($<) eq "fink-bld") {
++    warning(_g('removing the gain-root-command while being fink-bld')) if (@rootcommand);
++    pop  @rootcommand if (@rootcommand);
+ } else {
+     push @rootcommand, 'fakeroot' unless @rootcommand;
+ }
+ 
+ if (@rootcommand and not find_command($rootcommand[0])) {
+-    if ($rootcommand[0] eq 'fakeroot' and $< != 0) {
++    if ($rootcommand[0] eq 'fakeroot' and $< != 0 and getpwuid($<) ne "fink-bld") {
+         error(_g("fakeroot not found, either install the fakeroot\n" .
+                  'package, specify a command with the -r option, ' .
+                  'or run this as root'));
diff -ruN dpkg-1.17.6.orig/fink/patches/fink-virtuals.patch dpkg-1.17.6/fink/patches/fink-virtuals.patch
--- dpkg-1.17.6.orig/fink/patches/fink-virtuals.patch	1969-12-31 17:00:00.000000000 -0700
+++ dpkg-1.17.6/fink/patches/fink-virtuals.patch	2014-02-07 08:51:43.000000000 -0700
@@ -0,0 +1,563 @@
+diff -ruN dpkg-1.16.4.3.orig/dselect/main.cc dpkg-1.16.4.3/dselect/main.cc
+--- dpkg-1.16.4.3.orig/dselect/main.cc	2012-06-13 23:12:30.000000000 -0600
++++ dpkg-1.16.4.3/dselect/main.cc	2012-07-02 16:42:33.000000000 -0600
+@@ -24,6 +24,7 @@
+ #include <compat.h>
+ 
+ #include <sys/types.h>
++#include <sys/stat.h>
+ #include <sys/wait.h>
+ 
+ #include <assert.h>
+@@ -56,6 +56,12 @@
+ #include <dpkg/dpkg-db.h>
+ #include <dpkg/options.h>
+ 
++/* FINK LOCAL begin */
++#include <sys/utsname.h>
++#include <CoreFoundation/CoreFoundation.h>
++static void finkinit();
++/* FINK LOCAL end */
++
+ #include "dselect.h"
+ #include "bindings.h"
+ #include "pkglist.h"
+@@ -504,6 +510,173 @@
+   return urqr_quitmenu;
+ }
+ 
++/* FINK LOCAL begin */
++extern "C" {
++struct FinkVirtualPkgs {
++  struct FinkVirtualPkgs *next;
++  char *pkgname;
++  struct dpkg_version version;
++};
++
++struct FinkVirtualPkgs *fink_virt_pkg = NULL;
++}
++static void finkinit()
++{
++  FILE *virt_pkg_stream = NULL;
++  struct stat sb;
++  struct FinkVirtualPkgs *pkg;
++  char name[256];
++  char version[256];
++  char revision[256];
++  unsigned int  epoch;
++  Boolean status;
++  SInt32 errorCode;
++  CFURLRef fileURL = NULL;
++  CFDataRef resourceData = NULL;
++  CFPropertyListRef propertyList = NULL;    CFStringRef string;
++  static char buffer[256];  // This is static, to ensure the buffer stays around
++  static struct utsname ver;  // This is static, to ensure the buffer stays around
++
++  // Set PERL5LIB for the scripts to use. This is necessary because some
++  // package scripts use Dpkg.pm and it's in a "non-standard" Fink location.
++  {
++    char *perl5lib     = getenv("PERL5LIB");
++    size_t perl5lib_s  = 0;
++    if( perl5lib != NULL )
++      perl5lib_s       = strlen( perl5lib );
++    const char *perl5lib_add = ":@FINKPREFIX@/lib/perl5";
++    char *perl5lib_new = (char*)malloc(perl5lib_s + strlen(perl5lib_add) + 1);
++    char *perl5lib_set = perl5lib_new;
++    if( perl5lib_s > 0 )
++      perl5lib_set = stpcpy( perl5lib_set, perl5lib );
++    perl5lib_set = stpcpy( perl5lib_set, perl5lib_add );
++    perl5lib_set[0] = '\0';
++    setenv( "PERL5LIB", perl5lib_new, 1 );
++    free( perl5lib_new );
++  }
++
++  if (0 == stat("@FINKPREFIX@/bin/fink-virtual-pkgs", &sb))
++  {
++    virt_pkg_stream =popen("@FINKPREFIX@/bin/fink-virtual-pkgs --dpkg","r");
++    if (virt_pkg_stream)
++    {
++      while (fscanf(virt_pkg_stream,"%s\t%u\t%s\t%s\n",name,&epoch,version, revision) == 4)
++      {
++        pkg = (struct FinkVirtualPkgs *)malloc(sizeof(struct FinkVirtualPkgs));
++        if (pkg)
++        {
++          pkg->next = fink_virt_pkg;
++          pkg->pkgname = strdup(name);
++          pkg->version.epoch = epoch;
++          pkg->version.version = strdup(version);
++          pkg->version.revision = strdup(revision);
++          /* Quick and simple sanity check */
++          if ((NULL != pkg->pkgname) && (0 != strlen(pkg->pkgname)) &&
++              (NULL != pkg->version.version) && (0 != strlen(pkg->version.version)) &&
++              (NULL != pkg->version.revision) && (0 != strlen(pkg->version.revision)))
++          {
++            /* We are leaking here if something fails the sanity check above */
++            fink_virt_pkg = pkg;
++          }
++        }
++      }
++      if (pclose(virt_pkg_stream))
++      {
++        /* The fink-virtual-pkgs script returned a non zero exit status *
++         * clean up and try the old way.                                */
++        while(NULL != fink_virt_pkg)
++        {
++          pkg = fink_virt_pkg;
++          if (NULL != pkg->pkgname) free(pkg->pkgname);
++          if (NULL != pkg->version.version) free((void*)pkg->version.version);
++          if (NULL != pkg->version.revision) free((void*)pkg->version.revision);
++          fink_virt_pkg = pkg->next;
++          free(pkg);
++        }
++      }
++    }
++  }
++  if (NULL == fink_virt_pkg)
++  {
++    /* Determine system version */
++    /* TODO - should maybe check if this is really Darwin? */
++    if (!uname(&ver)) {
++        pkg = (struct FinkVirtualPkgs *)malloc(sizeof(struct FinkVirtualPkgs));
++        if (pkg) {
++        pkg->next = fink_virt_pkg;
++        pkg->pkgname = strdup("darwin");
++        pkg->version.epoch = 0;
++        pkg->version.version = ver.release;
++        pkg->version.revision = NULL;
++        fink_virt_pkg = pkg;
++        }
++    }
++
++    /* Check whether this is Mac OS X, and which version of it */
++
++    fileURL = CFURLCreateWithFileSystemPath( NULL,
++      CFSTR("/System/Library/CoreServices/SystemVersion.plist"),
++      kCFURLPOSIXPathStyle,
++      false );
++    if (!fileURL)
++    goto BAIL;
++
++    /* Read the XML */
++    status = CFURLCreateDataAndPropertiesFromResource(
++      NULL,
++      fileURL,
++      &resourceData,
++      NULL,
++      NULL,
++      &errorCode);
++    if (!status || errorCode != 0)
++    goto BAIL;
++
++    /* Reconstitute the dictionary using the XML data. */
++    propertyList = CFPropertyListCreateFromXMLData( NULL,
++      resourceData,
++      kCFPropertyListImmutable,
++      &string);
++    if (!propertyList)
++    goto BAIL;
++
++    /* Try to read the system version from it. */
++    status = CFDictionaryGetValueIfPresent(
++      (CFDictionaryRef)propertyList,
++      (const void*)CFSTR("ProductVersion"),
++      (const void**)&string);
++    if (!status)
++    goto BAIL;
++
++    /* Convert into a C string */
++    status = CFStringGetCString( string,
++      buffer,
++      sizeof(buffer),
++      kCFStringEncodingISOLatin1);
++    if (!status)
++    goto BAIL;
++    pkg = (struct FinkVirtualPkgs *)malloc(sizeof(struct FinkVirtualPkgs));
++    if (pkg)
++    {
++      pkg->next = fink_virt_pkg;
++      pkg->pkgname = strdup("macosx");
++      pkg->version.epoch = 0;
++      pkg->version.version = buffer;
++      pkg->version.revision = NULL;
++      fink_virt_pkg = pkg;
++    }
++  BAIL:
++    // Release all of the CF objects we're responsible for.
++    if (fileURL)
++    CFRelease(fileURL);
++    if (resourceData)
++    CFRelease(resourceData);
++    if (propertyList)
++    CFRelease(propertyList);
++  }
++}
++/* FINK LOCAL end */
++
+ static void
+ dselect_catch_fatal_error()
+ {
+@@ -515,6 +687,10 @@
+ main(int, const char *const *argv)
+ {
+   dpkg_locales_init(DSELECT);
++  /* FINK LOCAL begin */
++  finkinit();
++  /* FINK LOCAL end */
++
+   dpkg_set_progname(DSELECT);
+ 
+   push_error_context_func(dselect_catch_fatal_error, print_fatal_error, nullptr);
+diff -ruN dpkg-1.16.4.3.orig/dselect/pkgdepcon.cc dpkg-1.16.4.3/dselect/pkgdepcon.cc
+--- dpkg-1.16.4.3.orig/dselect/pkgdepcon.cc	2012-06-13 23:12:30.000000000 -0600
++++ dpkg-1.16.4.3/dselect/pkgdepcon.cc	2012-07-03 10:39:12.000000000 -0600
+@@ -211,6 +211,17 @@
+   return 2;
+ }
+ 
++/* FINK LOCAL begin */
++extern "C" {
++struct FinkVirtualPkgs {
++  struct FinkVirtualPkgs *next;
++  char *pkgname;
++  struct dpkg_version version;
++};
++extern struct FinkVirtualPkgs *fink_virt_pkg;
++}
++/* FINK LOCAL end */
++
+ int packagelist::resolvedepcon(dependency *depends) {
+   perpackagestate *best, *fixbyupgrade;
+   deppossi *possi, *provider;
+@@ -385,6 +396,29 @@
+   int would;
+   pkginfo::pkgwant want= pkginfo::want_purge;
+ 
++  /* FINK LOCAL begin */
++  {
++    int interestingwarnings;
++    struct varbuf oemsgs;
++    struct FinkVirtualPkgs *virt_pkg = NULL;
++    varbuf_init(&oemsgs, 1024);
++    interestingwarnings= 0;
++    virt_pkg = fink_virt_pkg;
++    while (virt_pkg)
++    {
++      if (strcasecmp(possi->ed->name, virt_pkg->pkgname) == 0) {
++        debug(dbg_depcondetail,"Found package : %s from VirtPackages.pm, depended by %s\n",virt_pkg->pkgname, possi->ed->name);
++        if (dpkg_version_relate(&virt_pkg->version,possi->verrel,&possi->version))
++        {
++          return 1;
++        }
++      }
++      virt_pkg = virt_pkg->next;
++    }
++    varbuf_destroy(&oemsgs);
++  }
++  /* FINK LOCAL end */
++
+   if (possi->ed->pkg.clientdata) {
+     want = possi->ed->pkg.clientdata->selected;
+     would = would_like_to_install(want, &possi->ed->pkg);
+diff -ruN dpkg-1.16.4.3.orig/src/main.c dpkg-1.16.4.3/src/main.c
+--- dpkg-1.16.4.3.orig/src/main.c	2012-06-13 23:12:34.000000000 -0600
++++ dpkg-1.16.4.3/src/main.c	2012-07-02 16:44:43.000000000 -0600
+@@ -25,6 +25,7 @@
+ #include <compat.h>
+ 
+ #include <sys/types.h>
++#include <sys/stat.h>
+ #include <sys/wait.h>
+ 
+ #include <errno.h>
+@@ -50,6 +50,11 @@
+ #include <dpkg/command.h>
+ #include <dpkg/pkg-spec.h>
+ #include <dpkg/options.h>
++/* FINK LOCAL begin */
++#include <sys/utsname.h>
++#include <CoreFoundation/CoreFoundation.h>
++static void finkinit();
++/* FINK LOCAL end */
+ 
+ #include "main.h"
+ #include "filesdb.h"
+@@ -852,6 +857,172 @@
+   return ret;
+ }
+ 
++/* FINK LOCAL begin */
++struct FinkVirtualPkgs {
++  struct FinkVirtualPkgs *next;
++  char *pkgname;
++  struct dpkg_version version;
++};
++
++struct FinkVirtualPkgs *fink_virt_pkg = NULL;
++static void finkinit()
++{
++  FILE *virt_pkg_stream = NULL;
++  struct stat sb;
++  struct FinkVirtualPkgs *pkg;
++  char name[256];
++  char version[256];
++  char revision[256];
++  unsigned int  epoch;
++  Boolean status;
++  SInt32 errorCode;
++  CFURLRef fileURL = NULL;
++  CFDataRef resourceData = NULL;
++  CFPropertyListRef propertyList = NULL;
++  CFStringRef string;
++  static char buffer[256];  // This is static, to ensure the buffer stays around
++  static struct utsname ver;  // This is static, to ensure the buffer stays around
++
++  // Set PERL5LIB for the scripts to use. This is necessary because some
++  // package scripts use Dpkg.pm and it's in a "non-standard" Fink location.
++  {
++    char *perl5lib     = getenv("PERL5LIB");
++    size_t perl5lib_s  = 0;
++    if( perl5lib != NULL )
++      perl5lib_s       = strlen( perl5lib );
++    const char *perl5lib_add = ":@FINKPREFIX@/lib/perl5";
++    char *perl5lib_new = (char*)malloc(perl5lib_s + strlen(perl5lib_add) + 1);
++    char *perl5lib_set = perl5lib_new;
++    if( perl5lib_s > 0 )
++      perl5lib_set = stpcpy( perl5lib_set, perl5lib );
++    perl5lib_set = stpcpy( perl5lib_set, perl5lib_add );
++    perl5lib_set[0] = '\0';
++    setenv( "PERL5LIB", perl5lib_new, 1 );
++    free( perl5lib_new );
++  }
++
++  if (0 == stat("@FINKPREFIX@/bin/fink-virtual-pkgs", &sb))
++  {
++    virt_pkg_stream =popen("@FINKPREFIX@/bin/fink-virtual-pkgs --dpkg","r");
++    if (virt_pkg_stream)
++    {
++      while (fscanf(virt_pkg_stream,"%s\t%u\t%s\t%s\n",name,&epoch,version,revision) == 4)
++      {
++        pkg = (struct FinkVirtualPkgs *)malloc(sizeof(struct FinkVirtualPkgs));
++        if (pkg)
++        {
++          pkg->next = fink_virt_pkg;
++          pkg->pkgname = strdup(name);
++          pkg->version.epoch = epoch;
++          pkg->version.version = strdup(version);
++          pkg->version.revision = strdup(revision);
++          /* Quick and simple sanity check */
++          if ((NULL != pkg->pkgname) && (0 != strlen(pkg->pkgname)) &&
++              (NULL != pkg->version.version) && (0 != strlen(pkg->version.version)) &&
++              (NULL != pkg->version.revision) && (0 != strlen(pkg->version.revision)))
++          {
++            /* We are leaking here if something fails the sanity check above */
++            fink_virt_pkg = pkg;
++          }
++        }
++      }
++      if (pclose(virt_pkg_stream))
++      {
++        /* The fink-virtual-pkgs script returned a non zero exit status *
++         * clean up and try the old way.                                */
++        while(NULL != fink_virt_pkg)
++        {
++          pkg = fink_virt_pkg;
++          if (NULL != pkg->pkgname) free(pkg->pkgname);
++          if (NULL != pkg->version.version) free(pkg->version.version);
++          if (NULL != pkg->version.revision) free(pkg->version.revision);
++          fink_virt_pkg = pkg->next;
++          free(pkg);
++        }
++        fink_virt_pkg = NULL;
++      }
++    }
++  }
++  if (NULL == fink_virt_pkg)
++  {
++    /* Determine system version */
++    /* TODO - should maybe check if this is really Darwin? */
++    if (!uname(&ver)) {
++        pkg = (struct FinkVirtualPkgs *)malloc(sizeof(struct FinkVirtualPkgs));
++        if (pkg) {
++        pkg->next = fink_virt_pkg;
++        pkg->pkgname = strdup("darwin");
++        pkg->version.epoch = 0;
++        pkg->version.version = ver.release;
++        pkg->version.revision = NULL;
++        fink_virt_pkg = pkg;
++        }
++    }
++
++    /* Check whether this is Mac OS X, and which version of it */
++
++    fileURL = CFURLCreateWithFileSystemPath( NULL,
++      CFSTR("/System/Library/CoreServices/SystemVersion.plist"),
++      kCFURLPOSIXPathStyle,
++      false );
++    if (!fileURL)
++    goto BAIL;
++
++    /* Read the XML */
++    status = CFURLCreateDataAndPropertiesFromResource(
++      NULL,
++      fileURL,
++      &resourceData,
++      NULL,
++      NULL,
++      &errorCode);
++    if (!status || errorCode != 0)
++    goto BAIL;
++
++    /* Reconstitute the dictionary using the XML data. */
++    propertyList = CFPropertyListCreateFromXMLData( NULL,
++      resourceData,
++      kCFPropertyListImmutable,
++      &string);
++    if (!propertyList)
++    goto BAIL;
++
++    /* Try to read the system version from it. */
++    status = CFDictionaryGetValueIfPresent( propertyList,
++      CFSTR("ProductVersion"),
++      (void*)&string);
++    if (!status)
++    goto BAIL;
++
++    /* Convert into a C string */
++    status = CFStringGetCString( string,
++      buffer,
++      sizeof(buffer),
++      kCFStringEncodingISOLatin1);
++    if (!status)
++    goto BAIL;
++    pkg = (struct FinkVirtualPkgs *)malloc(sizeof(struct FinkVirtualPkgs));
++    if (pkg)
++    {
++      pkg->next = fink_virt_pkg;
++      pkg->pkgname = strdup("macosx");
++      pkg->version.epoch = 0;
++      pkg->version.version = buffer;
++      pkg->version.revision = NULL;
++      fink_virt_pkg = pkg;
++    }
++  BAIL:
++    // Release all of the CF objects we're responsible for.
++    if (fileURL)
++    CFRelease(fileURL);
++    if (resourceData)
++    CFRelease(resourceData);
++    if (propertyList)
++    CFRelease(propertyList);
++  }
++}
++/* FINK LOCAL end */
++
+ int main(int argc, const char *const *argv) {
+   int ret;
+ 
+@@ -878,6 +1049,10 @@
+ 
+   filesdbinit();
+ 
++  /* FINK LOCAL begin */
++  finkinit();
++  /* FINK LOCAL end */
++
+   ret = cipaction->action(argv);
+ 
+   if (is_invoke_action(cipaction->arg_int))
+diff -ruN dpkg-1.16.4.3.orig/src/main.h dpkg-1.16.4.3/src/main.h
+--- dpkg-1.16.4.3.orig/src/main.h	2012-06-13 23:12:34.000000000 -0600
++++ dpkg-1.16.4.3/src/main.h	2012-07-02 16:43:04.000000000 -0600
+@@ -134,6 +134,11 @@
+ 	const char *command;
+ };
+ 
++/* FINK LOCAL begin */
++extern struct dpkg_version darwin_version;
++extern struct dpkg_version macosx_version;
++/* FINK LOCAL end */
++
+ /* from archives.c */
+ 
+ int archivefiles(const char *const *argv);
+diff -ruN dpkg-1.16.4.3.orig/src/packages.c dpkg-1.16.4.3/src/packages.c
+--- dpkg-1.16.4.3.orig/src/packages.c	2012-06-13 23:12:34.000000000 -0600
++++ dpkg-1.16.4.3/src/packages.c	2012-07-02 16:52:10.000000000 -0600
+@@ -538,6 +538,40 @@
+   return ok;
+ }
+ 
++/* FINK LOCAL begin */
++static int
++check_pseudo_package(const struct dpkg_version *versrev, const struct deppossi *possi, int *interestingwarnings, struct varbuf *oemsgs) {
++
++  if( dpkg_version_relate(versrev,possi->verrel,&possi->version)) {
++    debug(dbg_depcondetail,"        virtual version %s >= %s, PASS", versiondescribe(versrev, vdew_nonambig), versiondescribe(&possi->version, vdew_nonambig));
++    return found_ok;
++  } else {
++    (*interestingwarnings)++;
++    varbuf_add_str(oemsgs, _("  Version of "));
++    varbuf_add_str(oemsgs, possi->ed->name);
++    varbuf_add_str(oemsgs, _(" on system is "));
++    varbuf_add_str(oemsgs, versiondescribe(versrev, vdew_nonambig));
++    varbuf_add_str(oemsgs, ".\n");
++    /* If fink-virtual-pkgs returns 0-0 we assume that it satisfies the
++       version requirements no matter what, this is temp till f-v-p is fixed */
++    const char *forcedversion = "0-0";
++    if (strcasecmp(versiondescribe(versrev, vdew_nonambig), forcedversion) == 0) {
++      debug(dbg_depcondetail,"        virtual version %s, Forced!", versiondescribe(versrev, vdew_nonambig));
++      return found_forced;
++    } else {
++      debug(dbg_depcondetail,"        virtual version %s < %s, FAIL", versiondescribe(versrev, vdew_nonambig), versiondescribe(&possi->version, vdew_nonambig));
++      return found_none;
++    }
++  }
++}
++struct FinkVirtualPkgs {
++  struct FinkVirtualPkgs *next;
++  char *pkgname;
++  struct dpkg_version version;
++};
++extern struct FinkVirtualPkgs *fink_virt_pkg;
++/* FINK LOCAL end */
++
+ /*
+  * Checks [Pre]-Depends only.
+  */
+@@ -555,6 +589,7 @@
+   struct dependency *dep;
+   struct deppossi *possi, *provider;
+   struct pkginfo *possfixbytrig, *canfixbytrig;
++  struct FinkVirtualPkgs *virt_pkg = NULL;
+ 
+   interestingwarnings= 0;
+   ok = dep_check_ok;
+@@ -595,6 +630,28 @@
+       }
+       deppossi_pkg_iter_free(possi_iter);
+ 
++      /* FINK LOCAL begin */
++      if (found != found_ok) {
++        virt_pkg = fink_virt_pkg;
++        while (virt_pkg) {
++          if (strcasecmp(possi->ed->name, virt_pkg->pkgname) == 0) {
++              found = check_pseudo_package(&virt_pkg->version, possi,
++				           &interestingwarnings, &oemsgs);
++            if (found == found_ok || found == found_forced) {
++              debug(dbg_depcondetail,"        is fink-virtual, ok and found");
++	      break;
++	    }
++          }
++          virt_pkg = virt_pkg->next;
++        }
++      }
++      if (found == found_ok || found == found_forced) {
++        /* found done */
++        debug(dbg_depcondetail,"    found %d",found);
++        break;
++      }
++      /* FINK LOCAL end */
++
+       if (found != found_ok && possi->verrel == dpkg_relation_none) {
+         for (provider = possi->ed->depended.installed;
+              found != found_ok && provider;
diff -ruN dpkg-1.17.6.orig/fink/patches/full-path-calls.patch dpkg-1.17.6/fink/patches/full-path-calls.patch
--- dpkg-1.17.6.orig/fink/patches/full-path-calls.patch	1969-12-31 17:00:00.000000000 -0700
+++ dpkg-1.17.6/fink/patches/full-path-calls.patch	2012-07-09 16:10:10.000000000 -0600
@@ -0,0 +1,44 @@
+diff -ruN dpkg-1.16.4.3.orig/dselect/dselect.h dpkg-1.16.4.3/dselect/dselect.h
+--- dpkg-1.16.4.3.orig/dselect/dselect.h	2012-06-13 23:12:30.000000000 -0600
++++ dpkg-1.16.4.3/dselect/dselect.h	2012-07-02 16:14:45.000000000 -0600
+@@ -33,7 +33,7 @@
+ 
+ #include "dselect-curses.h"
+ 
+-#define DSELECT		"dselect"
++#define DSELECT		"@FINKPREFIX@/bin/dselect"
+ 
+ #define TOTAL_LIST_WIDTH 180
+ #define MAX_DISPLAY_INFO 120
+diff -ruN dpkg-1.16.4.3.orig/lib/dpkg/dpkg.h dpkg-1.16.4.3/lib/dpkg/dpkg.h
+--- dpkg-1.16.4.3.orig/lib/dpkg/dpkg.h	2012-06-13 23:12:31.000000000 -0600
++++ dpkg-1.16.4.3/lib/dpkg/dpkg.h	2012-07-02 16:14:45.000000000 -0600
+@@ -94,19 +94,19 @@
+ #define MAXUPDATES         250
+ 
+ #define DEFAULTSHELL        "sh"
+-#define DEFAULTPAGER        "pager"
++#define DEFAULTPAGER        "less"
+ 
+ #define MD5HASHLEN           32
+ #define MAXTRIGDIRECTIVE     256
+ 
+-#define BACKEND		"dpkg-deb"
+-#define SPLITTER	"dpkg-split"
+-#define DPKGQUERY	"dpkg-query"
+-#define DPKGDIVERT	"dpkg-divert"
+-#define DPKGSTAT	"dpkg-statoverride"
+-#define DPKGTRIGGER	"dpkg-trigger"
+-#define DPKG		"dpkg"
+-#define DEBSIGVERIFY	"/usr/bin/debsig-verify"
++#define BACKEND		"@FINKPREFIX@/bin/dpkg-deb"
++#define SPLITTER	"@FINKPREFIX@/bin/dpkg-split"
++#define DPKGQUERY	"@FINKPREFIX@/bin/dpkg-query"
++#define DPKGDIVERT	"@FINKPREFIX@/bin/dpkg-divert"
++#define DPKGSTAT	"@FINKPREFIX@/bin/dpkg-statoverride"
++#define DPKGTRIGGER	"@FINKPREFIX@/bin/dpkg-trigger"
++#define DPKG		"@FINKPREFIX@/bin/dpkg"
++#define DEBSIGVERIFY	"@FINKPREFIX@/bin/debsig-verify"
+ 
+ #define TAR		"tar"
+ #define RM		"rm"
diff -ruN dpkg-1.17.6.orig/fink/patches/gzip-rsyncable-fix.patch dpkg-1.17.6/fink/patches/gzip-rsyncable-fix.patch
--- dpkg-1.17.6.orig/fink/patches/gzip-rsyncable-fix.patch	1969-12-31 17:00:00.000000000 -0700
+++ dpkg-1.17.6/fink/patches/gzip-rsyncable-fix.patch	2013-12-23 10:28:23.000000000 -0700
@@ -0,0 +1,14 @@
+diff -ruN dpkg-1.16.4.3.orig/scripts/Dpkg/Compression.pm dpkg-1.16.4.3/scripts/Dpkg/Compression.pm
+--- dpkg-1.16.4.3.orig/scripts/Dpkg/Compression.pm	2012-06-13 23:12:33.000000000 -0600
++++ dpkg-1.16.4.3/scripts/Dpkg/Compression.pm	2012-07-02 16:14:45.000000000 -0600
+@@ -50,7 +50,9 @@
+ my $COMP = {
+     gzip => {
+ 	file_ext => 'gz',
+-	comp_prog => [ 'gzip', '--no-name', '--rsyncable' ],
++        # Fink doesn't have rsyncable bzip2/gzip yet
++        # comp_prog => [ 'gzip', '--no-name', '--rsyncable' ],
++	comp_prog => [ 'gzip', '--no-name' ],
+ 	decomp_prog => [ 'gunzip' ],
+ 	default_level => 9,
+     },
diff -ruN dpkg-1.17.6.orig/fink/patches/location-fixes.patch dpkg-1.17.6/fink/patches/location-fixes.patch
--- dpkg-1.17.6.orig/fink/patches/location-fixes.patch	1969-12-31 17:00:00.000000000 -0700
+++ dpkg-1.17.6/fink/patches/location-fixes.patch	2013-12-23 11:39:45.000000000 -0700
@@ -0,0 +1,49 @@
+diff -ruN dpkg-1.16.4.3.orig/dpkg-split/queue.c dpkg-1.16.4.3/dpkg-split/queue.c
+--- dpkg-1.16.4.3.orig/dpkg-split/queue.c	2012-06-13 23:12:30.000000000 -0600
++++ dpkg-1.16.4.3/dpkg-split/queue.c	2012-07-02 16:14:45.000000000 -0600
+@@ -46,7 +46,7 @@
+ #include "dpkg-split.h"
+ 
+ /*
+- * The queue, by default located in /var/lib/dpkg/parts/, is a plain
++ * The queue, by default located in @FINKPREFIX@/var/lib/dpkg/parts/, is a plain
+  * directory with one file per part.
+  *
+  * Each part is named “<md5sum>.<maxpartlen>.<thispartn>.<maxpartn>”,
+diff -ruN dpkg-1.16.4.3.orig/scripts/Dpkg/Changelog/Parse.pm dpkg-1.16.4.3/scripts/Dpkg/Changelog/Parse.pm
+--- dpkg-1.16.4.3.orig/scripts/Dpkg/Changelog/Parse.pm	2012-06-09 08:32:08.000000000 -0600
++++ dpkg-1.16.4.3/scripts/Dpkg/Changelog/Parse.pm	2012-07-02 16:14:45.000000000 -0600
+@@ -56,7 +56,7 @@
+ 
+ The parsing itself is done by an external program (searched in the
+ following list of directories: $opt{libdir},
+-F</usr/local/lib/dpkg/parsechangelog>, F</usr/lib/dpkg/parsechangelog>) That
++F<@FINKPREFIX@/lib/dpkg/parsechangelog>) That
+ program is named according to the format that it's able to parse. By
+ default it's either "debian" or the format name lookep up in the 40 last
+ lines of the changelog itself (extracted with this perl regular expression
+@@ -76,9 +76,8 @@
+ 
+ sub changelog_parse {
+     my (%options) = @_;
+-    my @parserpath = ('/usr/local/lib/dpkg/parsechangelog',
+-                      "$Dpkg::LIBDIR/parsechangelog",
+-                      '/usr/lib/dpkg/parsechangelog');
++    my @parserpath = ("$Dpkg::LIBDIR/parsechangelog",
++                      '@FINKPREFIX@/lib/dpkg/parsechangelog');
+     my $format = 'debian';
+     my $force = 0;
+ 
+diff -ruN dpkg-1.16.4.3.orig/scripts/Dpkg/Shlibs.pm dpkg-1.16.4.3/scripts/Dpkg/Shlibs.pm
+--- dpkg-1.16.4.3.orig/scripts/Dpkg/Shlibs.pm	2012-06-13 23:12:34.000000000 -0600
++++ dpkg-1.16.4.3/scripts/Dpkg/Shlibs.pm	2012-07-02 16:14:45.000000000 -0600
+@@ -36,7 +36,8 @@
+                   gnutriplet_to_multiarch debarch_to_multiarch);
+ 
+ use constant DEFAULT_LIBRARY_PATH =>
+-    qw(/lib /usr/lib /lib32 /usr/lib32 /lib64 /usr/lib64
++    qw(@FINKPREFIX@/lib @FINKPREFIX@/lib32 @FINKPREFIX@/lib64
++       /lib /usr/lib /lib32 /usr/lib32 /lib64 /usr/lib64
+        /emul/ia32-linux/lib /emul/ia32-linux/usr/lib);
+ 
+ # Adjust set of directories to consider when we're in a situation of a
diff -ruN dpkg-1.17.6.orig/fink/patches/protect-system-dirs.patch dpkg-1.17.6/fink/patches/protect-system-dirs.patch
--- dpkg-1.17.6.orig/fink/patches/protect-system-dirs.patch	1969-12-31 17:00:00.000000000 -0700
+++ dpkg-1.17.6/fink/patches/protect-system-dirs.patch	2013-12-23 11:40:53.000000000 -0700
@@ -0,0 +1,29 @@
+diff -ruN dpkg-1.16.4.3.orig/src/help.c dpkg-1.16.4.3/src/help.c
+--- dpkg-1.16.4.3.orig/src/help.c	2012-06-13 23:12:34.000000000 -0600
++++ dpkg-1.16.4.3/src/help.c	2012-07-02 16:14:45.000000000 -0600
+@@ -271,6 +271,25 @@
+   debug(dbg_veryverbose, "dir_is_used_by_others '%s' (except %s)", file->name,
+         pkg ? pkg_name(pkg, pnaw_always) : "<none>");
+ 
++  /* FINK LOCAL begin */
++
++  /*
++   * Darwin has symlinks /etc -> /private/etc and /var -> /private/var
++   * instead of actual /etc and /var dirs. If dpkg removes the last
++   * pkg that it has record of having installed a file in one of those
++   * top-level dirs, it will try to remove the dir (since it thinks
++   * it's an empty dir) and it will succeed (since it's just unlinking
++   * a symlink, not trying to remove a dir that is not actually
++   * empty). That's Bad. Here we make sure these top-level dirs are
++   * never thought to be empty.
++   */
++  if( !strcmp(file->name,"/etc") || !strcmp(file->name,"/tmp") || !strcmp(file->name,"/var") ) {
++    debug(dbg_veryverbose, "dir_is_used_by_others precious!");
++    return true;
++  }
++
++  /* FINK LOCAL end */
++
+   iter = filepackages_iter_new(file);
+   while ((other_pkg = filepackages_iter_next(iter))) {
+     debug(dbg_veryverbose, "dir_is_used_by_others considering %s ...",
diff -ruN dpkg-1.17.6.orig/fink/patches/so-to-dylib.patch dpkg-1.17.6/fink/patches/so-to-dylib.patch
--- dpkg-1.17.6.orig/fink/patches/so-to-dylib.patch	1969-12-31 17:00:00.000000000 -0700
+++ dpkg-1.17.6/fink/patches/so-to-dylib.patch	2014-02-07 10:01:19.000000000 -0700
@@ -0,0 +1,266 @@
+diff -ruN dpkg-1.16.10/scripts.orig/Dpkg/Shlibs/Objdump.pm dpkg-1.16.10/scripts/Dpkg/Shlibs/Objdump.pm
+--- dpkg-1.16.10/scripts.orig/Dpkg/Shlibs/Objdump.pm	2013-03-17 21:40:28.000000000 -0600
++++ dpkg-1.16.10/scripts/Dpkg/Shlibs/Objdump.pm	2013-04-18 13:35:21.000000000 -0600
+@@ -28,9 +28,15 @@
+ 
+ # Decide which objdump to call
+ our $OBJDUMP = 'objdump';
++our $OTOOL = "otool";
++our $NM = "nm";
+ if (get_build_arch() ne get_host_arch()) {
+     my $od = debarch_to_gnutriplet(get_host_arch()) . '-objdump';
+     $OBJDUMP = $od if find_command($od);
++    my $otool = debarch_to_gnutriplet(get_host_arch()) . "-otool";
++    $OTOOL = $otool if find_command($otool);
++    my $nm = debarch_to_gnutriplet(get_host_arch()) . "-nm";
++    $NM = $nm if find_command($nm);
+ }
+ 
+ 
+@@ -93,9 +99,9 @@
+ 	    return $format{$file};
+ 	} else {
+ 	    my ($output, %opts, $pid, $res);
+-	    if ($objdump ne 'objdump') {
++	    #if ($objdump ne 'objdump') {
+ 		$opts{error_to_file} = '/dev/null';
+-	    }
++	    #}
+ 	    $pid = spawn(exec => [ $objdump, '-a', '--', $file ],
+ 			 env => { LC_ALL => 'C' },
+ 			 to_pipe => \$output, %opts);
+@@ -104,7 +110,8 @@
+ 		if (/^\s*\S+:\s*file\s+format\s+(\S+)\s*$/) {
+ 		    $format{$file} = $1;
+ 		    $res = $format{$file};
+-		    last;
++		    # This might now be the only format, lets always take last
++		    #last;
+ 		}
+ 	    }
+ 	    close($output);
+@@ -129,7 +136,30 @@
+     return $result;
+ }
+ 
++sub is_mach_o {
++    my ($file) = @_;
++    open(FILE, "<", $file) || syserr(_g("cannot read %s"), $file);
++    my ($header, $result) = ("", 0);
++    if (read(FILE, $header, 4) == 4) {
++       # isLittleEndian
++        # 32 bit Mach-O
++        $result = 1 if ($header =~ /^\xce\xfa\xed\xfe$/);
++        # 64 bit Mach-O
++        $result = 1 if ($header =~ /^\xcf\xfa\xed\xfe$/);
++       # Fat
++        # 32 bit Mach-O
++        $result = 1 if ($header =~ /^\xfe\xed\xfa\xce$/);
++        # 64 bit Mach-O
++        $result = 1 if ($header =~ /^\xfe\xed\xfa\xcf$/);
++
++       # Mach-O Universal object files
++        $result = 1 if ($header =~ /^\xca\xfe\xba\xbe$/);
++    }
++    close(FILE);
++    return $result;
++}
++
+ package Dpkg::Shlibs::Objdump::Object;
+ 
+ use Dpkg::Gettext;
+ use Dpkg::ErrorHandling;
+@@ -170,21 +200,118 @@
+ 
+ sub analyze {
+     my ($self, $file) = @_;
++    my $ret = 'none';
+ 
+     $file ||= $self->{file};
+     return unless $file;
+ 
++    use IPC::Open3;
++
+     $self->reset;
+     $self->{file} = $file;
+ 
+     local $ENV{LC_ALL} = 'C';
+-    open(my $objdump, '-|', $OBJDUMP, '-w', '-f', '-p', '-T', '-R', $file)
+-        or syserr(_g('cannot fork for %s'), $OBJDUMP);
+-    my $ret = $self->parse_objdump_output($objdump);
+-    close($objdump);
++    if (Dpkg::Shlibs::Objdump::is_elf($file)) {
++       open3(my $objdumpin, my $objdump, my $objdumperr, $OBJDUMP, "-w", "-f", "-p", "-T", "-R", $file)
++           || syserr(_g("cannot fork for %s"), $OBJDUMP);
++       $ret = $self->parse_objdump_output($objdump);
++       close($objdump);
++    } elsif (Dpkg::Shlibs::Objdump::is_mach_o($file)) {
++       # no RPATH, HASH or GNU_HASH in macho
++       $self->{RPATH} = [ '/' ];
++
++       open3(my $objdumpin, my $objdump, my $objdumperr, $OBJDUMP, "-f", "-p", $file)
++           || syserr(_g("cannot fork for %s"), $OBJDUMP);
++       $ret = $self->parse_objdump_output($objdump);
++       close($objdump);
++
++       # get SONAME (dylib doesn't really use rpath but SONAME has a path)
++       open(my $install_name, "-|", $OTOOL, "-X", "-D", $file)
++           || syserr(_g("cannot fork for %s"), $OTOOL);
++       $self->parse_macho_soname($install_name);
++       close($install_name);
++
++        # Get list of linked libs
++        open(my $needed_names, "-|", $OTOOL, "-L", "-X", $file)
++            || syserr(_g("cannot fork for %s"), $OTOOL);
++        $self->parse_macho_needed($needed_names);
++        close($needed_names);
++
++       # Get list of symbols
++       open(my $dynsymbols, "-|", $NM, "-g", $file)
++           || syserr(_g("cannot fork for %s"), $NM);
++       $self->parse_macho_dynamic_symbol($dynsymbols);
++       close($dynsymbols);
++    }
+     return $ret;
+ }
+ 
++sub parse_macho_dynamic_symbol {
++    my ($self, $fh) = @_;
++    while (defined($_ = <$fh>)) {
++       chomp;
++
++       # no version in mach o
++       my $ver = '';
++
++       if (/^([0-9a-f]{16}) ([T|D|U]) (\S+)$/) {
++           my ($flags, $sect, $name) = ($1, $2, $3);
++           my $symbol = {
++               name => $name,
++               version => defined($ver) ? $ver : '',
++               section => $sect,
++               dynamic => "D",
++               #debug => substr($flags, 5, 1) eq "d",
++               type => $sect,
++               #weak => substr($flags, 1, 1) eq "w",
++               #local => substr($flags, 0, 1) eq "l",
++               #global => substr($flags, 0, 1) eq "g",
++               #visibility => defined($vis) ? $vis : '',
++               hidden => '',
++               defined => $sect ne 'U'
++           };
++           $self->add_dynamic_symbol($symbol);
++       }
++    }
++}
++
++sub get_macho_compatversion {
++    my ($self, $file) = @_;
++    open(my $fh, "-|", $OTOOL, "-L", "-X", $file)
++        || syserr(_g("cannot fork for %s"), $OTOOL);
++    while (defined($_ = <$fh>)) {
++       chomp;
++       if (/^\s*(.+) \(compatibility version ([0-9.]+)/) {
++           return $2 if $1 eq $self->{SONAME};
++       }
++    }
++    close($fh);
++}
++
++sub parse_macho_needed {
++    my ($self, $fh) = @_;
++    while (defined($_ = <$fh>)) {
++        chomp;
++        if (/^\s*(.+) \(compatibility version/) {
++            next if $1 eq $self->{SONAME};
++            push @{$self->{NEEDED}}, $1;
++        }
++    }
++}
++
++sub parse_macho_soname {
++    my ($self, $fh) = @_;
++    while (defined($_ = <$fh>)) {
++       chomp;
++       if ($_) {
++               use File::Basename;
++               $self->{SONAME} = basename $_;
++               $self->{SONAME} = $_;
++               $self->{RPATH} = [ dirname $_ ];
++       }
++    }
++}
++
+ sub parse_objdump_output {
+     my ($self, $fh) = @_;
+ 
+diff -ruN dpkg-1.16.10/scripts.orig/dpkg-gensymbols.pl dpkg-1.16.10/scripts/dpkg-gensymbols.pl
+--- dpkg-1.16.10/scripts.orig/dpkg-gensymbols.pl	2013-03-17 21:40:29.000000000 -0600
++++ dpkg-1.16.10/scripts/dpkg-gensymbols.pl	2013-04-17 15:28:52.000000000 -0600
+@@ -195,8 +195,9 @@
+ 	opendir(my $libdir_dh, "$libdir")
+ 	    or syserr(_g("can't read directory %s: %s"), $libdir, $!);
+ 	push @files, grep {
+-	    /(\.so\.|\.so$)/ && -f $_ &&
+-	    Dpkg::Shlibs::Objdump::is_elf($_);
++	    /(\.so\.|\.so$|\.dylib$|\.bundle$)/ && -f $_ &&
++	    Dpkg::Shlibs::Objdump::is_elf($_) ||
++	    Dpkg::Shlibs::Objdump::is_mach_o($_);
+ 	} map { "$libdir/$_" } readdir($libdir_dh);
+ 	closedir $libdir_dh;
+     }
+diff -ruN dpkg-1.16.10/scripts.orig/dpkg-shlibdeps.pl dpkg-1.16.10/scripts/dpkg-shlibdeps.pl
+--- dpkg-1.16.10/scripts.orig/dpkg-shlibdeps.pl	2013-03-17 21:40:29.000000000 -0600
++++ dpkg-1.16.10/scripts/dpkg-shlibdeps.pl	2013-04-18 11:12:48.000000000 -0600
+@@ -185,13 +185,15 @@
+ 	unless (defined $lib) {
+ 	    $soname_notfound{$soname} = 1;
+ 	    $global_soname_notfound{$soname} = 1;
+-	    my $msg = _g("couldn't find library %s needed by %s (ELF " .
++	    my $libtype = 'ELF';
++	    $libtype = 'MACH-O' if Dpkg::Shlibs::Objdump::is_mach_o($soname);
++	    my $msg = _g("couldn't find library %s needed by %s (%s " .
+ 			 "format: '%s'; RPATH: '%s')");
+ 	    if (scalar(split_soname($soname))) {
+-		errormsg($msg, $soname, $file, $obj->{format}, join(':', @{$obj->{RPATH}}));
++		errormsg($msg, $soname, $file, $libtype, $obj->{format}, join(':', @{$obj->{RPATH}}));
+ 		$error_count++;
+ 	    } else {
+-		warning($msg, $soname, $file, $obj->{format}, join(':', @{$obj->{RPATH}}));
++		warning($msg, $soname, $file, $libtype, $obj->{format}, join(':', @{$obj->{RPATH}}));
+ 	    }
+ 	    next;
+ 	}
+@@ -671,13 +673,19 @@
+ 
+ sub split_soname {
+     my $soname = shift;
+-    if ($soname =~ /^(.*)\.so\.(.*)$/) {
+-	return wantarray ? ($1, $2) : 1;
+-    } elsif ($soname =~ /^(.*)-(\d.*)\.so$/) {
+-	return wantarray ? ($1, $2) : 1;
++
++    if (Dpkg::Shlibs::Objdump::is_mach_o($soname)) {
++	use File::Basename;
++	my $obj = Dpkg::Shlibs::Objdump::Object->new($soname);
++	return wantarray ? ($soname, $obj->get_macho_compatversion($soname)) : 1;
+     } else {
+-	return wantarray ? () : 0;
++	if ($soname =~ /^(.*)\.so\.(.*)$/) {
++	    return wantarray ? ($1, $2) : 1;
++	} elsif ($soname =~ /^(.*)-(\d.*)\.so$/) {
++	    return wantarray ? ($1, $2) : 1;
++	}
+     }
++    return wantarray ? () : 0;
+ }
+ 
+ sub extract_from_shlibs {
+@@ -702,7 +710,7 @@
+ 	    next;
+ 	}
+ 	my $depread = defined($4) ? $4 : '';
+-	if (($libname eq $2) && ($libversion eq $3)) {
++	if (($libname eq $2 || $soname eq $2) && ($libversion eq $3)) {
+ 	    # Define dep and end here if the package type explicitly
+ 	    # matches. Otherwise if the packagetype is not specified, use
+ 	    # the dep only as a default that can be overriden by a later
diff -ruN dpkg-1.17.6.orig/fink/patches/test-fix.patch dpkg-1.17.6/fink/patches/test-fix.patch
--- dpkg-1.17.6.orig/fink/patches/test-fix.patch	1969-12-31 17:00:00.000000000 -0700
+++ dpkg-1.17.6/fink/patches/test-fix.patch	2014-02-07 08:52:42.000000000 -0700
@@ -0,0 +1,20 @@
+diff -ruN dpkg-1.16.4.3.orig/src/t/100_dpkg_divert.t dpkg-1.16.4.3/src/t/100_dpkg_divert.t
+--- dpkg-1.16.4.3.orig/src/t/100_dpkg_divert.t	2012-06-13 23:12:34.000000000 -0600
++++ dpkg-1.16.4.3/src/t/100_dpkg_divert.t	2012-07-02 16:14:45.000000000 -0600
+@@ -601,6 +601,7 @@
+                 expect_failure => 1, expect_stderr_like => qr/Permission denied/);
+     diversions_eq('');
+ 
++    system("chmod 755 $testdir/nadir");
+     cleanup();
+ }
+ 
+@@ -614,7 +615,7 @@
+     system("chmod 500 $admindir");
+     call_divert(["$testdir/foo"], expect_failure => 1, expect_stderr_like => qr/create.*new/);
+     system("chmod 755 $admindir; ln -s /dev/full $admindir/diversions-new");
+-    call_divert(["$testdir/foo"], expect_failure => 1, expect_stderr_like => qr/(write|flush|close).*new/);
++    call_divert(["$testdir/foo"], expect_failure => 1, expect_stderr_like => qr/create.*new/);
+ }
+ 
+ system("rm -f $admindir/diversions-new; mkdir $admindir/diversions-old");
diff -ruN dpkg-1.17.6.orig/src/script.c.new dpkg-1.17.6/src/script.c.new
--- dpkg-1.17.6.orig/src/script.c.new	1969-12-31 17:00:00.000000000 -0700
+++ dpkg-1.17.6/src/script.c.new	2014-02-07 11:43:57.000000000 -0700
@@ -0,0 +1,417 @@
+/*
+ * dpkg - main program for package management
+ * script.c - maintainer script routines
+ *
+ * Copyright © 1995 Ian Jackson <ian@chiark.greenend.org.uk>
+ * Copyright © 2007-2013 Guillem Jover <guillem@debian.org>
+ *
+ * This is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <https://www.gnu.org/licenses/>.
+ */
+
+#include <config.h>
+#include <compat.h>
+
+#include <sys/types.h>
+#include <sys/stat.h>
+
+#include <assert.h>
+#include <errno.h>
+#include <string.h>
+#include <unistd.h>
+#include <stdlib.h>
+
+#ifdef WITH_SELINUX
+#include <selinux/selinux.h>
+#include <selinux/flask.h>
+#include <selinux/context.h>
+#endif
+
+#include <dpkg/i18n.h>
+#include <dpkg/dpkg.h>
+#include <dpkg/dpkg-db.h>
+#include <dpkg/pkg.h>
+#include <dpkg/subproc.h>
+#include <dpkg/command.h>
+#include <dpkg/triglib.h>
+
+#include "filesdb.h"
+#include "infodb.h"
+#include "main.h"
+
+void
+post_postinst_tasks(struct pkginfo *pkg, enum pkgstatus new_status)
+{
+	if (new_status < stat_triggersawaited)
+		pkg_set_status(pkg, new_status);
+	else if (pkg->trigaw.head)
+		pkg_set_status(pkg, stat_triggersawaited);
+	else if (pkg->trigpend_head)
+		pkg_set_status(pkg, stat_triggerspending);
+	else
+		pkg_set_status(pkg, stat_installed);
+	modstatdb_note(pkg);
+
+	debug(dbg_triggersdetail, "post_postinst_tasks - trig_incorporate");
+	trig_incorporate(modstatdb_get_status());
+}
+
+static void
+post_script_tasks(void)
+{
+	debug(dbg_triggersdetail, "post_script_tasks - ensure_diversions");
+	ensure_diversions();
+
+	debug(dbg_triggersdetail, "post_script_tasks - trig_incorporate");
+	trig_incorporate(modstatdb_get_status());
+}
+
+static void
+cu_post_script_tasks(int argc, void **argv)
+{
+	post_script_tasks();
+}
+
+static void
+setexecute(const char *path, struct stat *stab)
+{
+	if ((stab->st_mode & 0555) == 0555)
+		return;
+	if (!chmod(path, 0755))
+		return;
+	ohshite(_("unable to set execute permissions on `%.250s'"), path);
+}
+
+/**
+ * Returns the path to the script inside the chroot.
+ */
+static const char *
+maintscript_pre_exec(struct command *cmd)
+{
+	const char *admindir = dpkg_db_get_dir();
+	size_t instdirl = strlen(instdir);
+
+	if (*instdir) {
+		if (strncmp(admindir, instdir, instdirl) != 0)
+			ohshit(_("admindir must be inside instdir for dpkg to work properly"));
+		if (setenv("DPKG_ADMINDIR", admindir + instdirl, 1) < 0)
+			ohshite(_("unable to setenv for subprocesses"));
+
+		if (chroot(instdir))
+			ohshite(_("failed to chroot to `%.250s'"), instdir);
+	}
+	/* Switch to a known good directory to give the maintainer script
+	 * a saner environment, also needed after the chroot(). */
+	if (chdir("/"))
+		ohshite(_("failed to chdir to `%.255s'"), "/");
+	if (debug_has_flag(dbg_scripts)) {
+		struct varbuf args = VARBUF_INIT;
+		const char **argv = cmd->argv;
+
+		while (*++argv) {
+			varbuf_add_char(&args, ' ');
+			varbuf_add_str(&args, *argv);
+		}
+		varbuf_end_str(&args);
+		debug(dbg_scripts, "fork/exec %s (%s )", cmd->filename,
+		      args.buf);
+		varbuf_destroy(&args);
+	}
+	if (!instdirl)
+		return cmd->filename;
+
+	assert(strlen(cmd->filename) >= instdirl);
+	return cmd->filename + instdirl;
+}
+
+/**
+ * Set a new security execution context for the maintainer script.
+ *
+ * Try to create a new execution context based on the current one and the
+ * specific maintainer script filename. If it's the same as the current
+ * one, use the given fallback.
+ */
+static int
+maintscript_set_exec_context(struct command *cmd, const char *fallback)
+{
+	int rc = 0;
+#ifdef WITH_SELINUX
+	security_context_t curcon = NULL, newcon = NULL, filecon = NULL;
+	context_t tmpcon = NULL;
+
+	if (is_selinux_enabled() < 1)
+		return 0;
+
+	rc = getcon(&curcon);
+	if (rc < 0)
+		goto out;
+
+	rc = getfilecon(cmd->filename, &filecon);
+	if (rc < 0)
+		goto out;
+
+	rc = security_compute_create(curcon, filecon, SECCLASS_PROCESS, &newcon);
+	if (rc < 0)
+		goto out;
+
+	if (strcmp(curcon, newcon) == 0) {
+		/* No default transition, use fallback for now. */
+		rc = -1;
+		tmpcon = context_new(curcon);
+		if (tmpcon == NULL)
+			goto out;
+		if (context_type_set(tmpcon, fallback))
+			goto out;
+		freecon(newcon);
+		newcon = strdup(context_str(tmpcon));
+		if (newcon == NULL)
+			goto out;
+	}
+
+	rc = setexeccon(newcon);
+
+out:
+	if (rc < 0 && security_getenforce() == 0)
+		rc = 0;
+
+	context_free(tmpcon);
+	freecon(newcon);
+	freecon(curcon);
+	freecon(filecon);
+#endif
+
+	return rc < 0 ? rc : 0;
+}
+
+static int
+maintscript_exec(struct pkginfo *pkg, struct pkgbin *pkgbin,
+                 struct command *cmd, struct stat *stab, int warn)
+{
+	pid_t pid;
+	int rc;
+
+	setexecute(cmd->filename, stab);
+
+	push_cleanup(cu_post_script_tasks, ehflag_bombout, NULL, 0, 0);
+
+	pid = subproc_fork();
+	if (pid == 0) {
+		char *pkg_count;
+
+		m_asprintf(&pkg_count, "%d", pkgset_installed_instances(pkg->set));
+
+		if (setenv("DPKG_MAINTSCRIPT_PACKAGE", pkg->set->name, 1) ||
+		    setenv("DPKG_MAINTSCRIPT_PACKAGE_REFCOUNT", pkg_count, 1) ||
+		    setenv("DPKG_MAINTSCRIPT_ARCH", pkgbin->arch->name, 1) ||
+		    setenv("DPKG_MAINTSCRIPT_NAME", cmd->argv[0], 1) ||
+		    setenv("DPKG_RUNNING_VERSION", PACKAGE_VERSION, 1))
+			ohshite(_("unable to setenv for maintainer script"));
+
+#ifdef WITH_EXTRA_ENV
+		if (set_extra_env())
+			ohshite(_("unable to set extra env for maintainer script"));
+#endif
+
+		cmd->filename = cmd->argv[0] = maintscript_pre_exec(cmd);
+
+		if (maintscript_set_exec_context(cmd, "dpkg_script_t") < 0)
+			ohshite(_("cannot set security execution context for "
+			          "maintainer script"));
+
+		command_exec(cmd);
+	}
+	subproc_signals_setup(cmd->name); /* This does a push_cleanup(). */
+	rc = subproc_wait_check(pid, cmd->name, warn);
+	pop_cleanup(ehflag_normaltidy);
+
+	pop_cleanup(ehflag_normaltidy);
+
+	return rc;
+}
+
+static int
+vmaintscript_installed(struct pkginfo *pkg, const char *scriptname,
+                       const char *desc, va_list args)
+{
+	struct command cmd;
+	const char *scriptpath;
+	struct stat stab;
+	char buf[100];
+
+	scriptpath = pkg_infodb_get_file(pkg, &pkg->installed, scriptname);
+	sprintf(buf, _("installed %s script"), desc);
+
+	command_init(&cmd, scriptpath, buf);
+	command_add_arg(&cmd, scriptname);
+	command_add_argv(&cmd, args);
+
+	if (stat(scriptpath, &stab)) {
+		command_destroy(&cmd);
+		if (errno == ENOENT) {
+			debug(dbg_scripts,
+			      "vmaintscript_installed nonexistent %s",
+			      scriptname);
+			return 0;
+		}
+		ohshite(_("unable to stat %s `%.250s'"), buf, scriptpath);
+	}
+	maintscript_exec(pkg, &pkg->installed, &cmd, &stab, 0);
+
+	command_destroy(&cmd);
+
+	return 1;
+}
+
+/*
+ * All ...'s in maintscript_* are const char *'s.
+ */
+
+int
+maintscript_installed(struct pkginfo *pkg, const char *scriptname,
+                      const char *desc, ...)
+{
+	va_list args;
+	int rc;
+
+	va_start(args, desc);
+	rc = vmaintscript_installed(pkg, scriptname, desc, args);
+	va_end(args);
+
+	if (rc)
+		post_script_tasks();
+
+	return rc;
+}
+
+int
+maintscript_postinst(struct pkginfo *pkg, ...)
+{
+	va_list args;
+	int rc;
+
+	va_start(args, pkg);
+	rc = vmaintscript_installed(pkg, POSTINSTFILE, "post-installation", args);
+	va_end(args);
+
+	if (rc)
+		ensure_diversions();
+
+	return rc;
+}
+
+int
+maintscript_new(struct pkginfo *pkg, const char *scriptname,
+                const char *desc, const char *cidir, char *cidirrest, ...)
+{
+	struct command cmd;
+	struct stat stab;
+	va_list args;
+	char buf[100];
+
+	strcpy(cidirrest, scriptname);
+	sprintf(buf, _("new %s script"), desc);
+
+	va_start(args, cidirrest);
+	command_init(&cmd, cidir, buf);
+	command_add_arg(&cmd, scriptname);
+	command_add_argv(&cmd, args);
+	va_end(args);
+
+	if (stat(cidir, &stab)) {
+		command_destroy(&cmd);
+		if (errno == ENOENT) {
+			debug(dbg_scripts,
+			      "maintscript_new nonexistent %s '%s'",
+			      scriptname, cidir);
+			return 0;
+		}
+		ohshite(_("unable to stat %s `%.250s'"), buf, cidir);
+	}
+	maintscript_exec(pkg, &pkg->available, &cmd, &stab, 0);
+
+	command_destroy(&cmd);
+	post_script_tasks();
+
+	return 1;
+}
+
+int
+maintscript_fallback(struct pkginfo *pkg,
+                     const char *scriptname, const char *desc,
+                     const char *cidir, char *cidirrest,
+                     const char *ifok, const char *iffallback)
+{
+	struct command cmd;
+	const char *oldscriptpath;
+	struct stat stab;
+	char buf[100];
+
+	oldscriptpath = pkg_infodb_get_file(pkg, &pkg->installed, scriptname);
+	sprintf(buf, _("old %s script"), desc);
+
+	command_init(&cmd, oldscriptpath, buf);
+	command_add_args(&cmd, scriptname, ifok,
+	                 versiondescribe(&pkg->available.version, vdew_nonambig),
+	                 NULL);
+
+	if (stat(oldscriptpath, &stab)) {
+		if (errno == ENOENT) {
+			debug(dbg_scripts,
+			      "maintscript_fallback nonexistent %s '%s'",
+			      scriptname, oldscriptpath);
+			command_destroy(&cmd);
+			return 0;
+		}
+		warning(_("unable to stat %s '%.250s': %s"),
+		        cmd.name, oldscriptpath, strerror(errno));
+	} else {
+		if (!maintscript_exec(pkg, &pkg->installed, &cmd, &stab, PROCWARN)) {
+			command_destroy(&cmd);
+			post_script_tasks();
+			return 1;
+		}
+	}
+	notice(_("trying script from the new package instead ..."));
+
+	strcpy(cidirrest, scriptname);
+	sprintf(buf, _("new %s script"), desc);
+
+	command_destroy(&cmd);
+	command_init(&cmd, cidir, buf);
+	command_add_args(&cmd, scriptname, iffallback,
+	                 versiondescribe(&pkg->installed.version, vdew_nonambig),
+	                 NULL);
+
+	if (stat(cidir, &stab)) {
+		command_destroy(&cmd);
+		if (errno == ENOENT)
+			ohshit(_("there is no script in the new version of the package - giving up"));
+		else
+			ohshite(_("unable to stat %s `%.250s'"), buf, cidir);
+	}
+
+	maintscript_exec(pkg, &pkg->available, &cmd, &stab, 0);
+	notice(_("... it looks like that went OK"));
+
+	command_destroy(&cmd);
+	post_script_tasks();
+
+	return 1;
+}
+
+#ifdef WITH_EXTRA_ENV
+int
+set_extra_env() {
+	return 0;
+}
+#endif
